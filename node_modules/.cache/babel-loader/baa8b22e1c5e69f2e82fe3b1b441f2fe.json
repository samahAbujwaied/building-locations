{"ast":null,"code":"function _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*\nStimulus 3.2.1\nCopyright Â© 2023 Basecamp, LLC\n */\nvar EventListener = /*#__PURE__*/function () {\n  function EventListener(eventTarget, eventName, eventOptions) {\n    _classCallCheck(this, EventListener);\n    this.eventTarget = eventTarget;\n    this.eventName = eventName;\n    this.eventOptions = eventOptions;\n    this.unorderedBindings = new Set();\n  }\n  return _createClass(EventListener, [{\n    key: \"connect\",\n    value: function connect() {\n      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);\n    }\n  }, {\n    key: \"bindingConnected\",\n    value: function bindingConnected(binding) {\n      this.unorderedBindings.add(binding);\n    }\n  }, {\n    key: \"bindingDisconnected\",\n    value: function bindingDisconnected(binding) {\n      this.unorderedBindings[\"delete\"](binding);\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      var extendedEvent = extendEvent(event);\n      var _iterator = _createForOfIteratorHelper(this.bindings),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var binding = _step.value;\n          if (extendedEvent.immediatePropagationStopped) {\n            break;\n          } else {\n            binding.handleEvent(extendedEvent);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"hasBindings\",\n    value: function hasBindings() {\n      return this.unorderedBindings.size > 0;\n    }\n  }, {\n    key: \"bindings\",\n    get: function get() {\n      return Array.from(this.unorderedBindings).sort(function (left, right) {\n        var leftIndex = left.index,\n          rightIndex = right.index;\n        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;\n      });\n    }\n  }]);\n}();\nfunction extendEvent(event) {\n  if (\"immediatePropagationStopped\" in event) {\n    return event;\n  } else {\n    var _stopImmediatePropagation = event.stopImmediatePropagation;\n    return Object.assign(event, {\n      immediatePropagationStopped: false,\n      stopImmediatePropagation: function stopImmediatePropagation() {\n        this.immediatePropagationStopped = true;\n        _stopImmediatePropagation.call(this);\n      }\n    });\n  }\n}\nvar Dispatcher = /*#__PURE__*/function () {\n  function Dispatcher(application) {\n    _classCallCheck(this, Dispatcher);\n    this.application = application;\n    this.eventListenerMaps = new Map();\n    this.started = false;\n  }\n  return _createClass(Dispatcher, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        this.started = true;\n        this.eventListeners.forEach(function (eventListener) {\n          return eventListener.connect();\n        });\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.started = false;\n        this.eventListeners.forEach(function (eventListener) {\n          return eventListener.disconnect();\n        });\n      }\n    }\n  }, {\n    key: \"eventListeners\",\n    get: function get() {\n      return Array.from(this.eventListenerMaps.values()).reduce(function (listeners, map) {\n        return listeners.concat(Array.from(map.values()));\n      }, []);\n    }\n  }, {\n    key: \"bindingConnected\",\n    value: function bindingConnected(binding) {\n      this.fetchEventListenerForBinding(binding).bindingConnected(binding);\n    }\n  }, {\n    key: \"bindingDisconnected\",\n    value: function bindingDisconnected(binding) {\n      var clearEventListeners = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);\n      if (clearEventListeners) this.clearEventListenersForBinding(binding);\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(error, message) {\n      var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.application.handleError(error, \"Error \".concat(message), detail);\n    }\n  }, {\n    key: \"clearEventListenersForBinding\",\n    value: function clearEventListenersForBinding(binding) {\n      var eventListener = this.fetchEventListenerForBinding(binding);\n      if (!eventListener.hasBindings()) {\n        eventListener.disconnect();\n        this.removeMappedEventListenerFor(binding);\n      }\n    }\n  }, {\n    key: \"removeMappedEventListenerFor\",\n    value: function removeMappedEventListenerFor(binding) {\n      var eventTarget = binding.eventTarget,\n        eventName = binding.eventName,\n        eventOptions = binding.eventOptions;\n      var eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);\n      var cacheKey = this.cacheKey(eventName, eventOptions);\n      eventListenerMap[\"delete\"](cacheKey);\n      if (eventListenerMap.size == 0) this.eventListenerMaps[\"delete\"](eventTarget);\n    }\n  }, {\n    key: \"fetchEventListenerForBinding\",\n    value: function fetchEventListenerForBinding(binding) {\n      var eventTarget = binding.eventTarget,\n        eventName = binding.eventName,\n        eventOptions = binding.eventOptions;\n      return this.fetchEventListener(eventTarget, eventName, eventOptions);\n    }\n  }, {\n    key: \"fetchEventListener\",\n    value: function fetchEventListener(eventTarget, eventName, eventOptions) {\n      var eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);\n      var cacheKey = this.cacheKey(eventName, eventOptions);\n      var eventListener = eventListenerMap.get(cacheKey);\n      if (!eventListener) {\n        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);\n        eventListenerMap.set(cacheKey, eventListener);\n      }\n      return eventListener;\n    }\n  }, {\n    key: \"createEventListener\",\n    value: function createEventListener(eventTarget, eventName, eventOptions) {\n      var eventListener = new EventListener(eventTarget, eventName, eventOptions);\n      if (this.started) {\n        eventListener.connect();\n      }\n      return eventListener;\n    }\n  }, {\n    key: \"fetchEventListenerMapForEventTarget\",\n    value: function fetchEventListenerMapForEventTarget(eventTarget) {\n      var eventListenerMap = this.eventListenerMaps.get(eventTarget);\n      if (!eventListenerMap) {\n        eventListenerMap = new Map();\n        this.eventListenerMaps.set(eventTarget, eventListenerMap);\n      }\n      return eventListenerMap;\n    }\n  }, {\n    key: \"cacheKey\",\n    value: function cacheKey(eventName, eventOptions) {\n      var parts = [eventName];\n      Object.keys(eventOptions).sort().forEach(function (key) {\n        parts.push(\"\".concat(eventOptions[key] ? \"\" : \"!\").concat(key));\n      });\n      return parts.join(\":\");\n    }\n  }]);\n}();\nvar defaultActionDescriptorFilters = {\n  stop: function stop(_ref) {\n    var event = _ref.event,\n      value = _ref.value;\n    if (value) event.stopPropagation();\n    return true;\n  },\n  prevent: function prevent(_ref2) {\n    var event = _ref2.event,\n      value = _ref2.value;\n    if (value) event.preventDefault();\n    return true;\n  },\n  self: function self(_ref3) {\n    var event = _ref3.event,\n      value = _ref3.value,\n      element = _ref3.element;\n    if (value) {\n      return element === event.target;\n    } else {\n      return true;\n    }\n  }\n};\nvar descriptorPattern = /^(?:(?:([^.]+?)\\+)?(.+?)(?:\\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;\nfunction parseActionDescriptorString(descriptorString) {\n  var source = descriptorString.trim();\n  var matches = source.match(descriptorPattern) || [];\n  var eventName = matches[2];\n  var keyFilter = matches[3];\n  if (keyFilter && ![\"keydown\", \"keyup\", \"keypress\"].includes(eventName)) {\n    eventName += \".\".concat(keyFilter);\n    keyFilter = \"\";\n  }\n  return {\n    eventTarget: parseEventTarget(matches[4]),\n    eventName: eventName,\n    eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},\n    identifier: matches[5],\n    methodName: matches[6],\n    keyFilter: matches[1] || keyFilter\n  };\n}\nfunction parseEventTarget(eventTargetName) {\n  if (eventTargetName == \"window\") {\n    return window;\n  } else if (eventTargetName == \"document\") {\n    return document;\n  }\n}\nfunction parseEventOptions(eventOptions) {\n  return eventOptions.split(\":\").reduce(function (options, token) {\n    return Object.assign(options, _defineProperty({}, token.replace(/^!/, \"\"), !/^!/.test(token)));\n  }, {});\n}\nfunction stringifyEventTarget(eventTarget) {\n  if (eventTarget == window) {\n    return \"window\";\n  } else if (eventTarget == document) {\n    return \"document\";\n  }\n}\nfunction camelize(value) {\n  return value.replace(/(?:[_-])([a-z0-9])/g, function (_, _char) {\n    return _char.toUpperCase();\n  });\n}\nfunction namespaceCamelize(value) {\n  return camelize(value.replace(/--/g, \"-\").replace(/__/g, \"_\"));\n}\nfunction capitalize(value) {\n  return value.charAt(0).toUpperCase() + value.slice(1);\n}\nfunction dasherize(value) {\n  return value.replace(/([A-Z])/g, function (_, _char2) {\n    return \"-\".concat(_char2.toLowerCase());\n  });\n}\nfunction tokenize(value) {\n  return value.match(/[^\\s]+/g) || [];\n}\nfunction isSomething(object) {\n  return object !== null && object !== undefined;\n}\nfunction hasProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\nvar allModifiers = [\"meta\", \"ctrl\", \"alt\", \"shift\"];\nvar Action = /*#__PURE__*/function () {\n  function Action(element, index, descriptor, schema) {\n    _classCallCheck(this, Action);\n    this.element = element;\n    this.index = index;\n    this.eventTarget = descriptor.eventTarget || element;\n    this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error(\"missing event name\");\n    this.eventOptions = descriptor.eventOptions || {};\n    this.identifier = descriptor.identifier || error(\"missing identifier\");\n    this.methodName = descriptor.methodName || error(\"missing method name\");\n    this.keyFilter = descriptor.keyFilter || \"\";\n    this.schema = schema;\n  }\n  return _createClass(Action, [{\n    key: \"toString\",\n    value: function toString() {\n      var eventFilter = this.keyFilter ? \".\".concat(this.keyFilter) : \"\";\n      var eventTarget = this.eventTargetName ? \"@\".concat(this.eventTargetName) : \"\";\n      return \"\".concat(this.eventName).concat(eventFilter).concat(eventTarget, \"->\").concat(this.identifier, \"#\").concat(this.methodName);\n    }\n  }, {\n    key: \"shouldIgnoreKeyboardEvent\",\n    value: function shouldIgnoreKeyboardEvent(event) {\n      if (!this.keyFilter) {\n        return false;\n      }\n      var filters = this.keyFilter.split(\"+\");\n      if (this.keyFilterDissatisfied(event, filters)) {\n        return true;\n      }\n      var standardFilter = filters.filter(function (key) {\n        return !allModifiers.includes(key);\n      })[0];\n      if (!standardFilter) {\n        return false;\n      }\n      if (!hasProperty(this.keyMappings, standardFilter)) {\n        error(\"contains unknown key filter: \".concat(this.keyFilter));\n      }\n      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();\n    }\n  }, {\n    key: \"shouldIgnoreMouseEvent\",\n    value: function shouldIgnoreMouseEvent(event) {\n      if (!this.keyFilter) {\n        return false;\n      }\n      var filters = [this.keyFilter];\n      if (this.keyFilterDissatisfied(event, filters)) {\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"params\",\n    get: function get() {\n      var params = {};\n      var pattern = new RegExp(\"^data-\".concat(this.identifier, \"-(.+)-param$\"), \"i\");\n      for (var _i = 0, _Array$from = Array.from(this.element.attributes); _i < _Array$from.length; _i++) {\n        var _ref4 = _Array$from[_i];\n        var name = _ref4.name;\n        var value = _ref4.value;\n        var match = name.match(pattern);\n        var key = match && match[1];\n        if (key) {\n          params[camelize(key)] = typecast(value);\n        }\n      }\n      return params;\n    }\n  }, {\n    key: \"eventTargetName\",\n    get: function get() {\n      return stringifyEventTarget(this.eventTarget);\n    }\n  }, {\n    key: \"keyMappings\",\n    get: function get() {\n      return this.schema.keyMappings;\n    }\n  }, {\n    key: \"keyFilterDissatisfied\",\n    value: function keyFilterDissatisfied(event, filters) {\n      var _allModifiers$map = allModifiers.map(function (modifier) {\n          return filters.includes(modifier);\n        }),\n        _allModifiers$map2 = _slicedToArray(_allModifiers$map, 4),\n        meta = _allModifiers$map2[0],\n        ctrl = _allModifiers$map2[1],\n        alt = _allModifiers$map2[2],\n        shift = _allModifiers$map2[3];\n      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;\n    }\n  }], [{\n    key: \"forToken\",\n    value: function forToken(token, schema) {\n      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);\n    }\n  }]);\n}();\nvar defaultEventNames = {\n  a: function a() {\n    return \"click\";\n  },\n  button: function button() {\n    return \"click\";\n  },\n  form: function form() {\n    return \"submit\";\n  },\n  details: function details() {\n    return \"toggle\";\n  },\n  input: function input(e) {\n    return e.getAttribute(\"type\") == \"submit\" ? \"click\" : \"input\";\n  },\n  select: function select() {\n    return \"change\";\n  },\n  textarea: function textarea() {\n    return \"input\";\n  }\n};\nfunction getDefaultEventNameForElement(element) {\n  var tagName = element.tagName.toLowerCase();\n  if (tagName in defaultEventNames) {\n    return defaultEventNames[tagName](element);\n  }\n}\nfunction error(message) {\n  throw new Error(message);\n}\nfunction typecast(value) {\n  try {\n    return JSON.parse(value);\n  } catch (o_O) {\n    return value;\n  }\n}\nvar Binding = /*#__PURE__*/function () {\n  function Binding(context, action) {\n    _classCallCheck(this, Binding);\n    this.context = context;\n    this.action = action;\n  }\n  return _createClass(Binding, [{\n    key: \"index\",\n    get: function get() {\n      return this.action.index;\n    }\n  }, {\n    key: \"eventTarget\",\n    get: function get() {\n      return this.action.eventTarget;\n    }\n  }, {\n    key: \"eventOptions\",\n    get: function get() {\n      return this.action.eventOptions;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.context.identifier;\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      var actionEvent = this.prepareActionEvent(event);\n      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {\n        this.invokeWithEvent(actionEvent);\n      }\n    }\n  }, {\n    key: \"eventName\",\n    get: function get() {\n      return this.action.eventName;\n    }\n  }, {\n    key: \"method\",\n    get: function get() {\n      var method = this.controller[this.methodName];\n      if (typeof method == \"function\") {\n        return method;\n      }\n      throw new Error(\"Action \\\"\".concat(this.action, \"\\\" references undefined method \\\"\").concat(this.methodName, \"\\\"\"));\n    }\n  }, {\n    key: \"applyEventModifiers\",\n    value: function applyEventModifiers(event) {\n      var element = this.action.element;\n      var actionDescriptorFilters = this.context.application.actionDescriptorFilters;\n      var controller = this.context.controller;\n      var passes = true;\n      for (var _i2 = 0, _Object$entries = Object.entries(this.eventOptions); _i2 < _Object$entries.length; _i2++) {\n        var _ref5 = _Object$entries[_i2];\n        var _ref6 = _slicedToArray(_ref5, 2);\n        var name = _ref6[0];\n        var value = _ref6[1];\n        if (name in actionDescriptorFilters) {\n          var filter = actionDescriptorFilters[name];\n          passes = passes && filter({\n            name: name,\n            value: value,\n            event: event,\n            element: element,\n            controller: controller\n          });\n        } else {\n          continue;\n        }\n      }\n      return passes;\n    }\n  }, {\n    key: \"prepareActionEvent\",\n    value: function prepareActionEvent(event) {\n      return Object.assign(event, {\n        params: this.action.params\n      });\n    }\n  }, {\n    key: \"invokeWithEvent\",\n    value: function invokeWithEvent(event) {\n      var target = event.target,\n        currentTarget = event.currentTarget;\n      try {\n        this.method.call(this.controller, event);\n        this.context.logDebugActivity(this.methodName, {\n          event: event,\n          target: target,\n          currentTarget: currentTarget,\n          action: this.methodName\n        });\n      } catch (error) {\n        var identifier = this.identifier,\n          controller = this.controller,\n          element = this.element,\n          index = this.index;\n        var detail = {\n          identifier: identifier,\n          controller: controller,\n          element: element,\n          index: index,\n          event: event\n        };\n        this.context.handleError(error, \"invoking action \\\"\".concat(this.action, \"\\\"\"), detail);\n      }\n    }\n  }, {\n    key: \"willBeInvokedByEvent\",\n    value: function willBeInvokedByEvent(event) {\n      var eventTarget = event.target;\n      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {\n        return false;\n      }\n      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {\n        return false;\n      }\n      if (this.element === eventTarget) {\n        return true;\n      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {\n        return this.scope.containsElement(eventTarget);\n      } else {\n        return this.scope.containsElement(this.action.element);\n      }\n    }\n  }, {\n    key: \"controller\",\n    get: function get() {\n      return this.context.controller;\n    }\n  }, {\n    key: \"methodName\",\n    get: function get() {\n      return this.action.methodName;\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.scope.element;\n    }\n  }, {\n    key: \"scope\",\n    get: function get() {\n      return this.context.scope;\n    }\n  }]);\n}();\nvar ElementObserver = /*#__PURE__*/function () {\n  function ElementObserver(element, delegate) {\n    var _this = this;\n    _classCallCheck(this, ElementObserver);\n    this.mutationObserverInit = {\n      attributes: true,\n      childList: true,\n      subtree: true\n    };\n    this.element = element;\n    this.started = false;\n    this.delegate = delegate;\n    this.elements = new Set();\n    this.mutationObserver = new MutationObserver(function (mutations) {\n      return _this.processMutations(mutations);\n    });\n  }\n  return _createClass(ElementObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        this.started = true;\n        this.mutationObserver.observe(this.element, this.mutationObserverInit);\n        this.refresh();\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause(callback) {\n      if (this.started) {\n        this.mutationObserver.disconnect();\n        this.started = false;\n      }\n      callback();\n      if (!this.started) {\n        this.mutationObserver.observe(this.element, this.mutationObserverInit);\n        this.started = true;\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.mutationObserver.takeRecords();\n        this.mutationObserver.disconnect();\n        this.started = false;\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      if (this.started) {\n        var matches = new Set(this.matchElementsInTree());\n        for (var _i3 = 0, _Array$from2 = Array.from(this.elements); _i3 < _Array$from2.length; _i3++) {\n          var element = _Array$from2[_i3];\n          if (!matches.has(element)) {\n            this.removeElement(element);\n          }\n        }\n        for (var _i4 = 0, _Array$from3 = Array.from(matches); _i4 < _Array$from3.length; _i4++) {\n          var _element2 = _Array$from3[_i4];\n          this.addElement(_element2);\n        }\n      }\n    }\n  }, {\n    key: \"processMutations\",\n    value: function processMutations(mutations) {\n      if (this.started) {\n        var _iterator2 = _createForOfIteratorHelper(mutations),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var mutation = _step2.value;\n            this.processMutation(mutation);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }, {\n    key: \"processMutation\",\n    value: function processMutation(mutation) {\n      if (mutation.type == \"attributes\") {\n        this.processAttributeChange(mutation.target, mutation.attributeName);\n      } else if (mutation.type == \"childList\") {\n        this.processRemovedNodes(mutation.removedNodes);\n        this.processAddedNodes(mutation.addedNodes);\n      }\n    }\n  }, {\n    key: \"processAttributeChange\",\n    value: function processAttributeChange(element, attributeName) {\n      if (this.elements.has(element)) {\n        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {\n          this.delegate.elementAttributeChanged(element, attributeName);\n        } else {\n          this.removeElement(element);\n        }\n      } else if (this.matchElement(element)) {\n        this.addElement(element);\n      }\n    }\n  }, {\n    key: \"processRemovedNodes\",\n    value: function processRemovedNodes(nodes) {\n      for (var _i5 = 0, _Array$from4 = Array.from(nodes); _i5 < _Array$from4.length; _i5++) {\n        var node = _Array$from4[_i5];\n        var element = this.elementFromNode(node);\n        if (element) {\n          this.processTree(element, this.removeElement);\n        }\n      }\n    }\n  }, {\n    key: \"processAddedNodes\",\n    value: function processAddedNodes(nodes) {\n      for (var _i6 = 0, _Array$from5 = Array.from(nodes); _i6 < _Array$from5.length; _i6++) {\n        var node = _Array$from5[_i6];\n        var element = this.elementFromNode(node);\n        if (element && this.elementIsActive(element)) {\n          this.processTree(element, this.addElement);\n        }\n      }\n    }\n  }, {\n    key: \"matchElement\",\n    value: function matchElement(element) {\n      return this.delegate.matchElement(element);\n    }\n  }, {\n    key: \"matchElementsInTree\",\n    value: function matchElementsInTree() {\n      var tree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element;\n      return this.delegate.matchElementsInTree(tree);\n    }\n  }, {\n    key: \"processTree\",\n    value: function processTree(tree, processor) {\n      var _iterator3 = _createForOfIteratorHelper(this.matchElementsInTree(tree)),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var element = _step3.value;\n          processor.call(this, element);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"elementFromNode\",\n    value: function elementFromNode(node) {\n      if (node.nodeType == Node.ELEMENT_NODE) {\n        return node;\n      }\n    }\n  }, {\n    key: \"elementIsActive\",\n    value: function elementIsActive(element) {\n      if (element.isConnected != this.element.isConnected) {\n        return false;\n      } else {\n        return this.element.contains(element);\n      }\n    }\n  }, {\n    key: \"addElement\",\n    value: function addElement(element) {\n      if (!this.elements.has(element)) {\n        if (this.elementIsActive(element)) {\n          this.elements.add(element);\n          if (this.delegate.elementMatched) {\n            this.delegate.elementMatched(element);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeElement\",\n    value: function removeElement(element) {\n      if (this.elements.has(element)) {\n        this.elements[\"delete\"](element);\n        if (this.delegate.elementUnmatched) {\n          this.delegate.elementUnmatched(element);\n        }\n      }\n    }\n  }]);\n}();\nvar AttributeObserver = /*#__PURE__*/function () {\n  function AttributeObserver(element, attributeName, delegate) {\n    _classCallCheck(this, AttributeObserver);\n    this.attributeName = attributeName;\n    this.delegate = delegate;\n    this.elementObserver = new ElementObserver(element, this);\n  }\n  return _createClass(AttributeObserver, [{\n    key: \"element\",\n    get: function get() {\n      return this.elementObserver.element;\n    }\n  }, {\n    key: \"selector\",\n    get: function get() {\n      return \"[\".concat(this.attributeName, \"]\");\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.elementObserver.start();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause(callback) {\n      this.elementObserver.pause(callback);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.elementObserver.stop();\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.elementObserver.refresh();\n    }\n  }, {\n    key: \"started\",\n    get: function get() {\n      return this.elementObserver.started;\n    }\n  }, {\n    key: \"matchElement\",\n    value: function matchElement(element) {\n      return element.hasAttribute(this.attributeName);\n    }\n  }, {\n    key: \"matchElementsInTree\",\n    value: function matchElementsInTree(tree) {\n      var match = this.matchElement(tree) ? [tree] : [];\n      var matches = Array.from(tree.querySelectorAll(this.selector));\n      return match.concat(matches);\n    }\n  }, {\n    key: \"elementMatched\",\n    value: function elementMatched(element) {\n      if (this.delegate.elementMatchedAttribute) {\n        this.delegate.elementMatchedAttribute(element, this.attributeName);\n      }\n    }\n  }, {\n    key: \"elementUnmatched\",\n    value: function elementUnmatched(element) {\n      if (this.delegate.elementUnmatchedAttribute) {\n        this.delegate.elementUnmatchedAttribute(element, this.attributeName);\n      }\n    }\n  }, {\n    key: \"elementAttributeChanged\",\n    value: function elementAttributeChanged(element, attributeName) {\n      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {\n        this.delegate.elementAttributeValueChanged(element, attributeName);\n      }\n    }\n  }]);\n}();\nfunction _add(map, key, value) {\n  fetch(map, key).add(value);\n}\nfunction del(map, key, value) {\n  fetch(map, key)[\"delete\"](value);\n  prune(map, key);\n}\nfunction fetch(map, key) {\n  var values = map.get(key);\n  if (!values) {\n    values = new Set();\n    map.set(key, values);\n  }\n  return values;\n}\nfunction prune(map, key) {\n  var values = map.get(key);\n  if (values != null && values.size == 0) {\n    map[\"delete\"](key);\n  }\n}\nvar Multimap = /*#__PURE__*/function () {\n  function Multimap() {\n    _classCallCheck(this, Multimap);\n    this.valuesByKey = new Map();\n  }\n  return _createClass(Multimap, [{\n    key: \"keys\",\n    get: function get() {\n      return Array.from(this.valuesByKey.keys());\n    }\n  }, {\n    key: \"values\",\n    get: function get() {\n      var sets = Array.from(this.valuesByKey.values());\n      return sets.reduce(function (values, set) {\n        return values.concat(Array.from(set));\n      }, []);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      var sets = Array.from(this.valuesByKey.values());\n      return sets.reduce(function (size, set) {\n        return size + set.size;\n      }, 0);\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, value) {\n      _add(this.valuesByKey, key, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key, value) {\n      del(this.valuesByKey, key, value);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key, value) {\n      var values = this.valuesByKey.get(key);\n      return values != null && values.has(value);\n    }\n  }, {\n    key: \"hasKey\",\n    value: function hasKey(key) {\n      return this.valuesByKey.has(key);\n    }\n  }, {\n    key: \"hasValue\",\n    value: function hasValue(value) {\n      var sets = Array.from(this.valuesByKey.values());\n      return sets.some(function (set) {\n        return set.has(value);\n      });\n    }\n  }, {\n    key: \"getValuesForKey\",\n    value: function getValuesForKey(key) {\n      var values = this.valuesByKey.get(key);\n      return values ? Array.from(values) : [];\n    }\n  }, {\n    key: \"getKeysForValue\",\n    value: function getKeysForValue(value) {\n      return Array.from(this.valuesByKey).filter(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n          _key = _ref8[0],\n          values = _ref8[1];\n        return values.has(value);\n      }).map(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n          key = _ref10[0],\n          _values = _ref10[1];\n        return key;\n      });\n    }\n  }]);\n}();\nvar IndexedMultimap = /*#__PURE__*/function (_Multimap) {\n  function IndexedMultimap() {\n    var _this2;\n    _classCallCheck(this, IndexedMultimap);\n    _this2 = _callSuper(this, IndexedMultimap);\n    _this2.keysByValue = new Map();\n    return _this2;\n  }\n  _inherits(IndexedMultimap, _Multimap);\n  return _createClass(IndexedMultimap, [{\n    key: \"values\",\n    get: function get() {\n      return Array.from(this.keysByValue.keys());\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, value) {\n      _superPropGet(IndexedMultimap, \"add\", this, 3)([key, value]);\n      _add(this.keysByValue, value, key);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key, value) {\n      _superPropGet(IndexedMultimap, \"delete\", this, 3)([key, value]);\n      del(this.keysByValue, value, key);\n    }\n  }, {\n    key: \"hasValue\",\n    value: function hasValue(value) {\n      return this.keysByValue.has(value);\n    }\n  }, {\n    key: \"getKeysForValue\",\n    value: function getKeysForValue(value) {\n      var set = this.keysByValue.get(value);\n      return set ? Array.from(set) : [];\n    }\n  }]);\n}(Multimap);\nvar SelectorObserver = /*#__PURE__*/function () {\n  function SelectorObserver(element, selector, delegate, details) {\n    _classCallCheck(this, SelectorObserver);\n    this._selector = selector;\n    this.details = details;\n    this.elementObserver = new ElementObserver(element, this);\n    this.delegate = delegate;\n    this.matchesByElement = new Multimap();\n  }\n  return _createClass(SelectorObserver, [{\n    key: \"started\",\n    get: function get() {\n      return this.elementObserver.started;\n    }\n  }, {\n    key: \"selector\",\n    get: function get() {\n      return this._selector;\n    },\n    set: function set(selector) {\n      this._selector = selector;\n      this.refresh();\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.elementObserver.start();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause(callback) {\n      this.elementObserver.pause(callback);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.elementObserver.stop();\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.elementObserver.refresh();\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.elementObserver.element;\n    }\n  }, {\n    key: \"matchElement\",\n    value: function matchElement(element) {\n      var selector = this.selector;\n      if (selector) {\n        var matches = element.matches(selector);\n        if (this.delegate.selectorMatchElement) {\n          return matches && this.delegate.selectorMatchElement(element, this.details);\n        }\n        return matches;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"matchElementsInTree\",\n    value: function matchElementsInTree(tree) {\n      var _this3 = this;\n      var selector = this.selector;\n      if (selector) {\n        var match = this.matchElement(tree) ? [tree] : [];\n        var matches = Array.from(tree.querySelectorAll(selector)).filter(function (match) {\n          return _this3.matchElement(match);\n        });\n        return match.concat(matches);\n      } else {\n        return [];\n      }\n    }\n  }, {\n    key: \"elementMatched\",\n    value: function elementMatched(element) {\n      var selector = this.selector;\n      if (selector) {\n        this.selectorMatched(element, selector);\n      }\n    }\n  }, {\n    key: \"elementUnmatched\",\n    value: function elementUnmatched(element) {\n      var selectors = this.matchesByElement.getKeysForValue(element);\n      var _iterator4 = _createForOfIteratorHelper(selectors),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var selector = _step4.value;\n          this.selectorUnmatched(element, selector);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"elementAttributeChanged\",\n    value: function elementAttributeChanged(element, _attributeName) {\n      var selector = this.selector;\n      if (selector) {\n        var matches = this.matchElement(element);\n        var matchedBefore = this.matchesByElement.has(selector, element);\n        if (matches && !matchedBefore) {\n          this.selectorMatched(element, selector);\n        } else if (!matches && matchedBefore) {\n          this.selectorUnmatched(element, selector);\n        }\n      }\n    }\n  }, {\n    key: \"selectorMatched\",\n    value: function selectorMatched(element, selector) {\n      this.delegate.selectorMatched(element, selector, this.details);\n      this.matchesByElement.add(selector, element);\n    }\n  }, {\n    key: \"selectorUnmatched\",\n    value: function selectorUnmatched(element, selector) {\n      this.delegate.selectorUnmatched(element, selector, this.details);\n      this.matchesByElement[\"delete\"](selector, element);\n    }\n  }]);\n}();\nvar StringMapObserver = /*#__PURE__*/function () {\n  function StringMapObserver(element, delegate) {\n    var _this4 = this;\n    _classCallCheck(this, StringMapObserver);\n    this.element = element;\n    this.delegate = delegate;\n    this.started = false;\n    this.stringMap = new Map();\n    this.mutationObserver = new MutationObserver(function (mutations) {\n      return _this4.processMutations(mutations);\n    });\n  }\n  return _createClass(StringMapObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        this.started = true;\n        this.mutationObserver.observe(this.element, {\n          attributes: true,\n          attributeOldValue: true\n        });\n        this.refresh();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.mutationObserver.takeRecords();\n        this.mutationObserver.disconnect();\n        this.started = false;\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      if (this.started) {\n        var _iterator5 = _createForOfIteratorHelper(this.knownAttributeNames),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var attributeName = _step5.value;\n            this.refreshAttribute(attributeName, null);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    }\n  }, {\n    key: \"processMutations\",\n    value: function processMutations(mutations) {\n      if (this.started) {\n        var _iterator6 = _createForOfIteratorHelper(mutations),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var mutation = _step6.value;\n            this.processMutation(mutation);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n    }\n  }, {\n    key: \"processMutation\",\n    value: function processMutation(mutation) {\n      var attributeName = mutation.attributeName;\n      if (attributeName) {\n        this.refreshAttribute(attributeName, mutation.oldValue);\n      }\n    }\n  }, {\n    key: \"refreshAttribute\",\n    value: function refreshAttribute(attributeName, oldValue) {\n      var key = this.delegate.getStringMapKeyForAttribute(attributeName);\n      if (key != null) {\n        if (!this.stringMap.has(attributeName)) {\n          this.stringMapKeyAdded(key, attributeName);\n        }\n        var value = this.element.getAttribute(attributeName);\n        if (this.stringMap.get(attributeName) != value) {\n          this.stringMapValueChanged(value, key, oldValue);\n        }\n        if (value == null) {\n          var _oldValue = this.stringMap.get(attributeName);\n          this.stringMap[\"delete\"](attributeName);\n          if (_oldValue) this.stringMapKeyRemoved(key, attributeName, _oldValue);\n        } else {\n          this.stringMap.set(attributeName, value);\n        }\n      }\n    }\n  }, {\n    key: \"stringMapKeyAdded\",\n    value: function stringMapKeyAdded(key, attributeName) {\n      if (this.delegate.stringMapKeyAdded) {\n        this.delegate.stringMapKeyAdded(key, attributeName);\n      }\n    }\n  }, {\n    key: \"stringMapValueChanged\",\n    value: function stringMapValueChanged(value, key, oldValue) {\n      if (this.delegate.stringMapValueChanged) {\n        this.delegate.stringMapValueChanged(value, key, oldValue);\n      }\n    }\n  }, {\n    key: \"stringMapKeyRemoved\",\n    value: function stringMapKeyRemoved(key, attributeName, oldValue) {\n      if (this.delegate.stringMapKeyRemoved) {\n        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);\n      }\n    }\n  }, {\n    key: \"knownAttributeNames\",\n    get: function get() {\n      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));\n    }\n  }, {\n    key: \"currentAttributeNames\",\n    get: function get() {\n      return Array.from(this.element.attributes).map(function (attribute) {\n        return attribute.name;\n      });\n    }\n  }, {\n    key: \"recordedAttributeNames\",\n    get: function get() {\n      return Array.from(this.stringMap.keys());\n    }\n  }]);\n}();\nvar TokenListObserver = /*#__PURE__*/function () {\n  function TokenListObserver(element, attributeName, delegate) {\n    _classCallCheck(this, TokenListObserver);\n    this.attributeObserver = new AttributeObserver(element, attributeName, this);\n    this.delegate = delegate;\n    this.tokensByElement = new Multimap();\n  }\n  return _createClass(TokenListObserver, [{\n    key: \"started\",\n    get: function get() {\n      return this.attributeObserver.started;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.attributeObserver.start();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause(callback) {\n      this.attributeObserver.pause(callback);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.attributeObserver.stop();\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.attributeObserver.refresh();\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.attributeObserver.element;\n    }\n  }, {\n    key: \"attributeName\",\n    get: function get() {\n      return this.attributeObserver.attributeName;\n    }\n  }, {\n    key: \"elementMatchedAttribute\",\n    value: function elementMatchedAttribute(element) {\n      this.tokensMatched(this.readTokensForElement(element));\n    }\n  }, {\n    key: \"elementAttributeValueChanged\",\n    value: function elementAttributeValueChanged(element) {\n      var _this$refreshTokensFo = this.refreshTokensForElement(element),\n        _this$refreshTokensFo2 = _slicedToArray(_this$refreshTokensFo, 2),\n        unmatchedTokens = _this$refreshTokensFo2[0],\n        matchedTokens = _this$refreshTokensFo2[1];\n      this.tokensUnmatched(unmatchedTokens);\n      this.tokensMatched(matchedTokens);\n    }\n  }, {\n    key: \"elementUnmatchedAttribute\",\n    value: function elementUnmatchedAttribute(element) {\n      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));\n    }\n  }, {\n    key: \"tokensMatched\",\n    value: function tokensMatched(tokens) {\n      var _this5 = this;\n      tokens.forEach(function (token) {\n        return _this5.tokenMatched(token);\n      });\n    }\n  }, {\n    key: \"tokensUnmatched\",\n    value: function tokensUnmatched(tokens) {\n      var _this6 = this;\n      tokens.forEach(function (token) {\n        return _this6.tokenUnmatched(token);\n      });\n    }\n  }, {\n    key: \"tokenMatched\",\n    value: function tokenMatched(token) {\n      this.delegate.tokenMatched(token);\n      this.tokensByElement.add(token.element, token);\n    }\n  }, {\n    key: \"tokenUnmatched\",\n    value: function tokenUnmatched(token) {\n      this.delegate.tokenUnmatched(token);\n      this.tokensByElement[\"delete\"](token.element, token);\n    }\n  }, {\n    key: \"refreshTokensForElement\",\n    value: function refreshTokensForElement(element) {\n      var previousTokens = this.tokensByElement.getValuesForKey(element);\n      var currentTokens = this.readTokensForElement(element);\n      var firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n          previousToken = _ref12[0],\n          currentToken = _ref12[1];\n        return !tokensAreEqual(previousToken, currentToken);\n      });\n      if (firstDifferingIndex == -1) {\n        return [[], []];\n      } else {\n        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];\n      }\n    }\n  }, {\n    key: \"readTokensForElement\",\n    value: function readTokensForElement(element) {\n      var attributeName = this.attributeName;\n      var tokenString = element.getAttribute(attributeName) || \"\";\n      return parseTokenString(tokenString, element, attributeName);\n    }\n  }]);\n}();\nfunction parseTokenString(tokenString, element, attributeName) {\n  return tokenString.trim().split(/\\s+/).filter(function (content) {\n    return content.length;\n  }).map(function (content, index) {\n    return {\n      element: element,\n      attributeName: attributeName,\n      content: content,\n      index: index\n    };\n  });\n}\nfunction zip(left, right) {\n  var length = Math.max(left.length, right.length);\n  return Array.from({\n    length: length\n  }, function (_, index) {\n    return [left[index], right[index]];\n  });\n}\nfunction tokensAreEqual(left, right) {\n  return left && right && left.index == right.index && left.content == right.content;\n}\nvar ValueListObserver = /*#__PURE__*/function () {\n  function ValueListObserver(element, attributeName, delegate) {\n    _classCallCheck(this, ValueListObserver);\n    this.tokenListObserver = new TokenListObserver(element, attributeName, this);\n    this.delegate = delegate;\n    this.parseResultsByToken = new WeakMap();\n    this.valuesByTokenByElement = new WeakMap();\n  }\n  return _createClass(ValueListObserver, [{\n    key: \"started\",\n    get: function get() {\n      return this.tokenListObserver.started;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.tokenListObserver.start();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.tokenListObserver.stop();\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.tokenListObserver.refresh();\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.tokenListObserver.element;\n    }\n  }, {\n    key: \"attributeName\",\n    get: function get() {\n      return this.tokenListObserver.attributeName;\n    }\n  }, {\n    key: \"tokenMatched\",\n    value: function tokenMatched(token) {\n      var element = token.element;\n      var _this$fetchParseResul = this.fetchParseResultForToken(token),\n        value = _this$fetchParseResul.value;\n      if (value) {\n        this.fetchValuesByTokenForElement(element).set(token, value);\n        this.delegate.elementMatchedValue(element, value);\n      }\n    }\n  }, {\n    key: \"tokenUnmatched\",\n    value: function tokenUnmatched(token) {\n      var element = token.element;\n      var _this$fetchParseResul2 = this.fetchParseResultForToken(token),\n        value = _this$fetchParseResul2.value;\n      if (value) {\n        this.fetchValuesByTokenForElement(element)[\"delete\"](token);\n        this.delegate.elementUnmatchedValue(element, value);\n      }\n    }\n  }, {\n    key: \"fetchParseResultForToken\",\n    value: function fetchParseResultForToken(token) {\n      var parseResult = this.parseResultsByToken.get(token);\n      if (!parseResult) {\n        parseResult = this.parseToken(token);\n        this.parseResultsByToken.set(token, parseResult);\n      }\n      return parseResult;\n    }\n  }, {\n    key: \"fetchValuesByTokenForElement\",\n    value: function fetchValuesByTokenForElement(element) {\n      var valuesByToken = this.valuesByTokenByElement.get(element);\n      if (!valuesByToken) {\n        valuesByToken = new Map();\n        this.valuesByTokenByElement.set(element, valuesByToken);\n      }\n      return valuesByToken;\n    }\n  }, {\n    key: \"parseToken\",\n    value: function parseToken(token) {\n      try {\n        var value = this.delegate.parseValueForToken(token);\n        return {\n          value: value\n        };\n      } catch (error) {\n        return {\n          error: error\n        };\n      }\n    }\n  }]);\n}();\nvar BindingObserver = /*#__PURE__*/function () {\n  function BindingObserver(context, delegate) {\n    _classCallCheck(this, BindingObserver);\n    this.context = context;\n    this.delegate = delegate;\n    this.bindingsByAction = new Map();\n  }\n  return _createClass(BindingObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.valueListObserver) {\n        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);\n        this.valueListObserver.start();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.valueListObserver) {\n        this.valueListObserver.stop();\n        delete this.valueListObserver;\n        this.disconnectAllActions();\n      }\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.context.element;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.context.identifier;\n    }\n  }, {\n    key: \"actionAttribute\",\n    get: function get() {\n      return this.schema.actionAttribute;\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return this.context.schema;\n    }\n  }, {\n    key: \"bindings\",\n    get: function get() {\n      return Array.from(this.bindingsByAction.values());\n    }\n  }, {\n    key: \"connectAction\",\n    value: function connectAction(action) {\n      var binding = new Binding(this.context, action);\n      this.bindingsByAction.set(action, binding);\n      this.delegate.bindingConnected(binding);\n    }\n  }, {\n    key: \"disconnectAction\",\n    value: function disconnectAction(action) {\n      var binding = this.bindingsByAction.get(action);\n      if (binding) {\n        this.bindingsByAction[\"delete\"](action);\n        this.delegate.bindingDisconnected(binding);\n      }\n    }\n  }, {\n    key: \"disconnectAllActions\",\n    value: function disconnectAllActions() {\n      var _this7 = this;\n      this.bindings.forEach(function (binding) {\n        return _this7.delegate.bindingDisconnected(binding, true);\n      });\n      this.bindingsByAction.clear();\n    }\n  }, {\n    key: \"parseValueForToken\",\n    value: function parseValueForToken(token) {\n      var action = Action.forToken(token, this.schema);\n      if (action.identifier == this.identifier) {\n        return action;\n      }\n    }\n  }, {\n    key: \"elementMatchedValue\",\n    value: function elementMatchedValue(element, action) {\n      this.connectAction(action);\n    }\n  }, {\n    key: \"elementUnmatchedValue\",\n    value: function elementUnmatchedValue(element, action) {\n      this.disconnectAction(action);\n    }\n  }]);\n}();\nvar ValueObserver = /*#__PURE__*/function () {\n  function ValueObserver(context, receiver) {\n    _classCallCheck(this, ValueObserver);\n    this.context = context;\n    this.receiver = receiver;\n    this.stringMapObserver = new StringMapObserver(this.element, this);\n    this.valueDescriptorMap = this.controller.valueDescriptorMap;\n  }\n  return _createClass(ValueObserver, [{\n    key: \"start\",\n    value: function start() {\n      this.stringMapObserver.start();\n      this.invokeChangedCallbacksForDefaultValues();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.stringMapObserver.stop();\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.context.element;\n    }\n  }, {\n    key: \"controller\",\n    get: function get() {\n      return this.context.controller;\n    }\n  }, {\n    key: \"getStringMapKeyForAttribute\",\n    value: function getStringMapKeyForAttribute(attributeName) {\n      if (attributeName in this.valueDescriptorMap) {\n        return this.valueDescriptorMap[attributeName].name;\n      }\n    }\n  }, {\n    key: \"stringMapKeyAdded\",\n    value: function stringMapKeyAdded(key, attributeName) {\n      var descriptor = this.valueDescriptorMap[attributeName];\n      if (!this.hasValue(key)) {\n        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));\n      }\n    }\n  }, {\n    key: \"stringMapValueChanged\",\n    value: function stringMapValueChanged(value, name, oldValue) {\n      var descriptor = this.valueDescriptorNameMap[name];\n      if (value === null) return;\n      if (oldValue === null) {\n        oldValue = descriptor.writer(descriptor.defaultValue);\n      }\n      this.invokeChangedCallback(name, value, oldValue);\n    }\n  }, {\n    key: \"stringMapKeyRemoved\",\n    value: function stringMapKeyRemoved(key, attributeName, oldValue) {\n      var descriptor = this.valueDescriptorNameMap[key];\n      if (this.hasValue(key)) {\n        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);\n      } else {\n        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);\n      }\n    }\n  }, {\n    key: \"invokeChangedCallbacksForDefaultValues\",\n    value: function invokeChangedCallbacksForDefaultValues() {\n      var _iterator7 = _createForOfIteratorHelper(this.valueDescriptors),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _ref13 = _step7.value;\n          var key = _ref13.key;\n          var name = _ref13.name;\n          var defaultValue = _ref13.defaultValue;\n          var writer = _ref13.writer;\n          if (defaultValue != undefined && !this.controller.data.has(key)) {\n            this.invokeChangedCallback(name, writer(defaultValue), undefined);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"invokeChangedCallback\",\n    value: function invokeChangedCallback(name, rawValue, rawOldValue) {\n      var changedMethodName = \"\".concat(name, \"Changed\");\n      var changedMethod = this.receiver[changedMethodName];\n      if (typeof changedMethod == \"function\") {\n        var descriptor = this.valueDescriptorNameMap[name];\n        try {\n          var value = descriptor.reader(rawValue);\n          var oldValue = rawOldValue;\n          if (rawOldValue) {\n            oldValue = descriptor.reader(rawOldValue);\n          }\n          changedMethod.call(this.receiver, value, oldValue);\n        } catch (error) {\n          if (error instanceof TypeError) {\n            error.message = \"Stimulus Value \\\"\".concat(this.context.identifier, \".\").concat(descriptor.name, \"\\\" - \").concat(error.message);\n          }\n          throw error;\n        }\n      }\n    }\n  }, {\n    key: \"valueDescriptors\",\n    get: function get() {\n      var valueDescriptorMap = this.valueDescriptorMap;\n      return Object.keys(valueDescriptorMap).map(function (key) {\n        return valueDescriptorMap[key];\n      });\n    }\n  }, {\n    key: \"valueDescriptorNameMap\",\n    get: function get() {\n      var _this8 = this;\n      var descriptors = {};\n      Object.keys(this.valueDescriptorMap).forEach(function (key) {\n        var descriptor = _this8.valueDescriptorMap[key];\n        descriptors[descriptor.name] = descriptor;\n      });\n      return descriptors;\n    }\n  }, {\n    key: \"hasValue\",\n    value: function hasValue(attributeName) {\n      var descriptor = this.valueDescriptorNameMap[attributeName];\n      var hasMethodName = \"has\".concat(capitalize(descriptor.name));\n      return this.receiver[hasMethodName];\n    }\n  }]);\n}();\nvar TargetObserver = /*#__PURE__*/function () {\n  function TargetObserver(context, delegate) {\n    _classCallCheck(this, TargetObserver);\n    this.context = context;\n    this.delegate = delegate;\n    this.targetsByName = new Multimap();\n  }\n  return _createClass(TargetObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.tokenListObserver) {\n        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);\n        this.tokenListObserver.start();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.tokenListObserver) {\n        this.disconnectAllTargets();\n        this.tokenListObserver.stop();\n        delete this.tokenListObserver;\n      }\n    }\n  }, {\n    key: \"tokenMatched\",\n    value: function tokenMatched(_ref14) {\n      var element = _ref14.element,\n        name = _ref14.content;\n      if (this.scope.containsElement(element)) {\n        this.connectTarget(element, name);\n      }\n    }\n  }, {\n    key: \"tokenUnmatched\",\n    value: function tokenUnmatched(_ref15) {\n      var element = _ref15.element,\n        name = _ref15.content;\n      this.disconnectTarget(element, name);\n    }\n  }, {\n    key: \"connectTarget\",\n    value: function connectTarget(element, name) {\n      var _this9 = this;\n      var _a;\n      if (!this.targetsByName.has(name, element)) {\n        this.targetsByName.add(name, element);\n        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(function () {\n          return _this9.delegate.targetConnected(element, name);\n        });\n      }\n    }\n  }, {\n    key: \"disconnectTarget\",\n    value: function disconnectTarget(element, name) {\n      var _this10 = this;\n      var _a;\n      if (this.targetsByName.has(name, element)) {\n        this.targetsByName[\"delete\"](name, element);\n        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(function () {\n          return _this10.delegate.targetDisconnected(element, name);\n        });\n      }\n    }\n  }, {\n    key: \"disconnectAllTargets\",\n    value: function disconnectAllTargets() {\n      var _iterator8 = _createForOfIteratorHelper(this.targetsByName.keys),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var name = _step8.value;\n          var _iterator9 = _createForOfIteratorHelper(this.targetsByName.getValuesForKey(name)),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var element = _step9.value;\n              this.disconnectTarget(element, name);\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"attributeName\",\n    get: function get() {\n      return \"data-\".concat(this.context.identifier, \"-target\");\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.context.element;\n    }\n  }, {\n    key: \"scope\",\n    get: function get() {\n      return this.context.scope;\n    }\n  }]);\n}();\nfunction readInheritableStaticArrayValues(constructor, propertyName) {\n  var ancestors = getAncestorsForConstructor(constructor);\n  return Array.from(ancestors.reduce(function (values, constructor) {\n    getOwnStaticArrayValues(constructor, propertyName).forEach(function (name) {\n      return values.add(name);\n    });\n    return values;\n  }, new Set()));\n}\nfunction readInheritableStaticObjectPairs(constructor, propertyName) {\n  var ancestors = getAncestorsForConstructor(constructor);\n  return ancestors.reduce(function (pairs, constructor) {\n    pairs.push.apply(pairs, _toConsumableArray(getOwnStaticObjectPairs(constructor, propertyName)));\n    return pairs;\n  }, []);\n}\nfunction getAncestorsForConstructor(constructor) {\n  var ancestors = [];\n  while (constructor) {\n    ancestors.push(constructor);\n    constructor = Object.getPrototypeOf(constructor);\n  }\n  return ancestors.reverse();\n}\nfunction getOwnStaticArrayValues(constructor, propertyName) {\n  var definition = constructor[propertyName];\n  return Array.isArray(definition) ? definition : [];\n}\nfunction getOwnStaticObjectPairs(constructor, propertyName) {\n  var definition = constructor[propertyName];\n  return definition ? Object.keys(definition).map(function (key) {\n    return [key, definition[key]];\n  }) : [];\n}\nvar OutletObserver = /*#__PURE__*/function () {\n  function OutletObserver(context, delegate) {\n    _classCallCheck(this, OutletObserver);\n    this.started = false;\n    this.context = context;\n    this.delegate = delegate;\n    this.outletsByName = new Multimap();\n    this.outletElementsByName = new Multimap();\n    this.selectorObserverMap = new Map();\n    this.attributeObserverMap = new Map();\n  }\n  return _createClass(OutletObserver, [{\n    key: \"start\",\n    value: function start() {\n      var _this11 = this;\n      if (!this.started) {\n        this.outletDefinitions.forEach(function (outletName) {\n          _this11.setupSelectorObserverForOutlet(outletName);\n          _this11.setupAttributeObserverForOutlet(outletName);\n        });\n        this.started = true;\n        this.dependentContexts.forEach(function (context) {\n          return context.refresh();\n        });\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.selectorObserverMap.forEach(function (observer) {\n        return observer.refresh();\n      });\n      this.attributeObserverMap.forEach(function (observer) {\n        return observer.refresh();\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.started = false;\n        this.disconnectAllOutlets();\n        this.stopSelectorObservers();\n        this.stopAttributeObservers();\n      }\n    }\n  }, {\n    key: \"stopSelectorObservers\",\n    value: function stopSelectorObservers() {\n      if (this.selectorObserverMap.size > 0) {\n        this.selectorObserverMap.forEach(function (observer) {\n          return observer.stop();\n        });\n        this.selectorObserverMap.clear();\n      }\n    }\n  }, {\n    key: \"stopAttributeObservers\",\n    value: function stopAttributeObservers() {\n      if (this.attributeObserverMap.size > 0) {\n        this.attributeObserverMap.forEach(function (observer) {\n          return observer.stop();\n        });\n        this.attributeObserverMap.clear();\n      }\n    }\n  }, {\n    key: \"selectorMatched\",\n    value: function selectorMatched(element, _selector, _ref16) {\n      var outletName = _ref16.outletName;\n      var outlet = this.getOutlet(element, outletName);\n      if (outlet) {\n        this.connectOutlet(outlet, element, outletName);\n      }\n    }\n  }, {\n    key: \"selectorUnmatched\",\n    value: function selectorUnmatched(element, _selector, _ref17) {\n      var outletName = _ref17.outletName;\n      var outlet = this.getOutletFromMap(element, outletName);\n      if (outlet) {\n        this.disconnectOutlet(outlet, element, outletName);\n      }\n    }\n  }, {\n    key: \"selectorMatchElement\",\n    value: function selectorMatchElement(element, _ref18) {\n      var outletName = _ref18.outletName;\n      var selector = this.selector(outletName);\n      var hasOutlet = this.hasOutlet(element, outletName);\n      var hasOutletController = element.matches(\"[\".concat(this.schema.controllerAttribute, \"~=\").concat(outletName, \"]\"));\n      if (selector) {\n        return hasOutlet && hasOutletController && element.matches(selector);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"elementMatchedAttribute\",\n    value: function elementMatchedAttribute(_element, attributeName) {\n      var outletName = this.getOutletNameFromOutletAttributeName(attributeName);\n      if (outletName) {\n        this.updateSelectorObserverForOutlet(outletName);\n      }\n    }\n  }, {\n    key: \"elementAttributeValueChanged\",\n    value: function elementAttributeValueChanged(_element, attributeName) {\n      var outletName = this.getOutletNameFromOutletAttributeName(attributeName);\n      if (outletName) {\n        this.updateSelectorObserverForOutlet(outletName);\n      }\n    }\n  }, {\n    key: \"elementUnmatchedAttribute\",\n    value: function elementUnmatchedAttribute(_element, attributeName) {\n      var outletName = this.getOutletNameFromOutletAttributeName(attributeName);\n      if (outletName) {\n        this.updateSelectorObserverForOutlet(outletName);\n      }\n    }\n  }, {\n    key: \"connectOutlet\",\n    value: function connectOutlet(outlet, element, outletName) {\n      var _this12 = this;\n      var _a;\n      if (!this.outletElementsByName.has(outletName, element)) {\n        this.outletsByName.add(outletName, outlet);\n        this.outletElementsByName.add(outletName, element);\n        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(function () {\n          return _this12.delegate.outletConnected(outlet, element, outletName);\n        });\n      }\n    }\n  }, {\n    key: \"disconnectOutlet\",\n    value: function disconnectOutlet(outlet, element, outletName) {\n      var _this13 = this;\n      var _a;\n      if (this.outletElementsByName.has(outletName, element)) {\n        this.outletsByName[\"delete\"](outletName, outlet);\n        this.outletElementsByName[\"delete\"](outletName, element);\n        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(function () {\n          return _this13.delegate.outletDisconnected(outlet, element, outletName);\n        });\n      }\n    }\n  }, {\n    key: \"disconnectAllOutlets\",\n    value: function disconnectAllOutlets() {\n      var _iterator10 = _createForOfIteratorHelper(this.outletElementsByName.keys),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var outletName = _step10.value;\n          var _iterator11 = _createForOfIteratorHelper(this.outletElementsByName.getValuesForKey(outletName)),\n            _step11;\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var element = _step11.value;\n              var _iterator12 = _createForOfIteratorHelper(this.outletsByName.getValuesForKey(outletName)),\n                _step12;\n              try {\n                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                  var outlet = _step12.value;\n                  this.disconnectOutlet(outlet, element, outletName);\n                }\n              } catch (err) {\n                _iterator12.e(err);\n              } finally {\n                _iterator12.f();\n              }\n            }\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }, {\n    key: \"updateSelectorObserverForOutlet\",\n    value: function updateSelectorObserverForOutlet(outletName) {\n      var observer = this.selectorObserverMap.get(outletName);\n      if (observer) {\n        observer.selector = this.selector(outletName);\n      }\n    }\n  }, {\n    key: \"setupSelectorObserverForOutlet\",\n    value: function setupSelectorObserverForOutlet(outletName) {\n      var selector = this.selector(outletName);\n      var selectorObserver = new SelectorObserver(document.body, selector, this, {\n        outletName: outletName\n      });\n      this.selectorObserverMap.set(outletName, selectorObserver);\n      selectorObserver.start();\n    }\n  }, {\n    key: \"setupAttributeObserverForOutlet\",\n    value: function setupAttributeObserverForOutlet(outletName) {\n      var attributeName = this.attributeNameForOutletName(outletName);\n      var attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);\n      this.attributeObserverMap.set(outletName, attributeObserver);\n      attributeObserver.start();\n    }\n  }, {\n    key: \"selector\",\n    value: function selector(outletName) {\n      return this.scope.outlets.getSelectorForOutletName(outletName);\n    }\n  }, {\n    key: \"attributeNameForOutletName\",\n    value: function attributeNameForOutletName(outletName) {\n      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);\n    }\n  }, {\n    key: \"getOutletNameFromOutletAttributeName\",\n    value: function getOutletNameFromOutletAttributeName(attributeName) {\n      var _this14 = this;\n      return this.outletDefinitions.find(function (outletName) {\n        return _this14.attributeNameForOutletName(outletName) === attributeName;\n      });\n    }\n  }, {\n    key: \"outletDependencies\",\n    get: function get() {\n      var dependencies = new Multimap();\n      this.router.modules.forEach(function (module) {\n        var constructor = module.definition.controllerConstructor;\n        var outlets = readInheritableStaticArrayValues(constructor, \"outlets\");\n        outlets.forEach(function (outlet) {\n          return dependencies.add(outlet, module.identifier);\n        });\n      });\n      return dependencies;\n    }\n  }, {\n    key: \"outletDefinitions\",\n    get: function get() {\n      return this.outletDependencies.getKeysForValue(this.identifier);\n    }\n  }, {\n    key: \"dependentControllerIdentifiers\",\n    get: function get() {\n      return this.outletDependencies.getValuesForKey(this.identifier);\n    }\n  }, {\n    key: \"dependentContexts\",\n    get: function get() {\n      var identifiers = this.dependentControllerIdentifiers;\n      return this.router.contexts.filter(function (context) {\n        return identifiers.includes(context.identifier);\n      });\n    }\n  }, {\n    key: \"hasOutlet\",\n    value: function hasOutlet(element, outletName) {\n      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);\n    }\n  }, {\n    key: \"getOutlet\",\n    value: function getOutlet(element, outletName) {\n      return this.application.getControllerForElementAndIdentifier(element, outletName);\n    }\n  }, {\n    key: \"getOutletFromMap\",\n    value: function getOutletFromMap(element, outletName) {\n      return this.outletsByName.getValuesForKey(outletName).find(function (outlet) {\n        return outlet.element === element;\n      });\n    }\n  }, {\n    key: \"scope\",\n    get: function get() {\n      return this.context.scope;\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return this.context.schema;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.context.identifier;\n    }\n  }, {\n    key: \"application\",\n    get: function get() {\n      return this.context.application;\n    }\n  }, {\n    key: \"router\",\n    get: function get() {\n      return this.application.router;\n    }\n  }]);\n}();\nvar Context = /*#__PURE__*/function () {\n  function Context(module, scope) {\n    var _this15 = this;\n    _classCallCheck(this, Context);\n    this.logDebugActivity = function (functionName) {\n      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var identifier = _this15.identifier,\n        controller = _this15.controller,\n        element = _this15.element;\n      detail = Object.assign({\n        identifier: identifier,\n        controller: controller,\n        element: element\n      }, detail);\n      _this15.application.logDebugActivity(_this15.identifier, functionName, detail);\n    };\n    this.module = module;\n    this.scope = scope;\n    this.controller = new module.controllerConstructor(this);\n    this.bindingObserver = new BindingObserver(this, this.dispatcher);\n    this.valueObserver = new ValueObserver(this, this.controller);\n    this.targetObserver = new TargetObserver(this, this);\n    this.outletObserver = new OutletObserver(this, this);\n    try {\n      this.controller.initialize();\n      this.logDebugActivity(\"initialize\");\n    } catch (error) {\n      this.handleError(error, \"initializing controller\");\n    }\n  }\n  return _createClass(Context, [{\n    key: \"connect\",\n    value: function connect() {\n      this.bindingObserver.start();\n      this.valueObserver.start();\n      this.targetObserver.start();\n      this.outletObserver.start();\n      try {\n        this.controller.connect();\n        this.logDebugActivity(\"connect\");\n      } catch (error) {\n        this.handleError(error, \"connecting controller\");\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.outletObserver.refresh();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      try {\n        this.controller.disconnect();\n        this.logDebugActivity(\"disconnect\");\n      } catch (error) {\n        this.handleError(error, \"disconnecting controller\");\n      }\n      this.outletObserver.stop();\n      this.targetObserver.stop();\n      this.valueObserver.stop();\n      this.bindingObserver.stop();\n    }\n  }, {\n    key: \"application\",\n    get: function get() {\n      return this.module.application;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.module.identifier;\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return this.application.schema;\n    }\n  }, {\n    key: \"dispatcher\",\n    get: function get() {\n      return this.application.dispatcher;\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.scope.element;\n    }\n  }, {\n    key: \"parentElement\",\n    get: function get() {\n      return this.element.parentElement;\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(error, message) {\n      var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var identifier = this.identifier,\n        controller = this.controller,\n        element = this.element;\n      detail = Object.assign({\n        identifier: identifier,\n        controller: controller,\n        element: element\n      }, detail);\n      this.application.handleError(error, \"Error \".concat(message), detail);\n    }\n  }, {\n    key: \"targetConnected\",\n    value: function targetConnected(element, name) {\n      this.invokeControllerMethod(\"\".concat(name, \"TargetConnected\"), element);\n    }\n  }, {\n    key: \"targetDisconnected\",\n    value: function targetDisconnected(element, name) {\n      this.invokeControllerMethod(\"\".concat(name, \"TargetDisconnected\"), element);\n    }\n  }, {\n    key: \"outletConnected\",\n    value: function outletConnected(outlet, element, name) {\n      this.invokeControllerMethod(\"\".concat(namespaceCamelize(name), \"OutletConnected\"), outlet, element);\n    }\n  }, {\n    key: \"outletDisconnected\",\n    value: function outletDisconnected(outlet, element, name) {\n      this.invokeControllerMethod(\"\".concat(namespaceCamelize(name), \"OutletDisconnected\"), outlet, element);\n    }\n  }, {\n    key: \"invokeControllerMethod\",\n    value: function invokeControllerMethod(methodName) {\n      var controller = this.controller;\n      if (typeof controller[methodName] == \"function\") {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        controller[methodName].apply(controller, args);\n      }\n    }\n  }]);\n}();\nfunction bless(constructor) {\n  return shadow(constructor, getBlessedProperties(constructor));\n}\nfunction shadow(constructor, properties) {\n  var shadowConstructor = extend(constructor);\n  var shadowProperties = getShadowProperties(constructor.prototype, properties);\n  Object.defineProperties(shadowConstructor.prototype, shadowProperties);\n  return shadowConstructor;\n}\nfunction getBlessedProperties(constructor) {\n  var blessings = readInheritableStaticArrayValues(constructor, \"blessings\");\n  return blessings.reduce(function (blessedProperties, blessing) {\n    var properties = blessing(constructor);\n    for (var key in properties) {\n      var descriptor = blessedProperties[key] || {};\n      blessedProperties[key] = Object.assign(descriptor, properties[key]);\n    }\n    return blessedProperties;\n  }, {});\n}\nfunction getShadowProperties(prototype, properties) {\n  return getOwnKeys(properties).reduce(function (shadowProperties, key) {\n    var descriptor = getShadowedDescriptor(prototype, properties, key);\n    if (descriptor) {\n      Object.assign(shadowProperties, _defineProperty({}, key, descriptor));\n    }\n    return shadowProperties;\n  }, {});\n}\nfunction getShadowedDescriptor(prototype, properties, key) {\n  var shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);\n  var shadowedByValue = shadowingDescriptor && \"value\" in shadowingDescriptor;\n  if (!shadowedByValue) {\n    var descriptor = Object.getOwnPropertyDescriptor(properties, key).value;\n    if (shadowingDescriptor) {\n      descriptor.get = shadowingDescriptor.get || descriptor.get;\n      descriptor.set = shadowingDescriptor.set || descriptor.set;\n    }\n    return descriptor;\n  }\n}\nvar getOwnKeys = function () {\n  if (typeof Object.getOwnPropertySymbols == \"function\") {\n    return function (object) {\n      return [].concat(_toConsumableArray(Object.getOwnPropertyNames(object)), _toConsumableArray(Object.getOwnPropertySymbols(object)));\n    };\n  } else {\n    return Object.getOwnPropertyNames;\n  }\n}();\nvar extend = function () {\n  function extendWithReflect(constructor) {\n    function extended() {\n      return Reflect.construct(constructor, arguments, this instanceof extended ? this.constructor : void 0);\n    }\n    extended.prototype = Object.create(constructor.prototype, {\n      constructor: {\n        value: extended\n      }\n    });\n    Reflect.setPrototypeOf(extended, constructor);\n    return extended;\n  }\n  function testReflectExtension() {\n    var a = function a() {\n      this.a.call(this);\n    };\n    var b = extendWithReflect(a);\n    b.prototype.a = function () {};\n    return new b();\n  }\n  try {\n    testReflectExtension();\n    return extendWithReflect;\n  } catch (error) {\n    return function (constructor) {\n      return /*#__PURE__*/function (_constructor) {\n        function extended() {\n          _classCallCheck(this, extended);\n          return _callSuper(this, extended, arguments);\n        }\n        _inherits(extended, _constructor);\n        return _createClass(extended);\n      }(constructor);\n    };\n  }\n}();\nfunction blessDefinition(definition) {\n  return {\n    identifier: definition.identifier,\n    controllerConstructor: bless(definition.controllerConstructor)\n  };\n}\nvar Module = /*#__PURE__*/function () {\n  function Module(application, definition) {\n    _classCallCheck(this, Module);\n    this.application = application;\n    this.definition = blessDefinition(definition);\n    this.contextsByScope = new WeakMap();\n    this.connectedContexts = new Set();\n  }\n  return _createClass(Module, [{\n    key: \"identifier\",\n    get: function get() {\n      return this.definition.identifier;\n    }\n  }, {\n    key: \"controllerConstructor\",\n    get: function get() {\n      return this.definition.controllerConstructor;\n    }\n  }, {\n    key: \"contexts\",\n    get: function get() {\n      return Array.from(this.connectedContexts);\n    }\n  }, {\n    key: \"connectContextForScope\",\n    value: function connectContextForScope(scope) {\n      var context = this.fetchContextForScope(scope);\n      this.connectedContexts.add(context);\n      context.connect();\n    }\n  }, {\n    key: \"disconnectContextForScope\",\n    value: function disconnectContextForScope(scope) {\n      var context = this.contextsByScope.get(scope);\n      if (context) {\n        this.connectedContexts[\"delete\"](context);\n        context.disconnect();\n      }\n    }\n  }, {\n    key: \"fetchContextForScope\",\n    value: function fetchContextForScope(scope) {\n      var context = this.contextsByScope.get(scope);\n      if (!context) {\n        context = new Context(this, scope);\n        this.contextsByScope.set(scope, context);\n      }\n      return context;\n    }\n  }]);\n}();\nvar ClassMap = /*#__PURE__*/function () {\n  function ClassMap(scope) {\n    _classCallCheck(this, ClassMap);\n    this.scope = scope;\n  }\n  return _createClass(ClassMap, [{\n    key: \"has\",\n    value: function has(name) {\n      return this.data.has(this.getDataKey(name));\n    }\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      return this.getAll(name)[0];\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll(name) {\n      var tokenString = this.data.get(this.getDataKey(name)) || \"\";\n      return tokenize(tokenString);\n    }\n  }, {\n    key: \"getAttributeName\",\n    value: function getAttributeName(name) {\n      return this.data.getAttributeNameForKey(this.getDataKey(name));\n    }\n  }, {\n    key: \"getDataKey\",\n    value: function getDataKey(name) {\n      return \"\".concat(name, \"-class\");\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.scope.data;\n    }\n  }]);\n}();\nvar DataMap = /*#__PURE__*/function () {\n  function DataMap(scope) {\n    _classCallCheck(this, DataMap);\n    this.scope = scope;\n  }\n  return _createClass(DataMap, [{\n    key: \"element\",\n    get: function get() {\n      return this.scope.element;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.scope.identifier;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var name = this.getAttributeNameForKey(key);\n      return this.element.getAttribute(name);\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var name = this.getAttributeNameForKey(key);\n      this.element.setAttribute(name, value);\n      return this.get(key);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var name = this.getAttributeNameForKey(key);\n      return this.element.hasAttribute(name);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      if (this.has(key)) {\n        var name = this.getAttributeNameForKey(key);\n        this.element.removeAttribute(name);\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"getAttributeNameForKey\",\n    value: function getAttributeNameForKey(key) {\n      return \"data-\".concat(this.identifier, \"-\").concat(dasherize(key));\n    }\n  }]);\n}();\nvar Guide = /*#__PURE__*/function () {\n  function Guide(logger) {\n    _classCallCheck(this, Guide);\n    this.warnedKeysByObject = new WeakMap();\n    this.logger = logger;\n  }\n  return _createClass(Guide, [{\n    key: \"warn\",\n    value: function warn(object, key, message) {\n      var warnedKeys = this.warnedKeysByObject.get(object);\n      if (!warnedKeys) {\n        warnedKeys = new Set();\n        this.warnedKeysByObject.set(object, warnedKeys);\n      }\n      if (!warnedKeys.has(key)) {\n        warnedKeys.add(key);\n        this.logger.warn(message, object);\n      }\n    }\n  }]);\n}();\nfunction attributeValueContainsToken(attributeName, token) {\n  return \"[\".concat(attributeName, \"~=\\\"\").concat(token, \"\\\"]\");\n}\nvar TargetSet = /*#__PURE__*/function () {\n  function TargetSet(scope) {\n    _classCallCheck(this, TargetSet);\n    this.scope = scope;\n  }\n  return _createClass(TargetSet, [{\n    key: \"element\",\n    get: function get() {\n      return this.scope.element;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.scope.identifier;\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return this.scope.schema;\n    }\n  }, {\n    key: \"has\",\n    value: function has(targetName) {\n      return this.find(targetName) != null;\n    }\n  }, {\n    key: \"find\",\n    value: function find() {\n      var _this16 = this;\n      for (var _len2 = arguments.length, targetNames = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {\n        targetNames[_key3] = arguments[_key3];\n      }\n      return targetNames.reduce(function (target, targetName) {\n        return target || _this16.findTarget(targetName) || _this16.findLegacyTarget(targetName);\n      }, undefined);\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll() {\n      var _this17 = this;\n      for (var _len3 = arguments.length, targetNames = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n        targetNames[_key4] = arguments[_key4];\n      }\n      return targetNames.reduce(function (targets, targetName) {\n        return [].concat(_toConsumableArray(targets), _toConsumableArray(_this17.findAllTargets(targetName)), _toConsumableArray(_this17.findAllLegacyTargets(targetName)));\n      }, []);\n    }\n  }, {\n    key: \"findTarget\",\n    value: function findTarget(targetName) {\n      var selector = this.getSelectorForTargetName(targetName);\n      return this.scope.findElement(selector);\n    }\n  }, {\n    key: \"findAllTargets\",\n    value: function findAllTargets(targetName) {\n      var selector = this.getSelectorForTargetName(targetName);\n      return this.scope.findAllElements(selector);\n    }\n  }, {\n    key: \"getSelectorForTargetName\",\n    value: function getSelectorForTargetName(targetName) {\n      var attributeName = this.schema.targetAttributeForScope(this.identifier);\n      return attributeValueContainsToken(attributeName, targetName);\n    }\n  }, {\n    key: \"findLegacyTarget\",\n    value: function findLegacyTarget(targetName) {\n      var selector = this.getLegacySelectorForTargetName(targetName);\n      return this.deprecate(this.scope.findElement(selector), targetName);\n    }\n  }, {\n    key: \"findAllLegacyTargets\",\n    value: function findAllLegacyTargets(targetName) {\n      var _this18 = this;\n      var selector = this.getLegacySelectorForTargetName(targetName);\n      return this.scope.findAllElements(selector).map(function (element) {\n        return _this18.deprecate(element, targetName);\n      });\n    }\n  }, {\n    key: \"getLegacySelectorForTargetName\",\n    value: function getLegacySelectorForTargetName(targetName) {\n      var targetDescriptor = \"\".concat(this.identifier, \".\").concat(targetName);\n      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);\n    }\n  }, {\n    key: \"deprecate\",\n    value: function deprecate(element, targetName) {\n      if (element) {\n        var identifier = this.identifier;\n        var attributeName = this.schema.targetAttribute;\n        var revisedAttributeName = this.schema.targetAttributeForScope(identifier);\n        this.guide.warn(element, \"target:\".concat(targetName), \"Please replace \".concat(attributeName, \"=\\\"\").concat(identifier, \".\").concat(targetName, \"\\\" with \").concat(revisedAttributeName, \"=\\\"\").concat(targetName, \"\\\". \") + \"The \".concat(attributeName, \" attribute is deprecated and will be removed in a future version of Stimulus.\"));\n      }\n      return element;\n    }\n  }, {\n    key: \"guide\",\n    get: function get() {\n      return this.scope.guide;\n    }\n  }]);\n}();\nvar OutletSet = /*#__PURE__*/function () {\n  function OutletSet(scope, controllerElement) {\n    _classCallCheck(this, OutletSet);\n    this.scope = scope;\n    this.controllerElement = controllerElement;\n  }\n  return _createClass(OutletSet, [{\n    key: \"element\",\n    get: function get() {\n      return this.scope.element;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.scope.identifier;\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return this.scope.schema;\n    }\n  }, {\n    key: \"has\",\n    value: function has(outletName) {\n      return this.find(outletName) != null;\n    }\n  }, {\n    key: \"find\",\n    value: function find() {\n      var _this19 = this;\n      for (var _len4 = arguments.length, outletNames = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {\n        outletNames[_key5] = arguments[_key5];\n      }\n      return outletNames.reduce(function (outlet, outletName) {\n        return outlet || _this19.findOutlet(outletName);\n      }, undefined);\n    }\n  }, {\n    key: \"findAll\",\n    value: function findAll() {\n      var _this20 = this;\n      for (var _len5 = arguments.length, outletNames = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {\n        outletNames[_key6] = arguments[_key6];\n      }\n      return outletNames.reduce(function (outlets, outletName) {\n        return [].concat(_toConsumableArray(outlets), _toConsumableArray(_this20.findAllOutlets(outletName)));\n      }, []);\n    }\n  }, {\n    key: \"getSelectorForOutletName\",\n    value: function getSelectorForOutletName(outletName) {\n      var attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);\n      return this.controllerElement.getAttribute(attributeName);\n    }\n  }, {\n    key: \"findOutlet\",\n    value: function findOutlet(outletName) {\n      var selector = this.getSelectorForOutletName(outletName);\n      if (selector) return this.findElement(selector, outletName);\n    }\n  }, {\n    key: \"findAllOutlets\",\n    value: function findAllOutlets(outletName) {\n      var selector = this.getSelectorForOutletName(outletName);\n      return selector ? this.findAllElements(selector, outletName) : [];\n    }\n  }, {\n    key: \"findElement\",\n    value: function findElement(selector, outletName) {\n      var _this21 = this;\n      var elements = this.scope.queryElements(selector);\n      return elements.filter(function (element) {\n        return _this21.matchesElement(element, selector, outletName);\n      })[0];\n    }\n  }, {\n    key: \"findAllElements\",\n    value: function findAllElements(selector, outletName) {\n      var _this22 = this;\n      var elements = this.scope.queryElements(selector);\n      return elements.filter(function (element) {\n        return _this22.matchesElement(element, selector, outletName);\n      });\n    }\n  }, {\n    key: \"matchesElement\",\n    value: function matchesElement(element, selector, outletName) {\n      var controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || \"\";\n      return element.matches(selector) && controllerAttribute.split(\" \").includes(outletName);\n    }\n  }]);\n}();\nvar Scope = /*#__PURE__*/function () {\n  function Scope(schema, element, identifier, logger) {\n    var _this23 = this;\n    _classCallCheck(this, Scope);\n    this.targets = new TargetSet(this);\n    this.classes = new ClassMap(this);\n    this.data = new DataMap(this);\n    this.containsElement = function (element) {\n      return element.closest(_this23.controllerSelector) === _this23.element;\n    };\n    this.schema = schema;\n    this.element = element;\n    this.identifier = identifier;\n    this.guide = new Guide(logger);\n    this.outlets = new OutletSet(this.documentScope, element);\n  }\n  return _createClass(Scope, [{\n    key: \"findElement\",\n    value: function findElement(selector) {\n      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);\n    }\n  }, {\n    key: \"findAllElements\",\n    value: function findAllElements(selector) {\n      return [].concat(_toConsumableArray(this.element.matches(selector) ? [this.element] : []), _toConsumableArray(this.queryElements(selector).filter(this.containsElement)));\n    }\n  }, {\n    key: \"queryElements\",\n    value: function queryElements(selector) {\n      return Array.from(this.element.querySelectorAll(selector));\n    }\n  }, {\n    key: \"controllerSelector\",\n    get: function get() {\n      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);\n    }\n  }, {\n    key: \"isDocumentScope\",\n    get: function get() {\n      return this.element === document.documentElement;\n    }\n  }, {\n    key: \"documentScope\",\n    get: function get() {\n      return this.isDocumentScope ? this : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);\n    }\n  }]);\n}();\nvar ScopeObserver = /*#__PURE__*/function () {\n  function ScopeObserver(element, schema, delegate) {\n    _classCallCheck(this, ScopeObserver);\n    this.element = element;\n    this.schema = schema;\n    this.delegate = delegate;\n    this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);\n    this.scopesByIdentifierByElement = new WeakMap();\n    this.scopeReferenceCounts = new WeakMap();\n  }\n  return _createClass(ScopeObserver, [{\n    key: \"start\",\n    value: function start() {\n      this.valueListObserver.start();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.valueListObserver.stop();\n    }\n  }, {\n    key: \"controllerAttribute\",\n    get: function get() {\n      return this.schema.controllerAttribute;\n    }\n  }, {\n    key: \"parseValueForToken\",\n    value: function parseValueForToken(token) {\n      var element = token.element,\n        identifier = token.content;\n      return this.parseValueForElementAndIdentifier(element, identifier);\n    }\n  }, {\n    key: \"parseValueForElementAndIdentifier\",\n    value: function parseValueForElementAndIdentifier(element, identifier) {\n      var scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);\n      var scope = scopesByIdentifier.get(identifier);\n      if (!scope) {\n        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);\n        scopesByIdentifier.set(identifier, scope);\n      }\n      return scope;\n    }\n  }, {\n    key: \"elementMatchedValue\",\n    value: function elementMatchedValue(element, value) {\n      var referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;\n      this.scopeReferenceCounts.set(value, referenceCount);\n      if (referenceCount == 1) {\n        this.delegate.scopeConnected(value);\n      }\n    }\n  }, {\n    key: \"elementUnmatchedValue\",\n    value: function elementUnmatchedValue(element, value) {\n      var referenceCount = this.scopeReferenceCounts.get(value);\n      if (referenceCount) {\n        this.scopeReferenceCounts.set(value, referenceCount - 1);\n        if (referenceCount == 1) {\n          this.delegate.scopeDisconnected(value);\n        }\n      }\n    }\n  }, {\n    key: \"fetchScopesByIdentifierForElement\",\n    value: function fetchScopesByIdentifierForElement(element) {\n      var scopesByIdentifier = this.scopesByIdentifierByElement.get(element);\n      if (!scopesByIdentifier) {\n        scopesByIdentifier = new Map();\n        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);\n      }\n      return scopesByIdentifier;\n    }\n  }]);\n}();\nvar Router = /*#__PURE__*/function () {\n  function Router(application) {\n    _classCallCheck(this, Router);\n    this.application = application;\n    this.scopeObserver = new ScopeObserver(this.element, this.schema, this);\n    this.scopesByIdentifier = new Multimap();\n    this.modulesByIdentifier = new Map();\n  }\n  return _createClass(Router, [{\n    key: \"element\",\n    get: function get() {\n      return this.application.element;\n    }\n  }, {\n    key: \"schema\",\n    get: function get() {\n      return this.application.schema;\n    }\n  }, {\n    key: \"logger\",\n    get: function get() {\n      return this.application.logger;\n    }\n  }, {\n    key: \"controllerAttribute\",\n    get: function get() {\n      return this.schema.controllerAttribute;\n    }\n  }, {\n    key: \"modules\",\n    get: function get() {\n      return Array.from(this.modulesByIdentifier.values());\n    }\n  }, {\n    key: \"contexts\",\n    get: function get() {\n      return this.modules.reduce(function (contexts, module) {\n        return contexts.concat(module.contexts);\n      }, []);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.scopeObserver.start();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.scopeObserver.stop();\n    }\n  }, {\n    key: \"loadDefinition\",\n    value: function loadDefinition(definition) {\n      this.unloadIdentifier(definition.identifier);\n      var module = new Module(this.application, definition);\n      this.connectModule(module);\n      var afterLoad = definition.controllerConstructor.afterLoad;\n      if (afterLoad) {\n        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);\n      }\n    }\n  }, {\n    key: \"unloadIdentifier\",\n    value: function unloadIdentifier(identifier) {\n      var module = this.modulesByIdentifier.get(identifier);\n      if (module) {\n        this.disconnectModule(module);\n      }\n    }\n  }, {\n    key: \"getContextForElementAndIdentifier\",\n    value: function getContextForElementAndIdentifier(element, identifier) {\n      var module = this.modulesByIdentifier.get(identifier);\n      if (module) {\n        return module.contexts.find(function (context) {\n          return context.element == element;\n        });\n      }\n    }\n  }, {\n    key: \"proposeToConnectScopeForElementAndIdentifier\",\n    value: function proposeToConnectScopeForElementAndIdentifier(element, identifier) {\n      var scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);\n      if (scope) {\n        this.scopeObserver.elementMatchedValue(scope.element, scope);\n      } else {\n        console.error(\"Couldn't find or create scope for identifier: \\\"\".concat(identifier, \"\\\" and element:\"), element);\n      }\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(error, message, detail) {\n      this.application.handleError(error, message, detail);\n    }\n  }, {\n    key: \"createScopeForElementAndIdentifier\",\n    value: function createScopeForElementAndIdentifier(element, identifier) {\n      return new Scope(this.schema, element, identifier, this.logger);\n    }\n  }, {\n    key: \"scopeConnected\",\n    value: function scopeConnected(scope) {\n      this.scopesByIdentifier.add(scope.identifier, scope);\n      var module = this.modulesByIdentifier.get(scope.identifier);\n      if (module) {\n        module.connectContextForScope(scope);\n      }\n    }\n  }, {\n    key: \"scopeDisconnected\",\n    value: function scopeDisconnected(scope) {\n      this.scopesByIdentifier[\"delete\"](scope.identifier, scope);\n      var module = this.modulesByIdentifier.get(scope.identifier);\n      if (module) {\n        module.disconnectContextForScope(scope);\n      }\n    }\n  }, {\n    key: \"connectModule\",\n    value: function connectModule(module) {\n      this.modulesByIdentifier.set(module.identifier, module);\n      var scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n      scopes.forEach(function (scope) {\n        return module.connectContextForScope(scope);\n      });\n    }\n  }, {\n    key: \"disconnectModule\",\n    value: function disconnectModule(module) {\n      this.modulesByIdentifier[\"delete\"](module.identifier);\n      var scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n      scopes.forEach(function (scope) {\n        return module.disconnectContextForScope(scope);\n      });\n    }\n  }]);\n}();\nvar defaultSchema = {\n  controllerAttribute: \"data-controller\",\n  actionAttribute: \"data-action\",\n  targetAttribute: \"data-target\",\n  targetAttributeForScope: function targetAttributeForScope(identifier) {\n    return \"data-\".concat(identifier, \"-target\");\n  },\n  outletAttributeForScope: function outletAttributeForScope(identifier, outlet) {\n    return \"data-\".concat(identifier, \"-\").concat(outlet, \"-outlet\");\n  },\n  keyMappings: Object.assign(Object.assign({\n    enter: \"Enter\",\n    tab: \"Tab\",\n    esc: \"Escape\",\n    space: \" \",\n    up: \"ArrowUp\",\n    down: \"ArrowDown\",\n    left: \"ArrowLeft\",\n    right: \"ArrowRight\",\n    home: \"Home\",\n    end: \"End\",\n    page_up: \"PageUp\",\n    page_down: \"PageDown\"\n  }, objectFromEntries(\"abcdefghijklmnopqrstuvwxyz\".split(\"\").map(function (c) {\n    return [c, c];\n  }))), objectFromEntries(\"0123456789\".split(\"\").map(function (n) {\n    return [n, n];\n  })))\n};\nfunction objectFromEntries(array) {\n  return array.reduce(function (memo, _ref19) {\n    var _ref20 = _slicedToArray(_ref19, 2),\n      k = _ref20[0],\n      v = _ref20[1];\n    return Object.assign(Object.assign({}, memo), _defineProperty({}, k, v));\n  }, {});\n}\nvar Application = /*#__PURE__*/function () {\n  function Application() {\n    var _this24 = this;\n    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.documentElement;\n    var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSchema;\n    _classCallCheck(this, Application);\n    this.logger = console;\n    this.debug = false;\n    this.logDebugActivity = function (identifier, functionName) {\n      var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (_this24.debug) {\n        _this24.logFormattedMessage(identifier, functionName, detail);\n      }\n    };\n    this.element = element;\n    this.schema = schema;\n    this.dispatcher = new Dispatcher(this);\n    this.router = new Router(this);\n    this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);\n  }\n  return _createClass(Application, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return domReady();\n            case 2:\n              this.logDebugActivity(\"application\", \"starting\");\n              this.dispatcher.start();\n              this.router.start();\n              this.logDebugActivity(\"application\", \"start\");\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.logDebugActivity(\"application\", \"stopping\");\n      this.dispatcher.stop();\n      this.router.stop();\n      this.logDebugActivity(\"application\", \"stop\");\n    }\n  }, {\n    key: \"register\",\n    value: function register(identifier, controllerConstructor) {\n      this.load({\n        identifier: identifier,\n        controllerConstructor: controllerConstructor\n      });\n    }\n  }, {\n    key: \"registerActionOption\",\n    value: function registerActionOption(name, filter) {\n      this.actionDescriptorFilters[name] = filter;\n    }\n  }, {\n    key: \"load\",\n    value: function load(head) {\n      var _this25 = this;\n      for (var _len6 = arguments.length, rest = new Array(_len6 > 1 ? _len6 - 1 : 0), _key7 = 1; _key7 < _len6; _key7++) {\n        rest[_key7 - 1] = arguments[_key7];\n      }\n      var definitions = Array.isArray(head) ? head : [head].concat(rest);\n      definitions.forEach(function (definition) {\n        if (definition.controllerConstructor.shouldLoad) {\n          _this25.router.loadDefinition(definition);\n        }\n      });\n    }\n  }, {\n    key: \"unload\",\n    value: function unload(head) {\n      var _this26 = this;\n      for (var _len7 = arguments.length, rest = new Array(_len7 > 1 ? _len7 - 1 : 0), _key8 = 1; _key8 < _len7; _key8++) {\n        rest[_key8 - 1] = arguments[_key8];\n      }\n      var identifiers = Array.isArray(head) ? head : [head].concat(rest);\n      identifiers.forEach(function (identifier) {\n        return _this26.router.unloadIdentifier(identifier);\n      });\n    }\n  }, {\n    key: \"controllers\",\n    get: function get() {\n      return this.router.contexts.map(function (context) {\n        return context.controller;\n      });\n    }\n  }, {\n    key: \"getControllerForElementAndIdentifier\",\n    value: function getControllerForElementAndIdentifier(element, identifier) {\n      var context = this.router.getContextForElementAndIdentifier(element, identifier);\n      return context ? context.controller : null;\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(error, message, detail) {\n      var _a;\n      this.logger.error(\"%s\\n\\n%o\\n\\n%o\", message, error, detail);\n      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, \"\", 0, 0, error);\n    }\n  }, {\n    key: \"logFormattedMessage\",\n    value: function logFormattedMessage(identifier, functionName) {\n      var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      detail = Object.assign({\n        application: this\n      }, detail);\n      this.logger.groupCollapsed(\"\".concat(identifier, \" #\").concat(functionName));\n      this.logger.log(\"details:\", Object.assign({}, detail));\n      this.logger.groupEnd();\n    }\n  }], [{\n    key: \"start\",\n    value: function start(element, schema) {\n      var application = new this(element, schema);\n      application.start();\n      return application;\n    }\n  }]);\n}();\nfunction domReady() {\n  return new Promise(function (resolve) {\n    if (document.readyState == \"loading\") {\n      document.addEventListener(\"DOMContentLoaded\", function () {\n        return resolve();\n      });\n    } else {\n      resolve();\n    }\n  });\n}\nfunction ClassPropertiesBlessing(constructor) {\n  var classes = readInheritableStaticArrayValues(constructor, \"classes\");\n  return classes.reduce(function (properties, classDefinition) {\n    return Object.assign(properties, propertiesForClassDefinition(classDefinition));\n  }, {});\n}\nfunction propertiesForClassDefinition(key) {\n  return _defineProperty(_defineProperty(_defineProperty({}, \"\".concat(key, \"Class\"), {\n    get: function get() {\n      var classes = this.classes;\n      if (classes.has(key)) {\n        return classes.get(key);\n      } else {\n        var attribute = classes.getAttributeName(key);\n        throw new Error(\"Missing attribute \\\"\".concat(attribute, \"\\\"\"));\n      }\n    }\n  }), \"\".concat(key, \"Classes\"), {\n    get: function get() {\n      return this.classes.getAll(key);\n    }\n  }), \"has\".concat(capitalize(key), \"Class\"), {\n    get: function get() {\n      return this.classes.has(key);\n    }\n  });\n}\nfunction OutletPropertiesBlessing(constructor) {\n  var outlets = readInheritableStaticArrayValues(constructor, \"outlets\");\n  return outlets.reduce(function (properties, outletDefinition) {\n    return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));\n  }, {});\n}\nfunction getOutletController(controller, element, identifier) {\n  return controller.application.getControllerForElementAndIdentifier(element, identifier);\n}\nfunction getControllerAndEnsureConnectedScope(controller, element, outletName) {\n  var outletController = getOutletController(controller, element, outletName);\n  if (outletController) return outletController;\n  controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);\n  outletController = getOutletController(controller, element, outletName);\n  if (outletController) return outletController;\n}\nfunction propertiesForOutletDefinition(name) {\n  var camelizedName = namespaceCamelize(name);\n  return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, \"\".concat(camelizedName, \"Outlet\"), {\n    get: function get() {\n      var outletElement = this.outlets.find(name);\n      var selector = this.outlets.getSelectorForOutletName(name);\n      if (outletElement) {\n        var outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);\n        if (outletController) return outletController;\n        throw new Error(\"The provided outlet element is missing an outlet controller \\\"\".concat(name, \"\\\" instance for host controller \\\"\").concat(this.identifier, \"\\\"\"));\n      }\n      throw new Error(\"Missing outlet element \\\"\".concat(name, \"\\\" for host controller \\\"\").concat(this.identifier, \"\\\". Stimulus couldn't find a matching outlet element using selector \\\"\").concat(selector, \"\\\".\"));\n    }\n  }), \"\".concat(camelizedName, \"Outlets\"), {\n    get: function get() {\n      var _this27 = this;\n      var outlets = this.outlets.findAll(name);\n      if (outlets.length > 0) {\n        return outlets.map(function (outletElement) {\n          var outletController = getControllerAndEnsureConnectedScope(_this27, outletElement, name);\n          if (outletController) return outletController;\n          console.warn(\"The provided outlet element is missing an outlet controller \\\"\".concat(name, \"\\\" instance for host controller \\\"\").concat(_this27.identifier, \"\\\"\"), outletElement);\n        }).filter(function (controller) {\n          return controller;\n        });\n      }\n      return [];\n    }\n  }), \"\".concat(camelizedName, \"OutletElement\"), {\n    get: function get() {\n      var outletElement = this.outlets.find(name);\n      var selector = this.outlets.getSelectorForOutletName(name);\n      if (outletElement) {\n        return outletElement;\n      } else {\n        throw new Error(\"Missing outlet element \\\"\".concat(name, \"\\\" for host controller \\\"\").concat(this.identifier, \"\\\". Stimulus couldn't find a matching outlet element using selector \\\"\").concat(selector, \"\\\".\"));\n      }\n    }\n  }), \"\".concat(camelizedName, \"OutletElements\"), {\n    get: function get() {\n      return this.outlets.findAll(name);\n    }\n  }), \"has\".concat(capitalize(camelizedName), \"Outlet\"), {\n    get: function get() {\n      return this.outlets.has(name);\n    }\n  });\n}\nfunction TargetPropertiesBlessing(constructor) {\n  var targets = readInheritableStaticArrayValues(constructor, \"targets\");\n  return targets.reduce(function (properties, targetDefinition) {\n    return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));\n  }, {});\n}\nfunction propertiesForTargetDefinition(name) {\n  return _defineProperty(_defineProperty(_defineProperty({}, \"\".concat(name, \"Target\"), {\n    get: function get() {\n      var target = this.targets.find(name);\n      if (target) {\n        return target;\n      } else {\n        throw new Error(\"Missing target element \\\"\".concat(name, \"\\\" for \\\"\").concat(this.identifier, \"\\\" controller\"));\n      }\n    }\n  }), \"\".concat(name, \"Targets\"), {\n    get: function get() {\n      return this.targets.findAll(name);\n    }\n  }), \"has\".concat(capitalize(name), \"Target\"), {\n    get: function get() {\n      return this.targets.has(name);\n    }\n  });\n}\nfunction ValuePropertiesBlessing(constructor) {\n  var valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, \"values\");\n  var propertyDescriptorMap = {\n    valueDescriptorMap: {\n      get: function get() {\n        var _this28 = this;\n        return valueDefinitionPairs.reduce(function (result, valueDefinitionPair) {\n          var valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, _this28.identifier);\n          var attributeName = _this28.data.getAttributeNameForKey(valueDescriptor.key);\n          return Object.assign(result, _defineProperty({}, attributeName, valueDescriptor));\n        }, {});\n      }\n    }\n  };\n  return valueDefinitionPairs.reduce(function (properties, valueDefinitionPair) {\n    return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));\n  }, propertyDescriptorMap);\n}\nfunction propertiesForValueDefinitionPair(valueDefinitionPair, controller) {\n  var definition = parseValueDefinitionPair(valueDefinitionPair, controller);\n  var key = definition.key,\n    name = definition.name,\n    read = definition.reader,\n    write = definition.writer;\n  return _defineProperty(_defineProperty({}, name, {\n    get: function get() {\n      var value = this.data.get(key);\n      if (value !== null) {\n        return read(value);\n      } else {\n        return definition.defaultValue;\n      }\n    },\n    set: function set(value) {\n      if (value === undefined) {\n        this.data[\"delete\"](key);\n      } else {\n        this.data.set(key, write(value));\n      }\n    }\n  }), \"has\".concat(capitalize(name)), {\n    get: function get() {\n      return this.data.has(key) || definition.hasCustomDefaultValue;\n    }\n  });\n}\nfunction parseValueDefinitionPair(_ref25, controller) {\n  var _ref26 = _slicedToArray(_ref25, 2),\n    token = _ref26[0],\n    typeDefinition = _ref26[1];\n  return valueDescriptorForTokenAndTypeDefinition({\n    controller: controller,\n    token: token,\n    typeDefinition: typeDefinition\n  });\n}\nfunction parseValueTypeConstant(constant) {\n  switch (constant) {\n    case Array:\n      return \"array\";\n    case Boolean:\n      return \"boolean\";\n    case Number:\n      return \"number\";\n    case Object:\n      return \"object\";\n    case String:\n      return \"string\";\n  }\n}\nfunction parseValueTypeDefault(defaultValue) {\n  switch (_typeof(defaultValue)) {\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n    case \"string\":\n      return \"string\";\n  }\n  if (Array.isArray(defaultValue)) return \"array\";\n  if (Object.prototype.toString.call(defaultValue) === \"[object Object]\") return \"object\";\n}\nfunction parseValueTypeObject(payload) {\n  var controller = payload.controller,\n    token = payload.token,\n    typeObject = payload.typeObject;\n  var hasType = isSomething(typeObject.type);\n  var hasDefault = isSomething(typeObject[\"default\"]);\n  var fullObject = hasType && hasDefault;\n  var onlyType = hasType && !hasDefault;\n  var onlyDefault = !hasType && hasDefault;\n  var typeFromObject = parseValueTypeConstant(typeObject.type);\n  var typeFromDefaultValue = parseValueTypeDefault(payload.typeObject[\"default\"]);\n  if (onlyType) return typeFromObject;\n  if (onlyDefault) return typeFromDefaultValue;\n  if (typeFromObject !== typeFromDefaultValue) {\n    var propertyPath = controller ? \"\".concat(controller, \".\").concat(token) : token;\n    throw new Error(\"The specified default value for the Stimulus Value \\\"\".concat(propertyPath, \"\\\" must match the defined type \\\"\").concat(typeFromObject, \"\\\". The provided default value of \\\"\").concat(typeObject[\"default\"], \"\\\" is of type \\\"\").concat(typeFromDefaultValue, \"\\\".\"));\n  }\n  if (fullObject) return typeFromObject;\n}\nfunction parseValueTypeDefinition(payload) {\n  var controller = payload.controller,\n    token = payload.token,\n    typeDefinition = payload.typeDefinition;\n  var typeObject = {\n    controller: controller,\n    token: token,\n    typeObject: typeDefinition\n  };\n  var typeFromObject = parseValueTypeObject(typeObject);\n  var typeFromDefaultValue = parseValueTypeDefault(typeDefinition);\n  var typeFromConstant = parseValueTypeConstant(typeDefinition);\n  var type = typeFromObject || typeFromDefaultValue || typeFromConstant;\n  if (type) return type;\n  var propertyPath = controller ? \"\".concat(controller, \".\").concat(typeDefinition) : token;\n  throw new Error(\"Unknown value type \\\"\".concat(propertyPath, \"\\\" for \\\"\").concat(token, \"\\\" value\"));\n}\nfunction defaultValueForDefinition(typeDefinition) {\n  var constant = parseValueTypeConstant(typeDefinition);\n  if (constant) return defaultValuesByType[constant];\n  var hasDefault = hasProperty(typeDefinition, \"default\");\n  var hasType = hasProperty(typeDefinition, \"type\");\n  var typeObject = typeDefinition;\n  if (hasDefault) return typeObject[\"default\"];\n  if (hasType) {\n    var type = typeObject.type;\n    var constantFromType = parseValueTypeConstant(type);\n    if (constantFromType) return defaultValuesByType[constantFromType];\n  }\n  return typeDefinition;\n}\nfunction valueDescriptorForTokenAndTypeDefinition(payload) {\n  var token = payload.token,\n    typeDefinition = payload.typeDefinition;\n  var key = \"\".concat(dasherize(token), \"-value\");\n  var type = parseValueTypeDefinition(payload);\n  return {\n    type: type,\n    key: key,\n    name: camelize(key),\n    get defaultValue() {\n      return defaultValueForDefinition(typeDefinition);\n    },\n    get hasCustomDefaultValue() {\n      return parseValueTypeDefault(typeDefinition) !== undefined;\n    },\n    reader: readers[type],\n    writer: writers[type] || writers[\"default\"]\n  };\n}\nvar defaultValuesByType = {\n  get array() {\n    return [];\n  },\n  \"boolean\": false,\n  number: 0,\n  get object() {\n    return {};\n  },\n  string: \"\"\n};\nvar readers = {\n  array: function array(value) {\n    var array = JSON.parse(value);\n    if (!Array.isArray(array)) {\n      throw new TypeError(\"expected value of type \\\"array\\\" but instead got value \\\"\".concat(value, \"\\\" of type \\\"\").concat(parseValueTypeDefault(array), \"\\\"\"));\n    }\n    return array;\n  },\n  \"boolean\": function boolean(value) {\n    return !(value == \"0\" || String(value).toLowerCase() == \"false\");\n  },\n  number: function number(value) {\n    return Number(value.replace(/_/g, \"\"));\n  },\n  object: function object(value) {\n    var object = JSON.parse(value);\n    if (object === null || _typeof(object) != \"object\" || Array.isArray(object)) {\n      throw new TypeError(\"expected value of type \\\"object\\\" but instead got value \\\"\".concat(value, \"\\\" of type \\\"\").concat(parseValueTypeDefault(object), \"\\\"\"));\n    }\n    return object;\n  },\n  string: function string(value) {\n    return value;\n  }\n};\nvar writers = {\n  \"default\": writeString,\n  array: writeJSON,\n  object: writeJSON\n};\nfunction writeJSON(value) {\n  return JSON.stringify(value);\n}\nfunction writeString(value) {\n  return \"\".concat(value);\n}\nvar Controller = /*#__PURE__*/function () {\n  function Controller(context) {\n    _classCallCheck(this, Controller);\n    this.context = context;\n  }\n  return _createClass(Controller, [{\n    key: \"application\",\n    get: function get() {\n      return this.context.application;\n    }\n  }, {\n    key: \"scope\",\n    get: function get() {\n      return this.context.scope;\n    }\n  }, {\n    key: \"element\",\n    get: function get() {\n      return this.scope.element;\n    }\n  }, {\n    key: \"identifier\",\n    get: function get() {\n      return this.scope.identifier;\n    }\n  }, {\n    key: \"targets\",\n    get: function get() {\n      return this.scope.targets;\n    }\n  }, {\n    key: \"outlets\",\n    get: function get() {\n      return this.scope.outlets;\n    }\n  }, {\n    key: \"classes\",\n    get: function get() {\n      return this.scope.classes;\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.scope.data;\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {}\n  }, {\n    key: \"connect\",\n    value: function connect() {}\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {}\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(eventName) {\n      var _ref27 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref27$target = _ref27.target,\n        target = _ref27$target === void 0 ? this.element : _ref27$target,\n        _ref27$detail = _ref27.detail,\n        detail = _ref27$detail === void 0 ? {} : _ref27$detail,\n        _ref27$prefix = _ref27.prefix,\n        prefix = _ref27$prefix === void 0 ? this.identifier : _ref27$prefix,\n        _ref27$bubbles = _ref27.bubbles,\n        bubbles = _ref27$bubbles === void 0 ? true : _ref27$bubbles,\n        _ref27$cancelable = _ref27.cancelable,\n        cancelable = _ref27$cancelable === void 0 ? true : _ref27$cancelable;\n      var type = prefix ? \"\".concat(prefix, \":\").concat(eventName) : eventName;\n      var event = new CustomEvent(type, {\n        detail: detail,\n        bubbles: bubbles,\n        cancelable: cancelable\n      });\n      target.dispatchEvent(event);\n      return event;\n    }\n  }], [{\n    key: \"shouldLoad\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"afterLoad\",\n    value: function afterLoad(_identifier, _application) {\n      return;\n    }\n  }]);\n}();\nController.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing, OutletPropertiesBlessing];\nController.targets = [];\nController.outlets = [];\nController.values = {};\nexport { Application, AttributeObserver, Context, Controller, ElementObserver, IndexedMultimap, Multimap, SelectorObserver, StringMapObserver, TokenListObserver, ValueListObserver, _add as add, defaultSchema, del, fetch, prune };","map":null,"metadata":{},"sourceType":"module"}