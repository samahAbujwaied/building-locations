{"ast":null,"code":"var _templateObject, _templateObject2;\nvar _excluded = [\"callbacks\"];\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _taggedTemplateLiteral(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = \"function\" == typeof Symbol ? Symbol : {}, a = i.iterator || \"@@iterator\", c = i.asyncIterator || \"@@asyncIterator\", u = i.toStringTag || \"@@toStringTag\"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, \"\"); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, \"_invoke\", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: \"normal\", arg: t.call(e, r) }; } catch (t) { return { type: \"throw\", arg: t }; } } e.wrap = wrap; var h = \"suspendedStart\", l = \"suspendedYield\", f = \"executing\", s = \"completed\", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { [\"next\", \"throw\", \"return\"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if (\"throw\" !== c.type) { var u = c.arg, h = u.value; return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) { invoke(\"next\", t, i, a); }, function (t) { invoke(\"throw\", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke(\"throw\", t, i, a); }); } a(c.arg); } var r; o(this, \"_invoke\", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error(\"Generator is already running\"); if (o === s) { if (\"throw\" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else \"return\" === n.method && n.abrupt(\"return\", n.arg); o = f; var p = tryCatch(e, r, n); if (\"normal\" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y; var i = tryCatch(o, e.iterator, r.arg); if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = \"normal\", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: \"root\" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || \"\" === e) { var r = e[a]; if (r) return r.call(e); if (\"function\" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + \" is not iterable\"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) { var e = \"function\" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () { return this; }), define(g, \"toString\", function () { return \"[object Generator]\"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if (\"throw\" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if (\"root\" === i.tryLoc) return handle(\"end\"); if (i.tryLoc <= this.prev) { var c = n.call(i, \"catchLoc\"), u = n.call(i, \"finallyLoc\"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error(\"try statement without catch or finally\"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) { var i = o; break; } } i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if (\"throw\" === t.type) throw t.arg; return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, \"catch\": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if (\"throw\" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, \"next\" === this.method && (this.arg = t), y; } }, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && \"function\" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _classPrivateFieldLooseBase(e, t) { if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\"); return e; }\nvar id = 0;\nfunction _classPrivateFieldLooseKey(e) { return \"__private_\" + id++ + \"_\" + e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = \"function\" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf(\"[native code]\"); } catch (n) { return \"function\" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\n/*!\nTurbo 8.0.12\nCopyright Â© 2024 37signals LLC\n */\n/**\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Javan Makhmali\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n(function (prototype) {\n  if (typeof prototype.requestSubmit == \"function\") return;\n  prototype.requestSubmit = function (submitter) {\n    if (submitter) {\n      validateSubmitter(submitter, this);\n      submitter.click();\n    } else {\n      submitter = document.createElement(\"input\");\n      submitter.type = \"submit\";\n      submitter.hidden = true;\n      this.appendChild(submitter);\n      submitter.click();\n      this.removeChild(submitter);\n    }\n  };\n  function validateSubmitter(submitter, form) {\n    submitter instanceof HTMLElement || raise(TypeError, \"parameter 1 is not of type 'HTMLElement'\");\n    submitter.type == \"submit\" || raise(TypeError, \"The specified element is not a submit button\");\n    submitter.form == form || raise(DOMException, \"The specified element is not owned by this form element\", \"NotFoundError\");\n  }\n  function raise(errorConstructor, message, name) {\n    throw new errorConstructor(\"Failed to execute 'requestSubmit' on 'HTMLFormElement': \" + message + \".\", name);\n  }\n})(HTMLFormElement.prototype);\nvar submittersByForm = new WeakMap();\nfunction findSubmitterFromClickTarget(target) {\n  var element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;\n  var candidate = element ? element.closest(\"input, button\") : null;\n  return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == \"submit\" ? candidate : null;\n}\nfunction clickCaptured(event) {\n  var submitter = findSubmitterFromClickTarget(event.target);\n  if (submitter && submitter.form) {\n    submittersByForm.set(submitter.form, submitter);\n  }\n}\n(function () {\n  if (\"submitter\" in Event.prototype) return;\n  var prototype = window.Event.prototype;\n  // Certain versions of Safari 15 have a bug where they won't\n  // populate the submitter. This hurts TurboDrive's enable/disable detection.\n  // See https://bugs.webkit.org/show_bug.cgi?id=229660\n  if (\"SubmitEvent\" in window) {\n    var prototypeOfSubmitEvent = window.SubmitEvent.prototype;\n    if (/Apple Computer/.test(navigator.vendor) && !(\"submitter\" in prototypeOfSubmitEvent)) {\n      prototype = prototypeOfSubmitEvent;\n    } else {\n      return; // polyfill not needed\n    }\n  }\n  addEventListener(\"click\", clickCaptured, true);\n  Object.defineProperty(prototype, \"submitter\", {\n    get: function get() {\n      if (this.type == \"submit\" && this.target instanceof HTMLFormElement) {\n        return submittersByForm.get(this.target);\n      }\n    }\n  });\n})();\nvar FrameLoadingStyle = {\n  eager: \"eager\",\n  lazy: \"lazy\"\n};\n\n/**\n * Contains a fragment of HTML which is updated based on navigation within\n * it (e.g. via links or form submissions).\n *\n * @customElement turbo-frame\n * @example\n *   <turbo-frame id=\"messages\">\n *     <a href=\"/messages/expanded\">\n *       Show all expanded messages in this frame.\n *     </a>\n *\n *     <form action=\"/messages\">\n *       Show response from this form within this frame.\n *     </form>\n *   </turbo-frame>\n */\nvar FrameElement = /*#__PURE__*/function (_HTMLElement) {\n  function FrameElement() {\n    var _this;\n    _classCallCheck(this, FrameElement);\n    _this = _callSuper(this, FrameElement);\n    _this.loaded = Promise.resolve();\n    _this.delegate = new FrameElement.delegateConstructor(_this);\n    return _this;\n  }\n  _inherits(FrameElement, _HTMLElement);\n  return _createClass(FrameElement, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      this.delegate.connect();\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      this.delegate.disconnect();\n    }\n  }, {\n    key: \"reload\",\n    value: function reload() {\n      return this.delegate.sourceURLReloaded();\n    }\n  }, {\n    key: \"attributeChangedCallback\",\n    value: function attributeChangedCallback(name) {\n      if (name == \"loading\") {\n        this.delegate.loadingStyleChanged();\n      } else if (name == \"src\") {\n        this.delegate.sourceURLChanged();\n      } else if (name == \"disabled\") {\n        this.delegate.disabledChanged();\n      }\n    }\n\n    /**\n     * Gets the URL to lazily load source HTML from\n     */\n  }, {\n    key: \"src\",\n    get: function get() {\n      return this.getAttribute(\"src\");\n    }\n\n    /**\n     * Sets the URL to lazily load source HTML from\n     */,\n    set: function set(value) {\n      if (value) {\n        this.setAttribute(\"src\", value);\n      } else {\n        this.removeAttribute(\"src\");\n      }\n    }\n\n    /**\n     * Gets the refresh mode for the frame.\n     */\n  }, {\n    key: \"refresh\",\n    get: function get() {\n      return this.getAttribute(\"refresh\");\n    }\n\n    /**\n     * Sets the refresh mode for the frame.\n     */,\n    set: function set(value) {\n      if (value) {\n        this.setAttribute(\"refresh\", value);\n      } else {\n        this.removeAttribute(\"refresh\");\n      }\n    }\n  }, {\n    key: \"shouldReloadWithMorph\",\n    get: function get() {\n      return this.src && this.refresh === \"morph\";\n    }\n\n    /**\n     * Determines if the element is loading\n     */\n  }, {\n    key: \"loading\",\n    get: function get() {\n      return frameLoadingStyleFromString(this.getAttribute(\"loading\") || \"\");\n    }\n\n    /**\n     * Sets the value of if the element is loading\n     */,\n    set: function set(value) {\n      if (value) {\n        this.setAttribute(\"loading\", value);\n      } else {\n        this.removeAttribute(\"loading\");\n      }\n    }\n\n    /**\n     * Gets the disabled state of the frame.\n     *\n     * If disabled, no requests will be intercepted by the frame.\n     */\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this.hasAttribute(\"disabled\");\n    }\n\n    /**\n     * Sets the disabled state of the frame.\n     *\n     * If disabled, no requests will be intercepted by the frame.\n     */,\n    set: function set(value) {\n      if (value) {\n        this.setAttribute(\"disabled\", \"\");\n      } else {\n        this.removeAttribute(\"disabled\");\n      }\n    }\n\n    /**\n     * Gets the autoscroll state of the frame.\n     *\n     * If true, the frame will be scrolled into view automatically on update.\n     */\n  }, {\n    key: \"autoscroll\",\n    get: function get() {\n      return this.hasAttribute(\"autoscroll\");\n    }\n\n    /**\n     * Sets the autoscroll state of the frame.\n     *\n     * If true, the frame will be scrolled into view automatically on update.\n     */,\n    set: function set(value) {\n      if (value) {\n        this.setAttribute(\"autoscroll\", \"\");\n      } else {\n        this.removeAttribute(\"autoscroll\");\n      }\n    }\n\n    /**\n     * Determines if the element has finished loading\n     */\n  }, {\n    key: \"complete\",\n    get: function get() {\n      return !this.delegate.isLoading;\n    }\n\n    /**\n     * Gets the active state of the frame.\n     *\n     * If inactive, source changes will not be observed.\n     */\n  }, {\n    key: \"isActive\",\n    get: function get() {\n      return this.ownerDocument === document && !this.isPreview;\n    }\n\n    /**\n     * Sets the active state of the frame.\n     *\n     * If inactive, source changes will not be observed.\n     */\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      var _this$ownerDocument, _this$ownerDocument$d;\n      return (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : (_this$ownerDocument$d = _this$ownerDocument.documentElement) === null || _this$ownerDocument$d === void 0 ? void 0 : _this$ownerDocument$d.hasAttribute(\"data-turbo-preview\");\n    }\n  }], [{\n    key: \"observedAttributes\",\n    get: function get() {\n      return [\"disabled\", \"loading\", \"src\"];\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(HTMLElement));\nFrameElement.delegateConstructor = undefined;\nfunction frameLoadingStyleFromString(style) {\n  switch (style.toLowerCase()) {\n    case \"lazy\":\n      return FrameLoadingStyle.lazy;\n    default:\n      return FrameLoadingStyle.eager;\n  }\n}\nvar drive = {\n  enabled: true,\n  progressBarDelay: 500,\n  unvisitableExtensions: new Set([\".7z\", \".aac\", \".apk\", \".avi\", \".bmp\", \".bz2\", \".css\", \".csv\", \".deb\", \".dmg\", \".doc\", \".docx\", \".exe\", \".gif\", \".gz\", \".heic\", \".heif\", \".ico\", \".iso\", \".jpeg\", \".jpg\", \".js\", \".json\", \".m4a\", \".mkv\", \".mov\", \".mp3\", \".mp4\", \".mpeg\", \".mpg\", \".msi\", \".ogg\", \".ogv\", \".pdf\", \".pkg\", \".png\", \".ppt\", \".pptx\", \".rar\", \".rtf\", \".svg\", \".tar\", \".tif\", \".tiff\", \".txt\", \".wav\", \".webm\", \".webp\", \".wma\", \".wmv\", \".xls\", \".xlsx\", \".xml\", \".zip\"])\n};\nfunction activateScriptElement(element) {\n  if (element.getAttribute(\"data-turbo-eval\") == \"false\") {\n    return element;\n  } else {\n    var createdScriptElement = document.createElement(\"script\");\n    var cspNonce = getCspNonce();\n    if (cspNonce) {\n      createdScriptElement.nonce = cspNonce;\n    }\n    createdScriptElement.textContent = element.textContent;\n    createdScriptElement.async = false;\n    copyElementAttributes(createdScriptElement, element);\n    return createdScriptElement;\n  }\n}\nfunction copyElementAttributes(destinationElement, sourceElement) {\n  var _iterator = _createForOfIteratorHelper(sourceElement.attributes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ref = _step.value;\n      var name = _ref.name;\n      var value = _ref.value;\n      destinationElement.setAttribute(name, value);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction createDocumentFragment(html) {\n  var template = document.createElement(\"template\");\n  template.innerHTML = html;\n  return template.content;\n}\nfunction dispatch(eventName) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    target = _ref2.target,\n    cancelable = _ref2.cancelable,\n    detail = _ref2.detail;\n  var event = new CustomEvent(eventName, {\n    cancelable: cancelable,\n    bubbles: true,\n    composed: true,\n    detail: detail\n  });\n  if (target && target.isConnected) {\n    target.dispatchEvent(event);\n  } else {\n    document.documentElement.dispatchEvent(event);\n  }\n  return event;\n}\nfunction cancelEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n}\nfunction nextRepaint() {\n  if (document.visibilityState === \"hidden\") {\n    return nextEventLoopTick();\n  } else {\n    return nextAnimationFrame();\n  }\n}\nfunction nextAnimationFrame() {\n  return new Promise(function (resolve) {\n    return requestAnimationFrame(function () {\n      return resolve();\n    });\n  });\n}\nfunction nextEventLoopTick() {\n  return new Promise(function (resolve) {\n    return setTimeout(function () {\n      return resolve();\n    }, 0);\n  });\n}\nfunction nextMicrotask() {\n  return Promise.resolve();\n}\nfunction parseHTMLDocument() {\n  var html = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return new DOMParser().parseFromString(html, \"text/html\");\n}\nfunction unindent(strings) {\n  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n  var lines = interpolate(strings, values).replace(/^\\n/, \"\").split(\"\\n\");\n  var match = lines[0].match(/^\\s+/);\n  var indent = match ? match[0].length : 0;\n  return lines.map(function (line) {\n    return line.slice(indent);\n  }).join(\"\\n\");\n}\nfunction interpolate(strings, values) {\n  return strings.reduce(function (result, string, i) {\n    var value = values[i] == undefined ? \"\" : values[i];\n    return result + string + value;\n  }, \"\");\n}\nfunction uuid() {\n  return Array.from({\n    length: 36\n  }).map(function (_, i) {\n    if (i == 8 || i == 13 || i == 18 || i == 23) {\n      return \"-\";\n    } else if (i == 14) {\n      return \"4\";\n    } else if (i == 19) {\n      return (Math.floor(Math.random() * 4) + 8).toString(16);\n    } else {\n      return Math.floor(Math.random() * 15).toString(16);\n    }\n  }).join(\"\");\n}\nfunction getAttribute(attributeName) {\n  for (var _len2 = arguments.length, elements = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    elements[_key2 - 1] = arguments[_key2];\n  }\n  var _iterator2 = _createForOfIteratorHelper(elements.map(function (element) {\n      return element === null || element === void 0 ? void 0 : element.getAttribute(attributeName);\n    })),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var value = _step2.value;\n      if (typeof value == \"string\") return value;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return null;\n}\nfunction hasAttribute(attributeName) {\n  for (var _len3 = arguments.length, elements = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    elements[_key3 - 1] = arguments[_key3];\n  }\n  return elements.some(function (element) {\n    return element && element.hasAttribute(attributeName);\n  });\n}\nfunction markAsBusy() {\n  for (var _len4 = arguments.length, elements = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    elements[_key4] = arguments[_key4];\n  }\n  for (var _i = 0, _elements = elements; _i < _elements.length; _i++) {\n    var element = _elements[_i];\n    if (element.localName == \"turbo-frame\") {\n      element.setAttribute(\"busy\", \"\");\n    }\n    element.setAttribute(\"aria-busy\", \"true\");\n  }\n}\nfunction clearBusyState() {\n  for (var _len5 = arguments.length, elements = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    elements[_key5] = arguments[_key5];\n  }\n  for (var _i2 = 0, _elements2 = elements; _i2 < _elements2.length; _i2++) {\n    var element = _elements2[_i2];\n    if (element.localName == \"turbo-frame\") {\n      element.removeAttribute(\"busy\");\n    }\n    element.removeAttribute(\"aria-busy\");\n  }\n}\nfunction waitForLoad(element) {\n  var timeoutInMilliseconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;\n  return new Promise(function (resolve) {\n    var _onComplete = function onComplete() {\n      element.removeEventListener(\"error\", _onComplete);\n      element.removeEventListener(\"load\", _onComplete);\n      resolve();\n    };\n    element.addEventListener(\"load\", _onComplete, {\n      once: true\n    });\n    element.addEventListener(\"error\", _onComplete, {\n      once: true\n    });\n    setTimeout(resolve, timeoutInMilliseconds);\n  });\n}\nfunction getHistoryMethodForAction(action) {\n  switch (action) {\n    case \"replace\":\n      return history.replaceState;\n    case \"advance\":\n    case \"restore\":\n      return history.pushState;\n  }\n}\nfunction isAction(action) {\n  return action == \"advance\" || action == \"replace\" || action == \"restore\";\n}\nfunction getVisitAction() {\n  for (var _len6 = arguments.length, elements = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    elements[_key6] = arguments[_key6];\n  }\n  var action = getAttribute.apply(void 0, [\"data-turbo-action\"].concat(elements));\n  return isAction(action) ? action : null;\n}\nfunction getMetaElement(name) {\n  return document.querySelector(\"meta[name=\\\"\".concat(name, \"\\\"]\"));\n}\nfunction getMetaContent(name) {\n  var element = getMetaElement(name);\n  return element && element.content;\n}\nfunction getCspNonce() {\n  var element = getMetaElement(\"csp-nonce\");\n  if (element) {\n    var nonce = element.nonce,\n      content = element.content;\n    return nonce == \"\" ? content : nonce;\n  }\n}\nfunction setMetaContent(name, content) {\n  var element = getMetaElement(name);\n  if (!element) {\n    element = document.createElement(\"meta\");\n    element.setAttribute(\"name\", name);\n    document.head.appendChild(element);\n  }\n  element.setAttribute(\"content\", content);\n  return element;\n}\nfunction findClosestRecursively(element, selector) {\n  if (element instanceof Element) {\n    var _element$getRootNode;\n    return element.closest(selector) || findClosestRecursively(element.assignedSlot || ((_element$getRootNode = element.getRootNode()) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.host), selector);\n  }\n}\nfunction elementIsFocusable(element) {\n  var inertDisabledOrHidden = \"[inert], :disabled, [hidden], details:not([open]), dialog:not([open])\";\n  return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == \"function\";\n}\nfunction queryAutofocusableElement(elementOrDocumentFragment) {\n  return Array.from(elementOrDocumentFragment.querySelectorAll(\"[autofocus]\")).find(elementIsFocusable);\n}\nfunction around(_x, _x2) {\n  return _around.apply(this, arguments);\n}\nfunction _around() {\n  _around = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee46(callback, reader) {\n    var before, after;\n    return _regeneratorRuntime().wrap(function _callee46$(_context46) {\n      while (1) switch (_context46.prev = _context46.next) {\n        case 0:\n          before = reader();\n          callback();\n          _context46.next = 4;\n          return nextAnimationFrame();\n        case 4:\n          after = reader();\n          return _context46.abrupt(\"return\", [before, after]);\n        case 6:\n        case \"end\":\n          return _context46.stop();\n      }\n    }, _callee46);\n  }));\n  return _around.apply(this, arguments);\n}\nfunction doesNotTargetIFrame(name) {\n  if (name === \"_blank\") {\n    return false;\n  } else if (name) {\n    var _iterator3 = _createForOfIteratorHelper(document.getElementsByName(name)),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var element = _step3.value;\n        if (element instanceof HTMLIFrameElement) return false;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return true;\n  } else {\n    return true;\n  }\n}\nfunction findLinkFromClickTarget(target) {\n  return findClosestRecursively(target, \"a[href]:not([target^=_]):not([download])\");\n}\nfunction getLocationForLink(link) {\n  return expandURL(link.getAttribute(\"href\") || \"\");\n}\nfunction debounce(fn, delay) {\n  var _this2 = this;\n  var timeoutId = null;\n  return function () {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    var callback = function callback() {\n      return fn.apply(_this2, args);\n    };\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(callback, delay);\n  };\n}\nvar submitter = {\n  \"aria-disabled\": {\n    beforeSubmit: function beforeSubmit(submitter) {\n      submitter.setAttribute(\"aria-disabled\", \"true\");\n      submitter.addEventListener(\"click\", cancelEvent);\n    },\n    afterSubmit: function afterSubmit(submitter) {\n      submitter.removeAttribute(\"aria-disabled\");\n      submitter.removeEventListener(\"click\", cancelEvent);\n    }\n  },\n  \"disabled\": {\n    beforeSubmit: function beforeSubmit(submitter) {\n      return submitter.disabled = true;\n    },\n    afterSubmit: function afterSubmit(submitter) {\n      return submitter.disabled = false;\n    }\n  }\n};\nvar _submitter = /*#__PURE__*/_classPrivateFieldLooseKey(\"submitter\");\nvar Config = /*#__PURE__*/function () {\n  function Config(config) {\n    _classCallCheck(this, Config);\n    Object.defineProperty(this, _submitter, {\n      writable: true,\n      value: null\n    });\n    Object.assign(this, config);\n  }\n  return _createClass(Config, [{\n    key: \"submitter\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _submitter)[_submitter];\n    },\n    set: function set(value) {\n      _classPrivateFieldLooseBase(this, _submitter)[_submitter] = submitter[value] || value;\n    }\n  }]);\n}();\nvar forms = new Config({\n  mode: \"on\",\n  submitter: \"disabled\"\n});\nvar config = {\n  drive: drive,\n  forms: forms\n};\nfunction expandURL(locatable) {\n  return new URL(locatable.toString(), document.baseURI);\n}\nfunction getAnchor(url) {\n  var anchorMatch;\n  if (url.hash) {\n    return url.hash.slice(1);\n    // eslint-disable-next-line no-cond-assign\n  } else if (anchorMatch = url.href.match(/#(.*)$/)) {\n    return anchorMatch[1];\n  }\n}\nfunction getAction$1(form, submitter) {\n  var action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"formaction\")) || form.getAttribute(\"action\") || form.action;\n  return expandURL(action);\n}\nfunction getExtension(url) {\n  return (getLastPathComponent(url).match(/\\.[^.]*$/) || [])[0] || \"\";\n}\nfunction isPrefixedBy(baseURL, url) {\n  var prefix = getPrefix(url);\n  return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);\n}\nfunction locationIsVisitable(location, rootLocation) {\n  return isPrefixedBy(location, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location));\n}\nfunction getRequestURL(url) {\n  var anchor = getAnchor(url);\n  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;\n}\nfunction toCacheKey(url) {\n  return getRequestURL(url);\n}\nfunction urlsAreEqual(left, right) {\n  return expandURL(left).href == expandURL(right).href;\n}\nfunction getPathComponents(url) {\n  return url.pathname.split(\"/\").slice(1);\n}\nfunction getLastPathComponent(url) {\n  return getPathComponents(url).slice(-1)[0];\n}\nfunction getPrefix(url) {\n  return addTrailingSlash(url.origin + url.pathname);\n}\nfunction addTrailingSlash(value) {\n  return value.endsWith(\"/\") ? value : value + \"/\";\n}\nvar FetchResponse = /*#__PURE__*/function () {\n  function FetchResponse(response) {\n    _classCallCheck(this, FetchResponse);\n    this.response = response;\n  }\n  return _createClass(FetchResponse, [{\n    key: \"succeeded\",\n    get: function get() {\n      return this.response.ok;\n    }\n  }, {\n    key: \"failed\",\n    get: function get() {\n      return !this.succeeded;\n    }\n  }, {\n    key: \"clientError\",\n    get: function get() {\n      return this.statusCode >= 400 && this.statusCode <= 499;\n    }\n  }, {\n    key: \"serverError\",\n    get: function get() {\n      return this.statusCode >= 500 && this.statusCode <= 599;\n    }\n  }, {\n    key: \"redirected\",\n    get: function get() {\n      return this.response.redirected;\n    }\n  }, {\n    key: \"location\",\n    get: function get() {\n      return expandURL(this.response.url);\n    }\n  }, {\n    key: \"isHTML\",\n    get: function get() {\n      return this.contentType && this.contentType.match(/^(?:text\\/([^\\s;,]+\\b)?html|application\\/xhtml\\+xml)\\b/);\n    }\n  }, {\n    key: \"statusCode\",\n    get: function get() {\n      return this.response.status;\n    }\n  }, {\n    key: \"contentType\",\n    get: function get() {\n      return this.header(\"Content-Type\");\n    }\n  }, {\n    key: \"responseText\",\n    get: function get() {\n      return this.response.clone().text();\n    }\n  }, {\n    key: \"responseHTML\",\n    get: function get() {\n      if (this.isHTML) {\n        return this.response.clone().text();\n      } else {\n        return Promise.resolve(undefined);\n      }\n    }\n  }, {\n    key: \"header\",\n    value: function header(name) {\n      return this.response.headers.get(name);\n    }\n  }]);\n}();\nvar LimitedSet = /*#__PURE__*/function (_Set) {\n  function LimitedSet(maxSize) {\n    var _this3;\n    _classCallCheck(this, LimitedSet);\n    _this3 = _callSuper(this, LimitedSet);\n    _this3.maxSize = maxSize;\n    return _this3;\n  }\n  _inherits(LimitedSet, _Set);\n  return _createClass(LimitedSet, [{\n    key: \"add\",\n    value: function add(value) {\n      if (this.size >= this.maxSize) {\n        var iterator = this.values();\n        var oldestValue = iterator.next().value;\n        this[\"delete\"](oldestValue);\n      }\n      _superPropGet(LimitedSet, \"add\", this, 3)([value]);\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(Set));\nvar recentRequests = new LimitedSet(20);\nvar nativeFetch = window.fetch;\nfunction fetchWithTurboHeaders(url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var modifiedHeaders = new Headers(options.headers || {});\n  var requestUID = uuid();\n  recentRequests.add(requestUID);\n  modifiedHeaders.append(\"X-Turbo-Request-Id\", requestUID);\n  return nativeFetch(url, _objectSpread(_objectSpread({}, options), {}, {\n    headers: modifiedHeaders\n  }));\n}\nfunction fetchMethodFromString(method) {\n  switch (method.toLowerCase()) {\n    case \"get\":\n      return FetchMethod.get;\n    case \"post\":\n      return FetchMethod.post;\n    case \"put\":\n      return FetchMethod.put;\n    case \"patch\":\n      return FetchMethod.patch;\n    case \"delete\":\n      return FetchMethod[\"delete\"];\n  }\n}\nvar FetchMethod = {\n  get: \"get\",\n  post: \"post\",\n  put: \"put\",\n  patch: \"patch\",\n  \"delete\": \"delete\"\n};\nfunction fetchEnctypeFromString(encoding) {\n  switch (encoding.toLowerCase()) {\n    case FetchEnctype.multipart:\n      return FetchEnctype.multipart;\n    case FetchEnctype.plain:\n      return FetchEnctype.plain;\n    default:\n      return FetchEnctype.urlEncoded;\n  }\n}\nvar FetchEnctype = {\n  urlEncoded: \"application/x-www-form-urlencoded\",\n  multipart: \"multipart/form-data\",\n  plain: \"text/plain\"\n};\nvar _resolveRequestPromise = /*#__PURE__*/_classPrivateFieldLooseKey(\"resolveRequestPromise\");\nvar _allowRequestToBeIntercepted = /*#__PURE__*/_classPrivateFieldLooseKey(\"allowRequestToBeIntercepted\");\nvar _willDelegateErrorHandling = /*#__PURE__*/_classPrivateFieldLooseKey(\"willDelegateErrorHandling\");\nvar FetchRequest = /*#__PURE__*/function () {\n  function FetchRequest(delegate, method, location) {\n    var _this$delegate$referr;\n    var requestBody = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new URLSearchParams();\n    var target = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var enctype = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : FetchEnctype.urlEncoded;\n    _classCallCheck(this, FetchRequest);\n    Object.defineProperty(this, _willDelegateErrorHandling, {\n      value: _willDelegateErrorHandling2\n    });\n    Object.defineProperty(this, _allowRequestToBeIntercepted, {\n      value: _allowRequestToBeIntercepted2\n    });\n    this.abortController = new AbortController();\n    Object.defineProperty(this, _resolveRequestPromise, {\n      writable: true,\n      value: function value(_value) {}\n    });\n    var _buildResourceAndBody = buildResourceAndBody(expandURL(location), method, requestBody, enctype),\n      _buildResourceAndBody2 = _slicedToArray(_buildResourceAndBody, 2),\n      url = _buildResourceAndBody2[0],\n      body = _buildResourceAndBody2[1];\n    this.delegate = delegate;\n    this.url = url;\n    this.target = target;\n    this.fetchOptions = {\n      credentials: \"same-origin\",\n      redirect: \"follow\",\n      method: method.toUpperCase(),\n      headers: _objectSpread({}, this.defaultHeaders),\n      body: body,\n      signal: this.abortSignal,\n      referrer: (_this$delegate$referr = this.delegate.referrer) === null || _this$delegate$referr === void 0 ? void 0 : _this$delegate$referr.href\n    };\n    this.enctype = enctype;\n  }\n  return _createClass(FetchRequest, [{\n    key: \"method\",\n    get: function get() {\n      return this.fetchOptions.method;\n    },\n    set: function set(value) {\n      var fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();\n      var fetchMethod = fetchMethodFromString(value) || FetchMethod.get;\n      this.url.search = \"\";\n      var _buildResourceAndBody3 = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype),\n        _buildResourceAndBody4 = _slicedToArray(_buildResourceAndBody3, 2),\n        url = _buildResourceAndBody4[0],\n        body = _buildResourceAndBody4[1];\n      this.url = url;\n      this.fetchOptions.body = body;\n      this.fetchOptions.method = fetchMethod.toUpperCase();\n    }\n  }, {\n    key: \"headers\",\n    get: function get() {\n      return this.fetchOptions.headers;\n    },\n    set: function set(value) {\n      this.fetchOptions.headers = value;\n    }\n  }, {\n    key: \"body\",\n    get: function get() {\n      if (this.isSafe) {\n        return this.url.searchParams;\n      } else {\n        return this.fetchOptions.body;\n      }\n    },\n    set: function set(value) {\n      this.fetchOptions.body = value;\n    }\n  }, {\n    key: \"location\",\n    get: function get() {\n      return this.url;\n    }\n  }, {\n    key: \"params\",\n    get: function get() {\n      return this.url.searchParams;\n    }\n  }, {\n    key: \"entries\",\n    get: function get() {\n      return this.body ? Array.from(this.body.entries()) : [];\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.abortController.abort();\n    }\n  }, {\n    key: \"perform\",\n    value: function () {\n      var _perform = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var fetchOptions, event, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              fetchOptions = this.fetchOptions;\n              this.delegate.prepareRequest(this);\n              _context.next = 4;\n              return _classPrivateFieldLooseBase(this, _allowRequestToBeIntercepted)[_allowRequestToBeIntercepted](fetchOptions);\n            case 4:\n              event = _context.sent;\n              _context.prev = 5;\n              this.delegate.requestStarted(this);\n              if (event.detail.fetchRequest) {\n                this.response = event.detail.fetchRequest.response;\n              } else {\n                this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);\n              }\n              _context.next = 10;\n              return this.response;\n            case 10:\n              response = _context.sent;\n              _context.next = 13;\n              return this.receive(response);\n            case 13:\n              return _context.abrupt(\"return\", _context.sent);\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](5);\n              if (!(_context.t0.name !== \"AbortError\")) {\n                _context.next = 21;\n                break;\n              }\n              if (_classPrivateFieldLooseBase(this, _willDelegateErrorHandling)[_willDelegateErrorHandling](_context.t0)) {\n                this.delegate.requestErrored(this, _context.t0);\n              }\n              throw _context.t0;\n            case 21:\n              _context.prev = 21;\n              this.delegate.requestFinished(this);\n              return _context.finish(21);\n            case 24:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[5, 16, 21, 24]]);\n      }));\n      function perform() {\n        return _perform.apply(this, arguments);\n      }\n      return perform;\n    }()\n  }, {\n    key: \"receive\",\n    value: function () {\n      var _receive = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(response) {\n        var fetchResponse, event;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              fetchResponse = new FetchResponse(response);\n              event = dispatch(\"turbo:before-fetch-response\", {\n                cancelable: true,\n                detail: {\n                  fetchResponse: fetchResponse\n                },\n                target: this.target\n              });\n              if (event.defaultPrevented) {\n                this.delegate.requestPreventedHandlingResponse(this, fetchResponse);\n              } else if (fetchResponse.succeeded) {\n                this.delegate.requestSucceededWithResponse(this, fetchResponse);\n              } else {\n                this.delegate.requestFailedWithResponse(this, fetchResponse);\n              }\n              return _context2.abrupt(\"return\", fetchResponse);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function receive(_x3) {\n        return _receive.apply(this, arguments);\n      }\n      return receive;\n    }()\n  }, {\n    key: \"defaultHeaders\",\n    get: function get() {\n      return {\n        Accept: \"text/html, application/xhtml+xml\"\n      };\n    }\n  }, {\n    key: \"isSafe\",\n    get: function get() {\n      return isSafe(this.method);\n    }\n  }, {\n    key: \"abortSignal\",\n    get: function get() {\n      return this.abortController.signal;\n    }\n  }, {\n    key: \"acceptResponseType\",\n    value: function acceptResponseType(mimeType) {\n      this.headers[\"Accept\"] = [mimeType, this.headers[\"Accept\"]].join(\", \");\n    }\n  }]);\n}();\nfunction _allowRequestToBeIntercepted2(_x40) {\n  return _allowRequestToBeIntercepted3.apply(this, arguments);\n}\nfunction _allowRequestToBeIntercepted3() {\n  _allowRequestToBeIntercepted3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee50(fetchOptions) {\n    var _this53 = this;\n    var requestInterception, event;\n    return _regeneratorRuntime().wrap(function _callee50$(_context50) {\n      while (1) switch (_context50.prev = _context50.next) {\n        case 0:\n          requestInterception = new Promise(function (resolve) {\n            return _classPrivateFieldLooseBase(_this53, _resolveRequestPromise)[_resolveRequestPromise] = resolve;\n          });\n          event = dispatch(\"turbo:before-fetch-request\", {\n            cancelable: true,\n            detail: {\n              fetchOptions: fetchOptions,\n              url: this.url,\n              resume: _classPrivateFieldLooseBase(this, _resolveRequestPromise)[_resolveRequestPromise]\n            },\n            target: this.target\n          });\n          this.url = event.detail.url;\n          if (!event.defaultPrevented) {\n            _context50.next = 6;\n            break;\n          }\n          _context50.next = 6;\n          return requestInterception;\n        case 6:\n          return _context50.abrupt(\"return\", event);\n        case 7:\n        case \"end\":\n          return _context50.stop();\n      }\n    }, _callee50, this);\n  }));\n  return _allowRequestToBeIntercepted3.apply(this, arguments);\n}\nfunction _willDelegateErrorHandling2(error) {\n  var event = dispatch(\"turbo:fetch-request-error\", {\n    target: this.target,\n    cancelable: true,\n    detail: {\n      request: this,\n      error: error\n    }\n  });\n  return !event.defaultPrevented;\n}\nfunction isSafe(fetchMethod) {\n  return fetchMethodFromString(fetchMethod) == FetchMethod.get;\n}\nfunction buildResourceAndBody(resource, method, requestBody, enctype) {\n  var searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;\n  if (isSafe(method)) {\n    return [mergeIntoURLSearchParams(resource, searchParams), null];\n  } else if (enctype == FetchEnctype.urlEncoded) {\n    return [resource, searchParams];\n  } else {\n    return [resource, requestBody];\n  }\n}\nfunction entriesExcludingFiles(requestBody) {\n  var entries = [];\n  var _iterator4 = _createForOfIteratorHelper(requestBody),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _ref3 = _step4.value;\n      var _ref4 = _slicedToArray(_ref3, 2);\n      var name = _ref4[0];\n      var value = _ref4[1];\n      if (value instanceof File) continue;else entries.push([name, value]);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return entries;\n}\nfunction mergeIntoURLSearchParams(url, requestBody) {\n  var searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));\n  url.search = searchParams.toString();\n  return url;\n}\nvar AppearanceObserver = /*#__PURE__*/function () {\n  function AppearanceObserver(delegate, element) {\n    var _this4 = this;\n    _classCallCheck(this, AppearanceObserver);\n    this.started = false;\n    this.intersect = function (entries) {\n      var lastEntry = entries.slice(-1)[0];\n      if (lastEntry !== null && lastEntry !== void 0 && lastEntry.isIntersecting) {\n        _this4.delegate.elementAppearedInViewport(_this4.element);\n      }\n    };\n    this.delegate = delegate;\n    this.element = element;\n    this.intersectionObserver = new IntersectionObserver(this.intersect);\n  }\n  return _createClass(AppearanceObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        this.started = true;\n        this.intersectionObserver.observe(this.element);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.started = false;\n        this.intersectionObserver.unobserve(this.element);\n      }\n    }\n  }]);\n}();\nvar StreamMessage = /*#__PURE__*/function () {\n  function StreamMessage(fragment) {\n    _classCallCheck(this, StreamMessage);\n    this.fragment = importStreamElements(fragment);\n  }\n  return _createClass(StreamMessage, null, [{\n    key: \"wrap\",\n    value: function wrap(message) {\n      if (typeof message == \"string\") {\n        return new this(createDocumentFragment(message));\n      } else {\n        return message;\n      }\n    }\n  }]);\n}();\nStreamMessage.contentType = \"text/vnd.turbo-stream.html\";\nfunction importStreamElements(fragment) {\n  var _iterator5 = _createForOfIteratorHelper(fragment.querySelectorAll(\"turbo-stream\")),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var element = _step5.value;\n      var streamElement = document.importNode(element, true);\n      var _iterator6 = _createForOfIteratorHelper(streamElement.templateElement.content.querySelectorAll(\"script\")),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var inertScriptElement = _step6.value;\n          inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      element.replaceWith(streamElement);\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return fragment;\n}\nvar PREFETCH_DELAY = 100;\nvar _prefetchTimeout = /*#__PURE__*/_classPrivateFieldLooseKey(\"prefetchTimeout\");\nvar _prefetched = /*#__PURE__*/_classPrivateFieldLooseKey(\"prefetched\");\nvar PrefetchCache = /*#__PURE__*/function () {\n  function PrefetchCache() {\n    _classCallCheck(this, PrefetchCache);\n    Object.defineProperty(this, _prefetchTimeout, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _prefetched, {\n      writable: true,\n      value: null\n    });\n  }\n  return _createClass(PrefetchCache, [{\n    key: \"get\",\n    value: function get(url) {\n      if (_classPrivateFieldLooseBase(this, _prefetched)[_prefetched] && _classPrivateFieldLooseBase(this, _prefetched)[_prefetched].url === url && _classPrivateFieldLooseBase(this, _prefetched)[_prefetched].expire > Date.now()) {\n        return _classPrivateFieldLooseBase(this, _prefetched)[_prefetched].request;\n      }\n    }\n  }, {\n    key: \"setLater\",\n    value: function setLater(url, request, ttl) {\n      var _this5 = this;\n      this.clear();\n      _classPrivateFieldLooseBase(this, _prefetchTimeout)[_prefetchTimeout] = setTimeout(function () {\n        request.perform();\n        _this5.set(url, request, ttl);\n        _classPrivateFieldLooseBase(_this5, _prefetchTimeout)[_prefetchTimeout] = null;\n      }, PREFETCH_DELAY);\n    }\n  }, {\n    key: \"set\",\n    value: function set(url, request, ttl) {\n      _classPrivateFieldLooseBase(this, _prefetched)[_prefetched] = {\n        url: url,\n        request: request,\n        expire: new Date(new Date().getTime() + ttl)\n      };\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (_classPrivateFieldLooseBase(this, _prefetchTimeout)[_prefetchTimeout]) clearTimeout(_classPrivateFieldLooseBase(this, _prefetchTimeout)[_prefetchTimeout]);\n      _classPrivateFieldLooseBase(this, _prefetched)[_prefetched] = null;\n    }\n  }]);\n}();\nvar cacheTtl = 10 * 1000;\nvar prefetchCache = new PrefetchCache();\nvar FormSubmissionState = {\n  initialized: \"initialized\",\n  requesting: \"requesting\",\n  waiting: \"waiting\",\n  receiving: \"receiving\",\n  stopping: \"stopping\",\n  stopped: \"stopped\"\n};\nvar FormSubmission = /*#__PURE__*/function () {\n  function FormSubmission(delegate, formElement, submitter) {\n    var mustRedirect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    _classCallCheck(this, FormSubmission);\n    this.state = FormSubmissionState.initialized;\n    var method = getMethod(formElement, submitter);\n    var action = getAction(getFormAction(formElement, submitter), method);\n    var body = buildFormData(formElement, submitter);\n    var enctype = getEnctype(formElement, submitter);\n    this.delegate = delegate;\n    this.formElement = formElement;\n    this.submitter = submitter;\n    this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);\n    this.mustRedirect = mustRedirect;\n  }\n  return _createClass(FormSubmission, [{\n    key: \"method\",\n    get: function get() {\n      return this.fetchRequest.method;\n    },\n    set: function set(value) {\n      this.fetchRequest.method = value;\n    }\n  }, {\n    key: \"action\",\n    get: function get() {\n      return this.fetchRequest.url.toString();\n    },\n    set: function set(value) {\n      this.fetchRequest.url = expandURL(value);\n    }\n  }, {\n    key: \"body\",\n    get: function get() {\n      return this.fetchRequest.body;\n    }\n  }, {\n    key: \"enctype\",\n    get: function get() {\n      return this.fetchRequest.enctype;\n    }\n  }, {\n    key: \"isSafe\",\n    get: function get() {\n      return this.fetchRequest.isSafe;\n    }\n  }, {\n    key: \"location\",\n    get: function get() {\n      return this.fetchRequest.url;\n    }\n\n    // The submission process\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var initialized, requesting, confirmationMessage, confirmMethod, answer;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              initialized = FormSubmissionState.initialized, requesting = FormSubmissionState.requesting;\n              confirmationMessage = getAttribute(\"data-turbo-confirm\", this.submitter, this.formElement);\n              if (!(typeof confirmationMessage === \"string\")) {\n                _context3.next = 9;\n                break;\n              }\n              confirmMethod = typeof config.forms.confirm === \"function\" ? config.forms.confirm : FormSubmission.confirmMethod;\n              _context3.next = 6;\n              return confirmMethod(confirmationMessage, this.formElement, this.submitter);\n            case 6:\n              answer = _context3.sent;\n              if (answer) {\n                _context3.next = 9;\n                break;\n              }\n              return _context3.abrupt(\"return\");\n            case 9:\n              if (!(this.state == initialized)) {\n                _context3.next = 12;\n                break;\n              }\n              this.state = requesting;\n              return _context3.abrupt(\"return\", this.fetchRequest.perform());\n            case 12:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var stopping = FormSubmissionState.stopping,\n        stopped = FormSubmissionState.stopped;\n      if (this.state != stopping && this.state != stopped) {\n        this.state = stopping;\n        this.fetchRequest.cancel();\n        return true;\n      }\n    }\n\n    // Fetch request delegate\n  }, {\n    key: \"prepareRequest\",\n    value: function prepareRequest(request) {\n      if (!request.isSafe) {\n        var token = getCookieValue(getMetaContent(\"csrf-param\")) || getMetaContent(\"csrf-token\");\n        if (token) {\n          request.headers[\"X-CSRF-Token\"] = token;\n        }\n      }\n      if (this.requestAcceptsTurboStreamResponse(request)) {\n        request.acceptResponseType(StreamMessage.contentType);\n      }\n    }\n  }, {\n    key: \"requestStarted\",\n    value: function requestStarted(_request) {\n      this.state = FormSubmissionState.waiting;\n      if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);\n      this.setSubmitsWith();\n      markAsBusy(this.formElement);\n      dispatch(\"turbo:submit-start\", {\n        target: this.formElement,\n        detail: {\n          formSubmission: this\n        }\n      });\n      this.delegate.formSubmissionStarted(this);\n    }\n  }, {\n    key: \"requestPreventedHandlingResponse\",\n    value: function requestPreventedHandlingResponse(request, response) {\n      prefetchCache.clear();\n      this.result = {\n        success: response.succeeded,\n        fetchResponse: response\n      };\n    }\n  }, {\n    key: \"requestSucceededWithResponse\",\n    value: function requestSucceededWithResponse(request, response) {\n      if (response.clientError || response.serverError) {\n        this.delegate.formSubmissionFailedWithResponse(this, response);\n        return;\n      }\n      prefetchCache.clear();\n      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {\n        var error = new Error(\"Form responses must redirect to another location\");\n        this.delegate.formSubmissionErrored(this, error);\n      } else {\n        this.state = FormSubmissionState.receiving;\n        this.result = {\n          success: true,\n          fetchResponse: response\n        };\n        this.delegate.formSubmissionSucceededWithResponse(this, response);\n      }\n    }\n  }, {\n    key: \"requestFailedWithResponse\",\n    value: function requestFailedWithResponse(request, response) {\n      this.result = {\n        success: false,\n        fetchResponse: response\n      };\n      this.delegate.formSubmissionFailedWithResponse(this, response);\n    }\n  }, {\n    key: \"requestErrored\",\n    value: function requestErrored(request, error) {\n      this.result = {\n        success: false,\n        error: error\n      };\n      this.delegate.formSubmissionErrored(this, error);\n    }\n  }, {\n    key: \"requestFinished\",\n    value: function requestFinished(_request) {\n      this.state = FormSubmissionState.stopped;\n      if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);\n      this.resetSubmitterText();\n      clearBusyState(this.formElement);\n      dispatch(\"turbo:submit-end\", {\n        target: this.formElement,\n        detail: _objectSpread({\n          formSubmission: this\n        }, this.result)\n      });\n      this.delegate.formSubmissionFinished(this);\n    }\n\n    // Private\n  }, {\n    key: \"setSubmitsWith\",\n    value: function setSubmitsWith() {\n      if (!this.submitter || !this.submitsWith) return;\n      if (this.submitter.matches(\"button\")) {\n        this.originalSubmitText = this.submitter.innerHTML;\n        this.submitter.innerHTML = this.submitsWith;\n      } else if (this.submitter.matches(\"input\")) {\n        var input = this.submitter;\n        this.originalSubmitText = input.value;\n        input.value = this.submitsWith;\n      }\n    }\n  }, {\n    key: \"resetSubmitterText\",\n    value: function resetSubmitterText() {\n      if (!this.submitter || !this.originalSubmitText) return;\n      if (this.submitter.matches(\"button\")) {\n        this.submitter.innerHTML = this.originalSubmitText;\n      } else if (this.submitter.matches(\"input\")) {\n        var input = this.submitter;\n        input.value = this.originalSubmitText;\n      }\n    }\n  }, {\n    key: \"requestMustRedirect\",\n    value: function requestMustRedirect(request) {\n      return !request.isSafe && this.mustRedirect;\n    }\n  }, {\n    key: \"requestAcceptsTurboStreamResponse\",\n    value: function requestAcceptsTurboStreamResponse(request) {\n      return !request.isSafe || hasAttribute(\"data-turbo-stream\", this.submitter, this.formElement);\n    }\n  }, {\n    key: \"submitsWith\",\n    get: function get() {\n      var _this$submitter;\n      return (_this$submitter = this.submitter) === null || _this$submitter === void 0 ? void 0 : _this$submitter.getAttribute(\"data-turbo-submits-with\");\n    }\n  }], [{\n    key: \"confirmMethod\",\n    value: function confirmMethod(message) {\n      return Promise.resolve(confirm(message));\n    }\n  }]);\n}();\nfunction buildFormData(formElement, submitter) {\n  var formData = new FormData(formElement);\n  var name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"name\");\n  var value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"value\");\n  if (name) {\n    formData.append(name, value || \"\");\n  }\n  return formData;\n}\nfunction getCookieValue(cookieName) {\n  if (cookieName != null) {\n    var cookies = document.cookie ? document.cookie.split(\"; \") : [];\n    var cookie = cookies.find(function (cookie) {\n      return cookie.startsWith(cookieName);\n    });\n    if (cookie) {\n      var value = cookie.split(\"=\").slice(1).join(\"=\");\n      return value ? decodeURIComponent(value) : undefined;\n    }\n  }\n}\nfunction responseSucceededWithoutRedirect(response) {\n  return response.statusCode == 200 && !response.redirected;\n}\nfunction getFormAction(formElement, submitter) {\n  var formElementAction = typeof formElement.action === \"string\" ? formElement.action : null;\n  if (submitter !== null && submitter !== void 0 && submitter.hasAttribute(\"formaction\")) {\n    return submitter.getAttribute(\"formaction\") || \"\";\n  } else {\n    return formElement.getAttribute(\"action\") || formElementAction || \"\";\n  }\n}\nfunction getAction(formAction, fetchMethod) {\n  var action = expandURL(formAction);\n  if (isSafe(fetchMethod)) {\n    action.search = \"\";\n  }\n  return action;\n}\nfunction getMethod(formElement, submitter) {\n  var method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"formmethod\")) || formElement.getAttribute(\"method\") || \"\";\n  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;\n}\nfunction getEnctype(formElement, submitter) {\n  return fetchEnctypeFromString((submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"formenctype\")) || formElement.enctype);\n}\nvar Snapshot = /*#__PURE__*/function () {\n  function Snapshot(element) {\n    _classCallCheck(this, Snapshot);\n    this.element = element;\n  }\n  return _createClass(Snapshot, [{\n    key: \"activeElement\",\n    get: function get() {\n      return this.element.ownerDocument.activeElement;\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return _toConsumableArray(this.element.children);\n    }\n  }, {\n    key: \"hasAnchor\",\n    value: function hasAnchor(anchor) {\n      return this.getElementForAnchor(anchor) != null;\n    }\n  }, {\n    key: \"getElementForAnchor\",\n    value: function getElementForAnchor(anchor) {\n      return anchor ? this.element.querySelector(\"[id='\".concat(anchor, \"'], a[name='\").concat(anchor, \"']\")) : null;\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.element.isConnected;\n    }\n  }, {\n    key: \"firstAutofocusableElement\",\n    get: function get() {\n      return queryAutofocusableElement(this.element);\n    }\n  }, {\n    key: \"permanentElements\",\n    get: function get() {\n      return queryPermanentElementsAll(this.element);\n    }\n  }, {\n    key: \"getPermanentElementById\",\n    value: function getPermanentElementById(id) {\n      return _getPermanentElementById(this.element, id);\n    }\n  }, {\n    key: \"getPermanentElementMapForSnapshot\",\n    value: function getPermanentElementMapForSnapshot(snapshot) {\n      var permanentElementMap = {};\n      var _iterator7 = _createForOfIteratorHelper(this.permanentElements),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var currentPermanentElement = _step7.value;\n          var _id = currentPermanentElement.id;\n          var newPermanentElement = snapshot.getPermanentElementById(_id);\n          if (newPermanentElement) {\n            permanentElementMap[_id] = [currentPermanentElement, newPermanentElement];\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return permanentElementMap;\n    }\n  }]);\n}();\nfunction _getPermanentElementById(node, id) {\n  return node.querySelector(\"#\".concat(id, \"[data-turbo-permanent]\"));\n}\nfunction queryPermanentElementsAll(node) {\n  return node.querySelectorAll(\"[id][data-turbo-permanent]\");\n}\nvar FormSubmitObserver = /*#__PURE__*/function () {\n  function FormSubmitObserver(delegate, eventTarget) {\n    var _this6 = this;\n    _classCallCheck(this, FormSubmitObserver);\n    this.started = false;\n    this.submitCaptured = function () {\n      _this6.eventTarget.removeEventListener(\"submit\", _this6.submitBubbled, false);\n      _this6.eventTarget.addEventListener(\"submit\", _this6.submitBubbled, false);\n    };\n    this.submitBubbled = function (event) {\n      if (!event.defaultPrevented) {\n        var form = event.target instanceof HTMLFormElement ? event.target : undefined;\n        var _submitter2 = event.submitter || undefined;\n        if (form && submissionDoesNotDismissDialog(form, _submitter2) && submissionDoesNotTargetIFrame(form, _submitter2) && _this6.delegate.willSubmitForm(form, _submitter2)) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          _this6.delegate.formSubmitted(form, _submitter2);\n        }\n      }\n    };\n    this.delegate = delegate;\n    this.eventTarget = eventTarget;\n  }\n  return _createClass(FormSubmitObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        this.eventTarget.addEventListener(\"submit\", this.submitCaptured, true);\n        this.started = true;\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.eventTarget.removeEventListener(\"submit\", this.submitCaptured, true);\n        this.started = false;\n      }\n    }\n  }]);\n}();\nfunction submissionDoesNotDismissDialog(form, submitter) {\n  var method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"formmethod\")) || form.getAttribute(\"method\");\n  return method != \"dialog\";\n}\nfunction submissionDoesNotTargetIFrame(form, submitter) {\n  var target = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"formtarget\")) || form.getAttribute(\"target\");\n  return doesNotTargetIFrame(target);\n}\nvar _resolveRenderPromise = /*#__PURE__*/_classPrivateFieldLooseKey(\"resolveRenderPromise\");\nvar _resolveInterceptionPromise = /*#__PURE__*/_classPrivateFieldLooseKey(\"resolveInterceptionPromise\");\nvar View = /*#__PURE__*/function () {\n  function View(delegate, element) {\n    _classCallCheck(this, View);\n    Object.defineProperty(this, _resolveRenderPromise, {\n      writable: true,\n      value: function value(_value) {}\n    });\n    Object.defineProperty(this, _resolveInterceptionPromise, {\n      writable: true,\n      value: function value(_value) {}\n    });\n    this.delegate = delegate;\n    this.element = element;\n  }\n\n  // Scrolling\n  return _createClass(View, [{\n    key: \"scrollToAnchor\",\n    value: function scrollToAnchor(anchor) {\n      var element = this.snapshot.getElementForAnchor(anchor);\n      if (element) {\n        this.scrollToElement(element);\n        this.focusElement(element);\n      } else {\n        this.scrollToPosition({\n          x: 0,\n          y: 0\n        });\n      }\n    }\n  }, {\n    key: \"scrollToAnchorFromLocation\",\n    value: function scrollToAnchorFromLocation(location) {\n      this.scrollToAnchor(getAnchor(location));\n    }\n  }, {\n    key: \"scrollToElement\",\n    value: function scrollToElement(element) {\n      element.scrollIntoView();\n    }\n  }, {\n    key: \"focusElement\",\n    value: function focusElement(element) {\n      if (element instanceof HTMLElement) {\n        if (element.hasAttribute(\"tabindex\")) {\n          element.focus();\n        } else {\n          element.setAttribute(\"tabindex\", \"-1\");\n          element.focus();\n          element.removeAttribute(\"tabindex\");\n        }\n      }\n    }\n  }, {\n    key: \"scrollToPosition\",\n    value: function scrollToPosition(_ref5) {\n      var x = _ref5.x,\n        y = _ref5.y;\n      this.scrollRoot.scrollTo(x, y);\n    }\n  }, {\n    key: \"scrollToTop\",\n    value: function scrollToTop() {\n      this.scrollToPosition({\n        x: 0,\n        y: 0\n      });\n    }\n  }, {\n    key: \"scrollRoot\",\n    get: function get() {\n      return window;\n    }\n\n    // Rendering\n  }, {\n    key: \"render\",\n    value: function () {\n      var _render = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(renderer) {\n        var _this7 = this;\n        var isPreview, shouldRender, willRender, snapshot, shouldInvalidate, renderInterception, options, immediateRender;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              isPreview = renderer.isPreview, shouldRender = renderer.shouldRender, willRender = renderer.willRender, snapshot = renderer.newSnapshot; // A workaround to ignore tracked element mismatch reloads when performing\n              // a promoted Visit from a frame navigation\n              shouldInvalidate = willRender;\n              if (!shouldRender) {\n                _context4.next = 26;\n                break;\n              }\n              _context4.prev = 3;\n              this.renderPromise = new Promise(function (resolve) {\n                return _classPrivateFieldLooseBase(_this7, _resolveRenderPromise)[_resolveRenderPromise] = resolve;\n              });\n              this.renderer = renderer;\n              _context4.next = 8;\n              return this.prepareToRenderSnapshot(renderer);\n            case 8:\n              renderInterception = new Promise(function (resolve) {\n                return _classPrivateFieldLooseBase(_this7, _resolveInterceptionPromise)[_resolveInterceptionPromise] = resolve;\n              });\n              options = {\n                resume: _classPrivateFieldLooseBase(this, _resolveInterceptionPromise)[_resolveInterceptionPromise],\n                render: this.renderer.renderElement,\n                renderMethod: this.renderer.renderMethod\n              };\n              immediateRender = this.delegate.allowsImmediateRender(snapshot, options);\n              if (immediateRender) {\n                _context4.next = 14;\n                break;\n              }\n              _context4.next = 14;\n              return renderInterception;\n            case 14:\n              _context4.next = 16;\n              return this.renderSnapshot(renderer);\n            case 16:\n              this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);\n              this.delegate.preloadOnLoadLinksForView(this.element);\n              this.finishRenderingSnapshot(renderer);\n            case 19:\n              _context4.prev = 19;\n              delete this.renderer;\n              _classPrivateFieldLooseBase(this, _resolveRenderPromise)[_resolveRenderPromise](undefined);\n              delete this.renderPromise;\n              return _context4.finish(19);\n            case 24:\n              _context4.next = 27;\n              break;\n            case 26:\n              if (shouldInvalidate) {\n                this.invalidate(renderer.reloadReason);\n              }\n            case 27:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[3,, 19, 24]]);\n      }));\n      function render(_x4) {\n        return _render.apply(this, arguments);\n      }\n      return render;\n    }()\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(reason) {\n      this.delegate.viewInvalidated(reason);\n    }\n  }, {\n    key: \"prepareToRenderSnapshot\",\n    value: function () {\n      var _prepareToRenderSnapshot = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(renderer) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              this.markAsPreview(renderer.isPreview);\n              _context5.next = 3;\n              return renderer.prepareToRender();\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function prepareToRenderSnapshot(_x5) {\n        return _prepareToRenderSnapshot.apply(this, arguments);\n      }\n      return prepareToRenderSnapshot;\n    }()\n  }, {\n    key: \"markAsPreview\",\n    value: function markAsPreview(isPreview) {\n      if (isPreview) {\n        this.element.setAttribute(\"data-turbo-preview\", \"\");\n      } else {\n        this.element.removeAttribute(\"data-turbo-preview\");\n      }\n    }\n  }, {\n    key: \"markVisitDirection\",\n    value: function markVisitDirection(direction) {\n      this.element.setAttribute(\"data-turbo-visit-direction\", direction);\n    }\n  }, {\n    key: \"unmarkVisitDirection\",\n    value: function unmarkVisitDirection() {\n      this.element.removeAttribute(\"data-turbo-visit-direction\");\n    }\n  }, {\n    key: \"renderSnapshot\",\n    value: function () {\n      var _renderSnapshot = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(renderer) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return renderer.render();\n            case 2:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n      function renderSnapshot(_x6) {\n        return _renderSnapshot.apply(this, arguments);\n      }\n      return renderSnapshot;\n    }()\n  }, {\n    key: \"finishRenderingSnapshot\",\n    value: function finishRenderingSnapshot(renderer) {\n      renderer.finishRendering();\n    }\n  }]);\n}();\nvar FrameView = /*#__PURE__*/function (_View2) {\n  function FrameView() {\n    _classCallCheck(this, FrameView);\n    return _callSuper(this, FrameView, arguments);\n  }\n  _inherits(FrameView, _View2);\n  return _createClass(FrameView, [{\n    key: \"missing\",\n    value: function missing() {\n      this.element.innerHTML = \"<strong class=\\\"turbo-frame-error\\\">Content missing</strong>\";\n    }\n  }, {\n    key: \"snapshot\",\n    get: function get() {\n      return new Snapshot(this.element);\n    }\n  }]);\n}(View);\nvar LinkInterceptor = /*#__PURE__*/function () {\n  function LinkInterceptor(delegate, element) {\n    var _this8 = this;\n    _classCallCheck(this, LinkInterceptor);\n    this.clickBubbled = function (event) {\n      if (_this8.clickEventIsSignificant(event)) {\n        _this8.clickEvent = event;\n      } else {\n        delete _this8.clickEvent;\n      }\n    };\n    this.linkClicked = function (event) {\n      if (_this8.clickEvent && _this8.clickEventIsSignificant(event)) {\n        if (_this8.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {\n          _this8.clickEvent.preventDefault();\n          event.preventDefault();\n          _this8.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);\n        }\n      }\n      delete _this8.clickEvent;\n    };\n    this.willVisit = function (_event) {\n      delete _this8.clickEvent;\n    };\n    this.delegate = delegate;\n    this.element = element;\n  }\n  return _createClass(LinkInterceptor, [{\n    key: \"start\",\n    value: function start() {\n      this.element.addEventListener(\"click\", this.clickBubbled);\n      document.addEventListener(\"turbo:click\", this.linkClicked);\n      document.addEventListener(\"turbo:before-visit\", this.willVisit);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.element.removeEventListener(\"click\", this.clickBubbled);\n      document.removeEventListener(\"turbo:click\", this.linkClicked);\n      document.removeEventListener(\"turbo:before-visit\", this.willVisit);\n    }\n  }, {\n    key: \"clickEventIsSignificant\",\n    value: function clickEventIsSignificant(event) {\n      var _event$target;\n      var target = event.composed ? (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.parentElement : event.target;\n      var element = findLinkFromClickTarget(target) || target;\n      return element instanceof Element && element.closest(\"turbo-frame, html\") == this.element;\n    }\n  }]);\n}();\nvar LinkClickObserver = /*#__PURE__*/function () {\n  function LinkClickObserver(delegate, eventTarget) {\n    var _this9 = this;\n    _classCallCheck(this, LinkClickObserver);\n    this.started = false;\n    this.clickCaptured = function () {\n      _this9.eventTarget.removeEventListener(\"click\", _this9.clickBubbled, false);\n      _this9.eventTarget.addEventListener(\"click\", _this9.clickBubbled, false);\n    };\n    this.clickBubbled = function (event) {\n      if (event instanceof MouseEvent && _this9.clickEventIsSignificant(event)) {\n        var target = event.composedPath && event.composedPath()[0] || event.target;\n        var link = findLinkFromClickTarget(target);\n        if (link && doesNotTargetIFrame(link.target)) {\n          var _location2 = getLocationForLink(link);\n          if (_this9.delegate.willFollowLinkToLocation(link, _location2, event)) {\n            event.preventDefault();\n            _this9.delegate.followedLinkToLocation(link, _location2);\n          }\n        }\n      }\n    };\n    this.delegate = delegate;\n    this.eventTarget = eventTarget;\n  }\n  return _createClass(LinkClickObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        this.eventTarget.addEventListener(\"click\", this.clickCaptured, true);\n        this.started = true;\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.eventTarget.removeEventListener(\"click\", this.clickCaptured, true);\n        this.started = false;\n      }\n    }\n  }, {\n    key: \"clickEventIsSignificant\",\n    value: function clickEventIsSignificant(event) {\n      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);\n    }\n  }]);\n}();\nvar FormLinkClickObserver = /*#__PURE__*/function () {\n  function FormLinkClickObserver(delegate, element) {\n    _classCallCheck(this, FormLinkClickObserver);\n    this.delegate = delegate;\n    this.linkInterceptor = new LinkClickObserver(this, element);\n  }\n  return _createClass(FormLinkClickObserver, [{\n    key: \"start\",\n    value: function start() {\n      this.linkInterceptor.start();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.linkInterceptor.stop();\n    }\n\n    // Link hover observer delegate\n  }, {\n    key: \"canPrefetchRequestToLocation\",\n    value: function canPrefetchRequestToLocation(link, location) {\n      return false;\n    }\n  }, {\n    key: \"prefetchAndCacheRequestToLocation\",\n    value: function prefetchAndCacheRequestToLocation(link, location) {\n      return;\n    }\n\n    // Link click observer delegate\n  }, {\n    key: \"willFollowLinkToLocation\",\n    value: function willFollowLinkToLocation(link, location, originalEvent) {\n      return this.delegate.willSubmitFormLinkToLocation(link, location, originalEvent) && (link.hasAttribute(\"data-turbo-method\") || link.hasAttribute(\"data-turbo-stream\"));\n    }\n  }, {\n    key: \"followedLinkToLocation\",\n    value: function followedLinkToLocation(link, location) {\n      var form = document.createElement(\"form\");\n      var type = \"hidden\";\n      var _iterator8 = _createForOfIteratorHelper(location.searchParams),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _ref6 = _step8.value;\n          var _ref7 = _slicedToArray(_ref6, 2);\n          var name = _ref7[0];\n          var value = _ref7[1];\n          form.append(Object.assign(document.createElement(\"input\"), {\n            type: type,\n            name: name,\n            value: value\n          }));\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      var action = Object.assign(location, {\n        search: \"\"\n      });\n      form.setAttribute(\"data-turbo\", \"true\");\n      form.setAttribute(\"action\", action.href);\n      form.setAttribute(\"hidden\", \"\");\n      var method = link.getAttribute(\"data-turbo-method\");\n      if (method) form.setAttribute(\"method\", method);\n      var turboFrame = link.getAttribute(\"data-turbo-frame\");\n      if (turboFrame) form.setAttribute(\"data-turbo-frame\", turboFrame);\n      var turboAction = getVisitAction(link);\n      if (turboAction) form.setAttribute(\"data-turbo-action\", turboAction);\n      var turboConfirm = link.getAttribute(\"data-turbo-confirm\");\n      if (turboConfirm) form.setAttribute(\"data-turbo-confirm\", turboConfirm);\n      var turboStream = link.hasAttribute(\"data-turbo-stream\");\n      if (turboStream) form.setAttribute(\"data-turbo-stream\", \"\");\n      this.delegate.submittedFormLinkToLocation(link, location, form);\n      document.body.appendChild(form);\n      form.addEventListener(\"turbo:submit-end\", function () {\n        return form.remove();\n      }, {\n        once: true\n      });\n      requestAnimationFrame(function () {\n        return form.requestSubmit();\n      });\n    }\n  }]);\n}();\nvar Bardo = /*#__PURE__*/function () {\n  function Bardo(delegate, permanentElementMap) {\n    _classCallCheck(this, Bardo);\n    this.delegate = delegate;\n    this.permanentElementMap = permanentElementMap;\n  }\n  return _createClass(Bardo, [{\n    key: \"enter\",\n    value: function enter() {\n      for (var _id2 in this.permanentElementMap) {\n        var _this$permanentElemen = _slicedToArray(this.permanentElementMap[_id2], 2),\n          currentPermanentElement = _this$permanentElemen[0],\n          newPermanentElement = _this$permanentElemen[1];\n        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);\n        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);\n      }\n    }\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      for (var _id3 in this.permanentElementMap) {\n        var _this$permanentElemen2 = _slicedToArray(this.permanentElementMap[_id3], 1),\n          currentPermanentElement = _this$permanentElemen2[0];\n        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);\n        this.replacePlaceholderWithPermanentElement(currentPermanentElement);\n        this.delegate.leavingBardo(currentPermanentElement);\n      }\n    }\n  }, {\n    key: \"replaceNewPermanentElementWithPlaceholder\",\n    value: function replaceNewPermanentElementWithPlaceholder(permanentElement) {\n      var placeholder = createPlaceholderForPermanentElement(permanentElement);\n      permanentElement.replaceWith(placeholder);\n    }\n  }, {\n    key: \"replaceCurrentPermanentElementWithClone\",\n    value: function replaceCurrentPermanentElementWithClone(permanentElement) {\n      var clone = permanentElement.cloneNode(true);\n      permanentElement.replaceWith(clone);\n    }\n  }, {\n    key: \"replacePlaceholderWithPermanentElement\",\n    value: function replacePlaceholderWithPermanentElement(permanentElement) {\n      var placeholder = this.getPlaceholderById(permanentElement.id);\n      placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);\n    }\n  }, {\n    key: \"getPlaceholderById\",\n    value: function getPlaceholderById(id) {\n      return this.placeholders.find(function (element) {\n        return element.content == id;\n      });\n    }\n  }, {\n    key: \"placeholders\",\n    get: function get() {\n      return _toConsumableArray(document.querySelectorAll(\"meta[name=turbo-permanent-placeholder][content]\"));\n    }\n  }], [{\n    key: \"preservingPermanentElements\",\n    value: function () {\n      var _preservingPermanentElements = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(delegate, permanentElementMap, callback) {\n        var bardo;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              bardo = new this(delegate, permanentElementMap);\n              bardo.enter();\n              _context7.next = 4;\n              return callback();\n            case 4:\n              bardo.leave();\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function preservingPermanentElements(_x7, _x8, _x9) {\n        return _preservingPermanentElements.apply(this, arguments);\n      }\n      return preservingPermanentElements;\n    }()\n  }]);\n}();\nfunction createPlaceholderForPermanentElement(permanentElement) {\n  var element = document.createElement(\"meta\");\n  element.setAttribute(\"name\", \"turbo-permanent-placeholder\");\n  element.setAttribute(\"content\", permanentElement.id);\n  return element;\n}\nvar _activeElement = /*#__PURE__*/_classPrivateFieldLooseKey(\"activeElement\");\nvar Renderer = /*#__PURE__*/function () {\n  function Renderer(currentSnapshot, newSnapshot, isPreview) {\n    var _this10 = this;\n    var willRender = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    _classCallCheck(this, Renderer);\n    Object.defineProperty(this, _activeElement, {\n      writable: true,\n      value: null\n    });\n    this.currentSnapshot = currentSnapshot;\n    this.newSnapshot = newSnapshot;\n    this.isPreview = isPreview;\n    this.willRender = willRender;\n    this.renderElement = this.constructor.renderElement;\n    this.promise = new Promise(function (resolve, reject) {\n      return _this10.resolvingFunctions = {\n        resolve: resolve,\n        reject: reject\n      };\n    });\n  }\n  return _createClass(Renderer, [{\n    key: \"shouldRender\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"shouldAutofocus\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"reloadReason\",\n    get: function get() {\n      return;\n    }\n  }, {\n    key: \"prepareToRender\",\n    value: function prepareToRender() {\n      return;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      // Abstract method\n    }\n  }, {\n    key: \"finishRendering\",\n    value: function finishRendering() {\n      if (this.resolvingFunctions) {\n        this.resolvingFunctions.resolve();\n        delete this.resolvingFunctions;\n      }\n    }\n  }, {\n    key: \"preservingPermanentElements\",\n    value: function () {\n      var _preservingPermanentElements2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(callback) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);\n            case 2:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function preservingPermanentElements(_x10) {\n        return _preservingPermanentElements2.apply(this, arguments);\n      }\n      return preservingPermanentElements;\n    }()\n  }, {\n    key: \"focusFirstAutofocusableElement\",\n    value: function focusFirstAutofocusableElement() {\n      if (this.shouldAutofocus) {\n        var element = this.connectedSnapshot.firstAutofocusableElement;\n        if (element) {\n          element.focus();\n        }\n      }\n    }\n\n    // Bardo delegate\n  }, {\n    key: \"enteringBardo\",\n    value: function enteringBardo(currentPermanentElement) {\n      if (_classPrivateFieldLooseBase(this, _activeElement)[_activeElement]) return;\n      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {\n        _classPrivateFieldLooseBase(this, _activeElement)[_activeElement] = this.currentSnapshot.activeElement;\n      }\n    }\n  }, {\n    key: \"leavingBardo\",\n    value: function leavingBardo(currentPermanentElement) {\n      if (currentPermanentElement.contains(_classPrivateFieldLooseBase(this, _activeElement)[_activeElement]) && _classPrivateFieldLooseBase(this, _activeElement)[_activeElement] instanceof HTMLElement) {\n        _classPrivateFieldLooseBase(this, _activeElement)[_activeElement].focus();\n        _classPrivateFieldLooseBase(this, _activeElement)[_activeElement] = null;\n      }\n    }\n  }, {\n    key: \"connectedSnapshot\",\n    get: function get() {\n      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;\n    }\n  }, {\n    key: \"currentElement\",\n    get: function get() {\n      return this.currentSnapshot.element;\n    }\n  }, {\n    key: \"newElement\",\n    get: function get() {\n      return this.newSnapshot.element;\n    }\n  }, {\n    key: \"permanentElementMap\",\n    get: function get() {\n      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);\n    }\n  }, {\n    key: \"renderMethod\",\n    get: function get() {\n      return \"replace\";\n    }\n  }], [{\n    key: \"renderElement\",\n    value: function renderElement(currentElement, newElement) {\n      // Abstract method\n    }\n  }]);\n}();\nvar FrameRenderer = /*#__PURE__*/function (_Renderer2) {\n  function FrameRenderer(delegate, currentSnapshot, newSnapshot, renderElement, isPreview) {\n    var _this11;\n    var willRender = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    _classCallCheck(this, FrameRenderer);\n    _this11 = _callSuper(this, FrameRenderer, [currentSnapshot, newSnapshot, renderElement, isPreview, willRender]);\n    _this11.delegate = delegate;\n    return _this11;\n  }\n  _inherits(FrameRenderer, _Renderer2);\n  return _createClass(FrameRenderer, [{\n    key: \"shouldRender\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"render\",\n    value: function () {\n      var _render2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _this12 = this;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return nextRepaint();\n            case 2:\n              this.preservingPermanentElements(function () {\n                _this12.loadFrameElement();\n              });\n              this.scrollFrameIntoView();\n              _context9.next = 6;\n              return nextRepaint();\n            case 6:\n              this.focusFirstAutofocusableElement();\n              _context9.next = 9;\n              return nextRepaint();\n            case 9:\n              this.activateScriptElements();\n            case 10:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function render() {\n        return _render2.apply(this, arguments);\n      }\n      return render;\n    }()\n  }, {\n    key: \"loadFrameElement\",\n    value: function loadFrameElement() {\n      this.delegate.willRenderFrame(this.currentElement, this.newElement);\n      this.renderElement(this.currentElement, this.newElement);\n    }\n  }, {\n    key: \"scrollFrameIntoView\",\n    value: function scrollFrameIntoView() {\n      if (this.currentElement.autoscroll || this.newElement.autoscroll) {\n        var element = this.currentElement.firstElementChild;\n        var block = readScrollLogicalPosition(this.currentElement.getAttribute(\"data-autoscroll-block\"), \"end\");\n        var behavior = readScrollBehavior(this.currentElement.getAttribute(\"data-autoscroll-behavior\"), \"auto\");\n        if (element) {\n          element.scrollIntoView({\n            block: block,\n            behavior: behavior\n          });\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"activateScriptElements\",\n    value: function activateScriptElements() {\n      var _iterator9 = _createForOfIteratorHelper(this.newScriptElements),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var inertScriptElement = _step9.value;\n          var activatedScriptElement = activateScriptElement(inertScriptElement);\n          inertScriptElement.replaceWith(activatedScriptElement);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }, {\n    key: \"newScriptElements\",\n    get: function get() {\n      return this.currentElement.querySelectorAll(\"script\");\n    }\n  }], [{\n    key: \"renderElement\",\n    value: function renderElement(currentElement, newElement) {\n      var _frameElement$ownerDo;\n      var destinationRange = document.createRange();\n      destinationRange.selectNodeContents(currentElement);\n      destinationRange.deleteContents();\n      var frameElement = newElement;\n      var sourceRange = (_frameElement$ownerDo = frameElement.ownerDocument) === null || _frameElement$ownerDo === void 0 ? void 0 : _frameElement$ownerDo.createRange();\n      if (sourceRange) {\n        sourceRange.selectNodeContents(frameElement);\n        currentElement.appendChild(sourceRange.extractContents());\n      }\n    }\n  }]);\n}(Renderer);\nfunction readScrollLogicalPosition(value, defaultValue) {\n  if (value == \"end\" || value == \"start\" || value == \"center\" || value == \"nearest\") {\n    return value;\n  } else {\n    return defaultValue;\n  }\n}\nfunction readScrollBehavior(value, defaultValue) {\n  if (value == \"auto\" || value == \"smooth\") {\n    return value;\n  } else {\n    return defaultValue;\n  }\n}\n\n// base IIFE to define idiomorph\nvar Idiomorph = function () {\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n  var EMPTY_SET = new Set();\n\n  // default configuration values, updatable by users now\n  var defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp\n    },\n    head: {\n      style: 'merge',\n      shouldPreserve: function shouldPreserve(elt) {\n        return elt.getAttribute(\"im-preserve\") === \"true\";\n      },\n      shouldReAppend: function shouldReAppend(elt) {\n        return elt.getAttribute(\"im-re-append\") === \"true\";\n      },\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp\n    }\n  };\n\n  //=============================================================================\n  // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n  //=============================================================================\n  function morph(oldNode, newContent) {\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (oldNode instanceof Document) {\n      oldNode = oldNode.documentElement;\n    }\n    if (typeof newContent === 'string') {\n      newContent = parseContent(newContent);\n    }\n    var normalizedContent = normalizeContent(newContent);\n    var ctx = createMorphContext(oldNode, normalizedContent, config);\n    return morphNormalizedContent(oldNode, normalizedContent, ctx);\n  }\n  function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n    if (ctx.head.block) {\n      var oldHead = oldNode.querySelector('head');\n      var newHead = normalizedNewContent.querySelector('head');\n      if (oldHead && newHead) {\n        var promises = handleHeadElement(newHead, oldHead, ctx);\n        // when head promises resolve, call morph again, ignoring the head tag\n        Promise.all(promises).then(function () {\n          morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true\n            }\n          }));\n        });\n        return;\n      }\n    }\n    if (ctx.morphStyle === \"innerHTML\") {\n      // innerHTML, so we are only updating the children\n      morphChildren(normalizedNewContent, oldNode, ctx);\n      return oldNode.children;\n    } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n      // otherwise find the best element match in the new content, morph that, and merge its siblings\n      // into either side of the best match\n      var bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n      // stash the siblings that will need to be inserted on either side of the best match\n      var previousSibling = bestMatch === null || bestMatch === void 0 ? void 0 : bestMatch.previousSibling;\n      var nextSibling = bestMatch === null || bestMatch === void 0 ? void 0 : bestMatch.nextSibling;\n\n      // morph it\n      var morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n      if (bestMatch) {\n        // if there was a best match, merge the siblings in too and return the\n        // whole bunch\n        return insertSiblings(previousSibling, morphedNode, nextSibling);\n      } else {\n        // otherwise nothing was added to the DOM\n        return [];\n      }\n    } else {\n      throw \"Do not understand how to morph style \" + ctx.morphStyle;\n    }\n  }\n\n  /**\n   * @param possibleActiveElement\n   * @param ctx\n   * @returns {boolean}\n   */\n  function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n    return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;\n  }\n\n  /**\n   * @param oldNode root node to merge content into\n   * @param newContent new content to merge\n   * @param ctx the merge context\n   * @returns {Element} the element that ended up in the DOM\n   */\n  function morphOldNodeTo(oldNode, newContent, ctx) {\n    if (ctx.ignoreActive && oldNode === document.activeElement) ;else if (newContent == null) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n      oldNode.remove();\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return null;\n    } else if (!isSoftMatch(oldNode, newContent)) {\n      if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n      if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n      oldNode.parentElement.replaceChild(newContent, oldNode);\n      ctx.callbacks.afterNodeAdded(newContent);\n      ctx.callbacks.afterNodeRemoved(oldNode);\n      return newContent;\n    } else {\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ;else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n        handleHeadElement(newContent, oldNode, ctx);\n      } else {\n        syncNodeFrom(newContent, oldNode, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          morphChildren(newContent, oldNode, ctx);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n  }\n\n  /**\n   * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n   * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n   * by using id sets, we are able to better match up with content deeper in the DOM.\n   *\n   * Basic algorithm is, for each node in the new content:\n   *\n   * - if we have reached the end of the old parent, append the new content\n   * - if the new content has an id set match with the current insertion point, morph\n   * - search for an id set match\n   * - if id set match found, morph\n   * - otherwise search for a \"soft\" match\n   * - if a soft match is found, morph\n   * - otherwise, prepend the new node before the current insertion point\n   *\n   * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n   * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n   *\n   * @param {Element} newParent the parent element of the new content\n   * @param {Element } oldParent the old content that we are merging the new content into\n   * @param ctx the merge context\n   */\n  function morphChildren(newParent, oldParent, ctx) {\n    var nextNewChild = newParent.firstChild;\n    var insertionPoint = oldParent.firstChild;\n    var newChild;\n\n    // run through all the new content\n    while (nextNewChild) {\n      newChild = nextNewChild;\n      nextNewChild = newChild.nextSibling;\n\n      // if we are at the end of the exiting parent's children, just append\n      if (insertionPoint == null) {\n        if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n        oldParent.appendChild(newChild);\n        ctx.callbacks.afterNodeAdded(newChild);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // if the current node has an id set match then morph\n      if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n        morphOldNodeTo(insertionPoint, newChild, ctx);\n        insertionPoint = insertionPoint.nextSibling;\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // otherwise search forward in the existing old children for an id set match\n      var idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n      // if we found a potential match, remove the nodes until that point and morph\n      if (idSetMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n        morphOldNodeTo(idSetMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // no id set match found, so scan forward for a soft match for the current node\n      var softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n      // if we found a soft match for the current node, morph\n      if (softMatch) {\n        insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n        morphOldNodeTo(softMatch, newChild, ctx);\n        removeIdsFromConsideration(ctx, newChild);\n        continue;\n      }\n\n      // abandon all hope of morphing, just insert the new child before the insertion point\n      // and move on\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n      oldParent.insertBefore(newChild, insertionPoint);\n      ctx.callbacks.afterNodeAdded(newChild);\n      removeIdsFromConsideration(ctx, newChild);\n    }\n\n    // remove any remaining old nodes that didn't match up with new content\n    while (insertionPoint !== null) {\n      var tempNode = insertionPoint;\n      insertionPoint = insertionPoint.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n  }\n\n  //=============================================================================\n  // Attribute Syncing Code\n  //=============================================================================\n\n  /**\n   * @param attr {String} the attribute to be mutated\n   * @param to {Element} the element that is going to be updated\n   * @param updateType {(\"update\"|\"remove\")}\n   * @param ctx the merge context\n   * @returns {boolean} true if the attribute should be ignored, false otherwise\n   */\n  function ignoreAttribute(attr, to, updateType, ctx) {\n    if (attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement) {\n      return true;\n    }\n    return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n  }\n\n  /**\n   * syncs a given node with another node, copying over all attributes and\n   * inner element state from the 'from' node to the 'to' node\n   *\n   * @param {Element} from the element to copy attributes & state from\n   * @param {Element} to the element to copy attributes & state to\n   * @param ctx the merge context\n   */\n  function syncNodeFrom(from, to, ctx) {\n    var type = from.nodeType;\n\n    // if is an element type, sync the attributes from the\n    // new node into the new node\n    if (type === 1 /* element type */) {\n      var fromAttributes = from.attributes;\n      var toAttributes = to.attributes;\n      var _iterator10 = _createForOfIteratorHelper(fromAttributes),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var fromAttribute = _step10.value;\n          if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n            continue;\n          }\n          if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n            to.setAttribute(fromAttribute.name, fromAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      for (var i = toAttributes.length - 1; 0 <= i; i--) {\n        var toAttribute = toAttributes[i];\n        if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n          continue;\n        }\n        if (!from.hasAttribute(toAttribute.name)) {\n          to.removeAttribute(toAttribute.name);\n        }\n      }\n    }\n\n    // sync text nodes\n    if (type === 8 /* comment */ || type === 3 /* text */) {\n      if (to.nodeValue !== from.nodeValue) {\n        to.nodeValue = from.nodeValue;\n      }\n    }\n    if (!ignoreValueOfActiveElement(to, ctx)) {\n      // sync input values\n      syncInputValue(from, to, ctx);\n    }\n  }\n\n  /**\n   * @param from {Element} element to sync the value from\n   * @param to {Element} element to sync the value to\n   * @param attributeName {String} the attribute name\n   * @param ctx the merge context\n   */\n  function syncBooleanAttribute(from, to, attributeName, ctx) {\n    if (from[attributeName] !== to[attributeName]) {\n      var ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n      if (!ignoreUpdate) {\n        to[attributeName] = from[attributeName];\n      }\n      if (from[attributeName]) {\n        if (!ignoreUpdate) {\n          to.setAttribute(attributeName, from[attributeName]);\n        }\n      } else {\n        if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n          to.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n\n  /**\n   * NB: many bothans died to bring us information:\n   *\n   *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n   *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n   *\n   * @param from {Element} the element to sync the input value from\n   * @param to {Element} the element to sync the input value to\n   * @param ctx the merge context\n   */\n  function syncInputValue(from, to, ctx) {\n    if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== 'file') {\n      var fromValue = from.value;\n      var toValue = to.value;\n\n      // sync boolean attributes\n      syncBooleanAttribute(from, to, 'checked', ctx);\n      syncBooleanAttribute(from, to, 'disabled', ctx);\n      if (!from.hasAttribute('value')) {\n        if (!ignoreAttribute('value', to, 'remove', ctx)) {\n          to.value = '';\n          to.removeAttribute('value');\n        }\n      } else if (fromValue !== toValue) {\n        if (!ignoreAttribute('value', to, 'update', ctx)) {\n          to.setAttribute('value', fromValue);\n          to.value = fromValue;\n        }\n      }\n    } else if (from instanceof HTMLOptionElement) {\n      syncBooleanAttribute(from, to, 'selected', ctx);\n    } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n      var _fromValue = from.value;\n      var _toValue = to.value;\n      if (ignoreAttribute('value', to, 'update', ctx)) {\n        return;\n      }\n      if (_fromValue !== _toValue) {\n        to.value = _fromValue;\n      }\n      if (to.firstChild && to.firstChild.nodeValue !== _fromValue) {\n        to.firstChild.nodeValue = _fromValue;\n      }\n    }\n  }\n\n  //=============================================================================\n  // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n  //=============================================================================\n  function handleHeadElement(newHeadTag, currentHead, ctx) {\n    var added = [];\n    var removed = [];\n    var preserved = [];\n    var nodesToAppend = [];\n    var headMergeStyle = ctx.head.style;\n\n    // put all new head elements into a Map, by their outerHTML\n    var srcToNewHeadNodes = new Map();\n    var _iterator11 = _createForOfIteratorHelper(newHeadTag.children),\n      _step11;\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var newHeadChild = _step11.value;\n        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n      }\n\n      // for each elt in the current head\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n    var _iterator12 = _createForOfIteratorHelper(currentHead.children),\n      _step12;\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var currentHeadElt = _step12.value;\n        // If the current head element is in the map\n        var inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n        var isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n        var isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n        if (inNewContent || isPreserved) {\n          if (isReAppended) {\n            // remove the current version and let the new version replace it and re-execute\n            removed.push(currentHeadElt);\n          } else {\n            // this element already exists and should not be re-appended, so remove it from\n            // the new content map, preserving it in the DOM\n            srcToNewHeadNodes[\"delete\"](currentHeadElt.outerHTML);\n            preserved.push(currentHeadElt);\n          }\n        } else {\n          if (headMergeStyle === \"append\") {\n            // we are appending and this existing element is not new content\n            // so if and only if it is marked for re-append do we do anything\n            if (isReAppended) {\n              removed.push(currentHeadElt);\n              nodesToAppend.push(currentHeadElt);\n            }\n          } else {\n            // if this is a merge, we remove this content since it is not in the new head\n            if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n              removed.push(currentHeadElt);\n            }\n          }\n        }\n      }\n\n      // Push the remaining new head elements in the Map into the\n      // nodes to append to the head tag\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n    nodesToAppend.push.apply(nodesToAppend, _toConsumableArray(srcToNewHeadNodes.values()));\n    var promises = [];\n    var _loop = function _loop() {\n      var newNode = _nodesToAppend[_i3];\n      var newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (newElt.href || newElt.src) {\n          var resolve = null;\n          var promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener('load', function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        currentHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    };\n    for (var _i3 = 0, _nodesToAppend = nodesToAppend; _i3 < _nodesToAppend.length; _i3++) {\n      _loop();\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (var _i4 = 0, _removed = removed; _i4 < _removed.length; _i4++) {\n      var removedElement = _removed[_i4];\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        currentHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n    ctx.head.afterHeadMorphed(currentHead, {\n      added: added,\n      kept: preserved,\n      removed: removed\n    });\n    return promises;\n  }\n  function noOp() {}\n\n  /*\n    Deep merges the config object and the Idiomoroph.defaults object to\n    produce a final configuration object\n   */\n  function mergeDefaults(config) {\n    var finalConfig = {};\n    // copy top level stuff into final config\n    Object.assign(finalConfig, defaults);\n    Object.assign(finalConfig, config);\n\n    // copy callbacks into final config (do this to deep merge the callbacks)\n    finalConfig.callbacks = {};\n    Object.assign(finalConfig.callbacks, defaults.callbacks);\n    Object.assign(finalConfig.callbacks, config.callbacks);\n\n    // copy head config into final config  (do this to deep merge the head)\n    finalConfig.head = {};\n    Object.assign(finalConfig.head, defaults.head);\n    Object.assign(finalConfig.head, config.head);\n    return finalConfig;\n  }\n  function createMorphContext(oldNode, newContent, config) {\n    config = mergeDefaults(config);\n    return {\n      target: oldNode,\n      newContent: newContent,\n      config: config,\n      morphStyle: config.morphStyle,\n      ignoreActive: config.ignoreActive,\n      ignoreActiveValue: config.ignoreActiveValue,\n      idMap: createIdMap(oldNode, newContent),\n      deadIds: new Set(),\n      callbacks: config.callbacks,\n      head: config.head\n    };\n  }\n  function isIdSetMatch(node1, node2, ctx) {\n    if (node1 == null || node2 == null) {\n      return false;\n    }\n    if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n      if (node1.id !== \"\" && node1.id === node2.id) {\n        return true;\n      } else {\n        return getIdIntersectionCount(ctx, node1, node2) > 0;\n      }\n    }\n    return false;\n  }\n  function isSoftMatch(node1, node2) {\n    if (node1 == null || node2 == null) {\n      return false;\n    }\n    return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;\n  }\n  function removeNodesBetween(startInclusive, endExclusive, ctx) {\n    while (startInclusive !== endExclusive) {\n      var tempNode = startInclusive;\n      startInclusive = startInclusive.nextSibling;\n      removeNode(tempNode, ctx);\n    }\n    removeIdsFromConsideration(ctx, endExclusive);\n    return endExclusive.nextSibling;\n  }\n\n  //=============================================================================\n  // Scans forward from the insertionPoint in the old parent looking for a potential id match\n  // for the newChild.  We stop if we find a potential id match for the new child OR\n  // if the number of potential id matches we are discarding is greater than the\n  // potential id matches for the new child\n  //=============================================================================\n  function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n    // max id matches we are willing to discard in our search\n    var newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n    var potentialMatch = null;\n\n    // only search forward if there is a possibility of an id match\n    if (newChildPotentialIdCount > 0) {\n      var _potentialMatch = insertionPoint;\n      // if there is a possibility of an id match, scan forward\n      // keep track of the potential id match count we are discarding (the\n      // newChildPotentialIdCount must be greater than this to make it likely\n      // worth it)\n      var otherMatchCount = 0;\n      while (_potentialMatch != null) {\n        // If we have an id match, return the current potential match\n        if (isIdSetMatch(newChild, _potentialMatch, ctx)) {\n          return _potentialMatch;\n        }\n\n        // computer the other potential matches of this new content\n        otherMatchCount += getIdIntersectionCount(ctx, _potentialMatch, newContent);\n        if (otherMatchCount > newChildPotentialIdCount) {\n          // if we have more potential id matches in _other_ content, we\n          // do not have a good candidate for an id match, so return null\n          return null;\n        }\n\n        // advanced to the next old content child\n        _potentialMatch = _potentialMatch.nextSibling;\n      }\n    }\n    return potentialMatch;\n  }\n\n  //=============================================================================\n  // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n  // for the newChild.  We stop if we find a potential soft match for the new child OR\n  // if we find a potential id match in the old parents children OR if we find two\n  // potential soft matches for the next two pieces of new content\n  //=============================================================================\n  function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n    var potentialSoftMatch = insertionPoint;\n    var nextSibling = newChild.nextSibling;\n    var siblingSoftMatchCount = 0;\n    while (potentialSoftMatch != null) {\n      if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n        // the current potential soft match has a potential id set match with the remaining new\n        // content so bail out of looking\n        return null;\n      }\n\n      // if we have a soft match with the current node, return it\n      if (isSoftMatch(newChild, potentialSoftMatch)) {\n        return potentialSoftMatch;\n      }\n      if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n        // the next new node has a soft match with this node, so\n        // increment the count of future soft matches\n        siblingSoftMatchCount++;\n        nextSibling = nextSibling.nextSibling;\n\n        // If there are two future soft matches, bail to allow the siblings to soft match\n        // so that we don't consume future soft matches for the sake of the current node\n        if (siblingSoftMatchCount >= 2) {\n          return null;\n        }\n      }\n\n      // advanced to the next old content child\n      potentialSoftMatch = potentialSoftMatch.nextSibling;\n    }\n    return potentialSoftMatch;\n  }\n  function parseContent(newContent) {\n    var parser = new DOMParser();\n\n    // remove svgs to avoid false-positive matches on head, etc.\n    var contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n    // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n    if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n      var content = parser.parseFromString(newContent, \"text/html\");\n      // if it is a full HTML document, return the document itself as the parent container\n      if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n        content.generatedByIdiomorph = true;\n        return content;\n      } else {\n        // otherwise return the html element as the parent container\n        var htmlElement = content.firstChild;\n        if (htmlElement) {\n          htmlElement.generatedByIdiomorph = true;\n          return htmlElement;\n        } else {\n          return null;\n        }\n      }\n    } else {\n      // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n      // deal with touchy tags like tr, tbody, etc.\n      var responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n      var _content = responseDoc.body.querySelector('template').content;\n      _content.generatedByIdiomorph = true;\n      return _content;\n    }\n  }\n  function normalizeContent(newContent) {\n    if (newContent == null) {\n      // noinspection UnnecessaryLocalVariableJS\n      var dummyParent = document.createElement('div');\n      return dummyParent;\n    } else if (newContent.generatedByIdiomorph) {\n      // the template tag created by idiomorph parsing can serve as a dummy parent\n      return newContent;\n    } else if (newContent instanceof Node) {\n      // a single node is added as a child to a dummy parent\n      var _dummyParent = document.createElement('div');\n      _dummyParent.append(newContent);\n      return _dummyParent;\n    } else {\n      // all nodes in the array or HTMLElement collection are consolidated under\n      // a single dummy parent element\n      var _dummyParent2 = document.createElement('div');\n      for (var _i5 = 0, _arr = _toConsumableArray(newContent); _i5 < _arr.length; _i5++) {\n        var elt = _arr[_i5];\n        _dummyParent2.append(elt);\n      }\n      return _dummyParent2;\n    }\n  }\n  function insertSiblings(previousSibling, morphedNode, nextSibling) {\n    var stack = [];\n    var added = [];\n    while (previousSibling != null) {\n      stack.push(previousSibling);\n      previousSibling = previousSibling.previousSibling;\n    }\n    while (stack.length > 0) {\n      var node = stack.pop();\n      added.push(node); // push added preceding siblings on in order and insert\n      morphedNode.parentElement.insertBefore(node, morphedNode);\n    }\n    added.push(morphedNode);\n    while (nextSibling != null) {\n      stack.push(nextSibling);\n      added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n      nextSibling = nextSibling.nextSibling;\n    }\n    while (stack.length > 0) {\n      morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n    }\n    return added;\n  }\n  function findBestNodeMatch(newContent, oldNode, ctx) {\n    var currentElement;\n    currentElement = newContent.firstChild;\n    var bestElement = currentElement;\n    var score = 0;\n    while (currentElement) {\n      var newScore = scoreElement(currentElement, oldNode, ctx);\n      if (newScore > score) {\n        bestElement = currentElement;\n        score = newScore;\n      }\n      currentElement = currentElement.nextSibling;\n    }\n    return bestElement;\n  }\n  function scoreElement(node1, node2, ctx) {\n    if (isSoftMatch(node1, node2)) {\n      return .5 + getIdIntersectionCount(ctx, node1, node2);\n    }\n    return 0;\n  }\n  function removeNode(tempNode, ctx) {\n    removeIdsFromConsideration(ctx, tempNode);\n    if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n    tempNode.remove();\n    ctx.callbacks.afterNodeRemoved(tempNode);\n  }\n\n  //=============================================================================\n  // ID Set Functions\n  //=============================================================================\n\n  function isIdInConsideration(ctx, id) {\n    return !ctx.deadIds.has(id);\n  }\n  function idIsWithinNode(ctx, id, targetNode) {\n    var idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n    return idSet.has(id);\n  }\n  function removeIdsFromConsideration(ctx, node) {\n    var idSet = ctx.idMap.get(node) || EMPTY_SET;\n    var _iterator13 = _createForOfIteratorHelper(idSet),\n      _step13;\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var _id4 = _step13.value;\n        ctx.deadIds.add(_id4);\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n  }\n  function getIdIntersectionCount(ctx, node1, node2) {\n    var sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n    var matchCount = 0;\n    var _iterator14 = _createForOfIteratorHelper(sourceSet),\n      _step14;\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var _id5 = _step14.value;\n        // a potential match is an id in the source and potentialIdsSet, but\n        // that has not already been merged into the DOM\n        if (isIdInConsideration(ctx, _id5) && idIsWithinNode(ctx, _id5, node2)) {\n          ++matchCount;\n        }\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n    return matchCount;\n  }\n\n  /**\n   * A bottom up algorithm that finds all elements with ids inside of the node\n   * argument and populates id sets for those nodes and all their parents, generating\n   * a set of ids contained within all nodes for the entire hierarchy in the DOM\n   *\n   * @param node {Element}\n   * @param {Map<Node, Set<String>>} idMap\n   */\n  function populateIdMapForNode(node, idMap) {\n    var nodeParent = node.parentElement;\n    // find all elements with an id property\n    var idElements = node.querySelectorAll('[id]');\n    var _iterator15 = _createForOfIteratorHelper(idElements),\n      _step15;\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var elt = _step15.value;\n        var current = elt;\n        // walk up the parent hierarchy of that element, adding the id\n        // of element to the parent's id set\n        while (current !== nodeParent && current != null) {\n          var idSet = idMap.get(current);\n          // if the id set doesn't exist, create it and insert it in the  map\n          if (idSet == null) {\n            idSet = new Set();\n            idMap.set(current, idSet);\n          }\n          idSet.add(elt.id);\n          current = current.parentElement;\n        }\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n  }\n\n  /**\n   * This function computes a map of nodes to all ids contained within that node (inclusive of the\n   * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n   * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n   * to contribute to a parent nodes matching.\n   *\n   * @param {Element} oldContent  the old content that will be morphed\n   * @param {Element} newContent  the new content to morph to\n   * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n   */\n  function createIdMap(oldContent, newContent) {\n    var idMap = new Map();\n    populateIdMapForNode(oldContent, idMap);\n    populateIdMapForNode(newContent, idMap);\n    return idMap;\n  }\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph: morph,\n    defaults: defaults\n  };\n}();\nfunction morphElements(currentElement, newElement) {\n  var _ref8 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var callbacks = _ref8.callbacks,\n    options = _objectWithoutProperties(_ref8, _excluded);\n  Idiomorph.morph(currentElement, newElement, _objectSpread(_objectSpread({}, options), {}, {\n    callbacks: new DefaultIdiomorphCallbacks(callbacks)\n  }));\n}\nfunction morphChildren(currentElement, newElement) {\n  morphElements(currentElement, newElement.children, {\n    morphStyle: \"innerHTML\"\n  });\n}\nvar _beforeNodeMorphed = /*#__PURE__*/_classPrivateFieldLooseKey(\"beforeNodeMorphed\");\nvar DefaultIdiomorphCallbacks = /*#__PURE__*/_createClass(function DefaultIdiomorphCallbacks() {\n  var _this13 = this;\n  var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    beforeNodeMorphed = _ref9.beforeNodeMorphed;\n  _classCallCheck(this, DefaultIdiomorphCallbacks);\n  Object.defineProperty(this, _beforeNodeMorphed, {\n    writable: true,\n    value: void 0\n  });\n  this.beforeNodeAdded = function (node) {\n    return !(node.id && node.hasAttribute(\"data-turbo-permanent\") && document.getElementById(node.id));\n  };\n  this.beforeNodeMorphed = function (currentElement, newElement) {\n    if (currentElement instanceof Element) {\n      if (!currentElement.hasAttribute(\"data-turbo-permanent\") && _classPrivateFieldLooseBase(_this13, _beforeNodeMorphed)[_beforeNodeMorphed](currentElement, newElement)) {\n        var event = dispatch(\"turbo:before-morph-element\", {\n          cancelable: true,\n          target: currentElement,\n          detail: {\n            currentElement: currentElement,\n            newElement: newElement\n          }\n        });\n        return !event.defaultPrevented;\n      } else {\n        return false;\n      }\n    }\n  };\n  this.beforeAttributeUpdated = function (attributeName, target, mutationType) {\n    var event = dispatch(\"turbo:before-morph-attribute\", {\n      cancelable: true,\n      target: target,\n      detail: {\n        attributeName: attributeName,\n        mutationType: mutationType\n      }\n    });\n    return !event.defaultPrevented;\n  };\n  this.beforeNodeRemoved = function (node) {\n    return _this13.beforeNodeMorphed(node);\n  };\n  this.afterNodeMorphed = function (currentElement, newElement) {\n    if (currentElement instanceof Element) {\n      dispatch(\"turbo:morph-element\", {\n        target: currentElement,\n        detail: {\n          currentElement: currentElement,\n          newElement: newElement\n        }\n      });\n    }\n  };\n  _classPrivateFieldLooseBase(this, _beforeNodeMorphed)[_beforeNodeMorphed] = beforeNodeMorphed || function () {\n    return true;\n  };\n});\nvar MorphingFrameRenderer = /*#__PURE__*/function (_FrameRenderer) {\n  function MorphingFrameRenderer() {\n    _classCallCheck(this, MorphingFrameRenderer);\n    return _callSuper(this, MorphingFrameRenderer, arguments);\n  }\n  _inherits(MorphingFrameRenderer, _FrameRenderer);\n  return _createClass(MorphingFrameRenderer, [{\n    key: \"preservingPermanentElements\",\n    value: function () {\n      var _preservingPermanentElements3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(callback) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return callback();\n            case 2:\n              return _context10.abrupt(\"return\", _context10.sent);\n            case 3:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10);\n      }));\n      function preservingPermanentElements(_x11) {\n        return _preservingPermanentElements3.apply(this, arguments);\n      }\n      return preservingPermanentElements;\n    }()\n  }], [{\n    key: \"renderElement\",\n    value: function renderElement(currentElement, newElement) {\n      dispatch(\"turbo:before-frame-morph\", {\n        target: currentElement,\n        detail: {\n          currentElement: currentElement,\n          newElement: newElement\n        }\n      });\n      morphChildren(currentElement, newElement);\n    }\n  }]);\n}(FrameRenderer);\nvar ProgressBar = /*#__PURE__*/function () {\n  function ProgressBar() {\n    var _this14 = this;\n    _classCallCheck(this, ProgressBar);\n    this.hiding = false;\n    this.value = 0;\n    this.visible = false;\n    this.trickle = function () {\n      _this14.setValue(_this14.value + Math.random() / 100);\n    };\n    this.stylesheetElement = this.createStylesheetElement();\n    this.progressElement = this.createProgressElement();\n    this.installStylesheetElement();\n    this.setValue(0);\n  }\n  return _createClass(ProgressBar, [{\n    key: \"show\",\n    value: function show() {\n      if (!this.visible) {\n        this.visible = true;\n        this.installProgressElement();\n        this.startTrickling();\n      }\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this15 = this;\n      if (this.visible && !this.hiding) {\n        this.hiding = true;\n        this.fadeProgressElement(function () {\n          _this15.uninstallProgressElement();\n          _this15.stopTrickling();\n          _this15.visible = false;\n          _this15.hiding = false;\n        });\n      }\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.value = value;\n      this.refresh();\n    }\n\n    // Private\n  }, {\n    key: \"installStylesheetElement\",\n    value: function installStylesheetElement() {\n      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);\n    }\n  }, {\n    key: \"installProgressElement\",\n    value: function installProgressElement() {\n      this.progressElement.style.width = \"0\";\n      this.progressElement.style.opacity = \"1\";\n      document.documentElement.insertBefore(this.progressElement, document.body);\n      this.refresh();\n    }\n  }, {\n    key: \"fadeProgressElement\",\n    value: function fadeProgressElement(callback) {\n      this.progressElement.style.opacity = \"0\";\n      setTimeout(callback, ProgressBar.animationDuration * 1.5);\n    }\n  }, {\n    key: \"uninstallProgressElement\",\n    value: function uninstallProgressElement() {\n      if (this.progressElement.parentNode) {\n        document.documentElement.removeChild(this.progressElement);\n      }\n    }\n  }, {\n    key: \"startTrickling\",\n    value: function startTrickling() {\n      if (!this.trickleInterval) {\n        this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);\n      }\n    }\n  }, {\n    key: \"stopTrickling\",\n    value: function stopTrickling() {\n      window.clearInterval(this.trickleInterval);\n      delete this.trickleInterval;\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this16 = this;\n      requestAnimationFrame(function () {\n        _this16.progressElement.style.width = \"\".concat(10 + _this16.value * 90, \"%\");\n      });\n    }\n  }, {\n    key: \"createStylesheetElement\",\n    value: function createStylesheetElement() {\n      var element = document.createElement(\"style\");\n      element.type = \"text/css\";\n      element.textContent = ProgressBar.defaultCSS;\n      var cspNonce = getCspNonce();\n      if (cspNonce) {\n        element.nonce = cspNonce;\n      }\n      return element;\n    }\n  }, {\n    key: \"createProgressElement\",\n    value: function createProgressElement() {\n      var element = document.createElement(\"div\");\n      element.className = \"turbo-progress-bar\";\n      return element;\n    }\n  }], [{\n    key: \"defaultCSS\",\n    get: /*ms*/\n\n    function get() {\n      return unindent(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      .turbo-progress-bar {\\n        position: fixed;\\n        display: block;\\n        top: 0;\\n        left: 0;\\n        height: 3px;\\n        background: #0076ff;\\n        z-index: 2147483647;\\n        transition:\\n          width \", \"ms ease-out,\\n          opacity \", \"ms \", \"ms ease-in;\\n        transform: translate3d(0, 0, 0);\\n      }\\n    \"])), ProgressBar.animationDuration, ProgressBar.animationDuration / 2, ProgressBar.animationDuration / 2);\n    }\n  }]);\n}();\nProgressBar.animationDuration = 300;\nvar HeadSnapshot = /*#__PURE__*/function (_Snapshot) {\n  function HeadSnapshot() {\n    var _this17;\n    _classCallCheck(this, HeadSnapshot);\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n    _this17 = _callSuper(this, HeadSnapshot, [].concat(args));\n    _this17.detailsByOuterHTML = _this17.children.filter(function (element) {\n      return !elementIsNoscript(element);\n    }).map(function (element) {\n      return elementWithoutNonce(element);\n    }).reduce(function (result, element) {\n      var outerHTML = element.outerHTML;\n      var details = outerHTML in result ? result[outerHTML] : {\n        type: elementType(element),\n        tracked: elementIsTracked(element),\n        elements: []\n      };\n      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, outerHTML, _objectSpread(_objectSpread({}, details), {}, {\n        elements: [].concat(_toConsumableArray(details.elements), [element])\n      })));\n    }, {});\n    return _this17;\n  }\n  _inherits(HeadSnapshot, _Snapshot);\n  return _createClass(HeadSnapshot, [{\n    key: \"trackedElementSignature\",\n    get: function get() {\n      var _this18 = this;\n      return Object.keys(this.detailsByOuterHTML).filter(function (outerHTML) {\n        return _this18.detailsByOuterHTML[outerHTML].tracked;\n      }).join(\"\");\n    }\n  }, {\n    key: \"getScriptElementsNotInSnapshot\",\n    value: function getScriptElementsNotInSnapshot(snapshot) {\n      return this.getElementsMatchingTypeNotInSnapshot(\"script\", snapshot);\n    }\n  }, {\n    key: \"getStylesheetElementsNotInSnapshot\",\n    value: function getStylesheetElementsNotInSnapshot(snapshot) {\n      return this.getElementsMatchingTypeNotInSnapshot(\"stylesheet\", snapshot);\n    }\n  }, {\n    key: \"getElementsMatchingTypeNotInSnapshot\",\n    value: function getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {\n      var _this19 = this;\n      return Object.keys(this.detailsByOuterHTML).filter(function (outerHTML) {\n        return !(outerHTML in snapshot.detailsByOuterHTML);\n      }).map(function (outerHTML) {\n        return _this19.detailsByOuterHTML[outerHTML];\n      }).filter(function (_ref10) {\n        var type = _ref10.type;\n        return type == matchedType;\n      }).map(function (_ref11) {\n        var _ref11$elements = _slicedToArray(_ref11.elements, 1),\n          element = _ref11$elements[0];\n        return element;\n      });\n    }\n  }, {\n    key: \"provisionalElements\",\n    get: function get() {\n      var _this20 = this;\n      return Object.keys(this.detailsByOuterHTML).reduce(function (result, outerHTML) {\n        var _this20$detailsByOute = _this20.detailsByOuterHTML[outerHTML],\n          type = _this20$detailsByOute.type,\n          tracked = _this20$detailsByOute.tracked,\n          elements = _this20$detailsByOute.elements;\n        if (type == null && !tracked) {\n          return [].concat(_toConsumableArray(result), _toConsumableArray(elements));\n        } else if (elements.length > 1) {\n          return [].concat(_toConsumableArray(result), _toConsumableArray(elements.slice(1)));\n        } else {\n          return result;\n        }\n      }, []);\n    }\n  }, {\n    key: \"getMetaValue\",\n    value: function getMetaValue(name) {\n      var element = this.findMetaElementByName(name);\n      return element ? element.getAttribute(\"content\") : null;\n    }\n  }, {\n    key: \"findMetaElementByName\",\n    value: function findMetaElementByName(name) {\n      var _this21 = this;\n      return Object.keys(this.detailsByOuterHTML).reduce(function (result, outerHTML) {\n        var _this21$detailsByOute = _slicedToArray(_this21.detailsByOuterHTML[outerHTML].elements, 1),\n          element = _this21$detailsByOute[0];\n        return elementIsMetaElementWithName(element, name) ? element : result;\n      }, undefined | undefined);\n    }\n  }]);\n}(Snapshot);\nfunction elementType(element) {\n  if (elementIsScript(element)) {\n    return \"script\";\n  } else if (elementIsStylesheet(element)) {\n    return \"stylesheet\";\n  }\n}\nfunction elementIsTracked(element) {\n  return element.getAttribute(\"data-turbo-track\") == \"reload\";\n}\nfunction elementIsScript(element) {\n  var tagName = element.localName;\n  return tagName == \"script\";\n}\nfunction elementIsNoscript(element) {\n  var tagName = element.localName;\n  return tagName == \"noscript\";\n}\nfunction elementIsStylesheet(element) {\n  var tagName = element.localName;\n  return tagName == \"style\" || tagName == \"link\" && element.getAttribute(\"rel\") == \"stylesheet\";\n}\nfunction elementIsMetaElementWithName(element, name) {\n  var tagName = element.localName;\n  return tagName == \"meta\" && element.getAttribute(\"name\") == name;\n}\nfunction elementWithoutNonce(element) {\n  if (element.hasAttribute(\"nonce\")) {\n    element.setAttribute(\"nonce\", \"\");\n  }\n  return element;\n}\nvar PageSnapshot = /*#__PURE__*/function (_Snapshot2) {\n  function PageSnapshot(documentElement, body, headSnapshot) {\n    var _this22;\n    _classCallCheck(this, PageSnapshot);\n    _this22 = _callSuper(this, PageSnapshot, [body]);\n    _this22.documentElement = documentElement;\n    _this22.headSnapshot = headSnapshot;\n    return _this22;\n  }\n  _inherits(PageSnapshot, _Snapshot2);\n  return _createClass(PageSnapshot, [{\n    key: \"clone\",\n    value: function clone() {\n      var clonedElement = this.element.cloneNode(true);\n      var selectElements = this.element.querySelectorAll(\"select\");\n      var clonedSelectElements = clonedElement.querySelectorAll(\"select\");\n      var _iterator16 = _createForOfIteratorHelper(selectElements.entries()),\n        _step16;\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var _ref12 = _step16.value;\n          var _ref13 = _slicedToArray(_ref12, 2);\n          var index = _ref13[0];\n          var source = _ref13[1];\n          {\n            var _clone = clonedSelectElements[index];\n            var _iterator18 = _createForOfIteratorHelper(_clone.selectedOptions),\n              _step18;\n            try {\n              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                var option = _step18.value;\n                option.selected = false;\n              }\n            } catch (err) {\n              _iterator18.e(err);\n            } finally {\n              _iterator18.f();\n            }\n            var _iterator19 = _createForOfIteratorHelper(source.selectedOptions),\n              _step19;\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _option = _step19.value;\n                _clone.options[_option.index].selected = true;\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n      var _iterator17 = _createForOfIteratorHelper(clonedElement.querySelectorAll('input[type=\"password\"]')),\n        _step17;\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var clonedPasswordInput = _step17.value;\n          clonedPasswordInput.value = \"\";\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n      return new PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);\n    }\n  }, {\n    key: \"lang\",\n    get: function get() {\n      return this.documentElement.getAttribute(\"lang\");\n    }\n  }, {\n    key: \"headElement\",\n    get: function get() {\n      return this.headSnapshot.element;\n    }\n  }, {\n    key: \"rootLocation\",\n    get: function get() {\n      var _this$getSetting;\n      var root = (_this$getSetting = this.getSetting(\"root\")) !== null && _this$getSetting !== void 0 ? _this$getSetting : \"/\";\n      return expandURL(root);\n    }\n  }, {\n    key: \"cacheControlValue\",\n    get: function get() {\n      return this.getSetting(\"cache-control\");\n    }\n  }, {\n    key: \"isPreviewable\",\n    get: function get() {\n      return this.cacheControlValue != \"no-preview\";\n    }\n  }, {\n    key: \"isCacheable\",\n    get: function get() {\n      return this.cacheControlValue != \"no-cache\";\n    }\n  }, {\n    key: \"isVisitable\",\n    get: function get() {\n      return this.getSetting(\"visit-control\") != \"reload\";\n    }\n  }, {\n    key: \"prefersViewTransitions\",\n    get: function get() {\n      return this.headSnapshot.getMetaValue(\"view-transition\") === \"same-origin\";\n    }\n  }, {\n    key: \"shouldMorphPage\",\n    get: function get() {\n      return this.getSetting(\"refresh-method\") === \"morph\";\n    }\n  }, {\n    key: \"shouldPreserveScrollPosition\",\n    get: function get() {\n      return this.getSetting(\"refresh-scroll\") === \"preserve\";\n    }\n\n    // Private\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(name) {\n      return this.headSnapshot.getMetaValue(\"turbo-\".concat(name));\n    }\n  }], [{\n    key: \"fromHTMLString\",\n    value: function fromHTMLString() {\n      var html = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      return this.fromDocument(parseHTMLDocument(html));\n    }\n  }, {\n    key: \"fromElement\",\n    value: function fromElement(element) {\n      return this.fromDocument(element.ownerDocument);\n    }\n  }, {\n    key: \"fromDocument\",\n    value: function fromDocument(_ref14) {\n      var documentElement = _ref14.documentElement,\n        body = _ref14.body,\n        head = _ref14.head;\n      return new this(documentElement, body, new HeadSnapshot(head));\n    }\n  }]);\n}(Snapshot);\nvar _viewTransitionStarted = /*#__PURE__*/_classPrivateFieldLooseKey(\"viewTransitionStarted\");\nvar _lastOperation = /*#__PURE__*/_classPrivateFieldLooseKey(\"lastOperation\");\nvar ViewTransitioner = /*#__PURE__*/function () {\n  function ViewTransitioner() {\n    _classCallCheck(this, ViewTransitioner);\n    Object.defineProperty(this, _viewTransitionStarted, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _lastOperation, {\n      writable: true,\n      value: Promise.resolve()\n    });\n  }\n  return _createClass(ViewTransitioner, [{\n    key: \"renderChange\",\n    value: function renderChange(useViewTransition, render) {\n      if (useViewTransition && this.viewTransitionsAvailable && !_classPrivateFieldLooseBase(this, _viewTransitionStarted)[_viewTransitionStarted]) {\n        _classPrivateFieldLooseBase(this, _viewTransitionStarted)[_viewTransitionStarted] = true;\n        _classPrivateFieldLooseBase(this, _lastOperation)[_lastOperation] = _classPrivateFieldLooseBase(this, _lastOperation)[_lastOperation].then(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n          return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n            while (1) switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return document.startViewTransition(render).finished;\n              case 2:\n              case \"end\":\n                return _context11.stop();\n            }\n          }, _callee11);\n        })));\n      } else {\n        _classPrivateFieldLooseBase(this, _lastOperation)[_lastOperation] = _classPrivateFieldLooseBase(this, _lastOperation)[_lastOperation].then(render);\n      }\n      return _classPrivateFieldLooseBase(this, _lastOperation)[_lastOperation];\n    }\n  }, {\n    key: \"viewTransitionsAvailable\",\n    get: function get() {\n      return document.startViewTransition;\n    }\n  }]);\n}();\nvar defaultOptions = {\n  action: \"advance\",\n  historyChanged: false,\n  visitCachedSnapshot: function visitCachedSnapshot() {},\n  willRender: true,\n  updateHistory: true,\n  shouldCacheSnapshot: true,\n  acceptsStreamResponse: false\n};\nvar TimingMetric = {\n  visitStart: \"visitStart\",\n  requestStart: \"requestStart\",\n  requestEnd: \"requestEnd\",\n  visitEnd: \"visitEnd\"\n};\nvar VisitState = {\n  initialized: \"initialized\",\n  started: \"started\",\n  canceled: \"canceled\",\n  failed: \"failed\",\n  completed: \"completed\"\n};\nvar SystemStatusCode = {\n  networkFailure: 0,\n  timeoutFailure: -1,\n  contentTypeMismatch: -2\n};\nvar Direction = {\n  advance: \"forward\",\n  restore: \"back\",\n  replace: \"none\"\n};\nvar Visit = /*#__PURE__*/function () {\n  function Visit(delegate, location, restorationIdentifier) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, Visit);\n    this.identifier = uuid();\n    // Required by turbo-ios\n    this.timingMetrics = {};\n    this.followedRedirect = false;\n    this.historyChanged = false;\n    this.scrolled = false;\n    this.shouldCacheSnapshot = true;\n    this.acceptsStreamResponse = false;\n    this.snapshotCached = false;\n    this.state = VisitState.initialized;\n    this.viewTransitioner = new ViewTransitioner();\n    this.delegate = delegate;\n    this.location = location;\n    this.restorationIdentifier = restorationIdentifier || uuid();\n    var _defaultOptions$optio = _objectSpread(_objectSpread({}, defaultOptions), options),\n      action = _defaultOptions$optio.action,\n      historyChanged = _defaultOptions$optio.historyChanged,\n      referrer = _defaultOptions$optio.referrer,\n      snapshot = _defaultOptions$optio.snapshot,\n      snapshotHTML = _defaultOptions$optio.snapshotHTML,\n      response = _defaultOptions$optio.response,\n      visitCachedSnapshot = _defaultOptions$optio.visitCachedSnapshot,\n      willRender = _defaultOptions$optio.willRender,\n      updateHistory = _defaultOptions$optio.updateHistory,\n      shouldCacheSnapshot = _defaultOptions$optio.shouldCacheSnapshot,\n      acceptsStreamResponse = _defaultOptions$optio.acceptsStreamResponse,\n      direction = _defaultOptions$optio.direction;\n    this.action = action;\n    this.historyChanged = historyChanged;\n    this.referrer = referrer;\n    this.snapshot = snapshot;\n    this.snapshotHTML = snapshotHTML;\n    this.response = response;\n    this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);\n    this.isPageRefresh = this.view.isPageRefresh(this);\n    this.visitCachedSnapshot = visitCachedSnapshot;\n    this.willRender = willRender;\n    this.updateHistory = updateHistory;\n    this.scrolled = !willRender;\n    this.shouldCacheSnapshot = shouldCacheSnapshot;\n    this.acceptsStreamResponse = acceptsStreamResponse;\n    this.direction = direction || Direction[action];\n  }\n  return _createClass(Visit, [{\n    key: \"adapter\",\n    get: function get() {\n      return this.delegate.adapter;\n    }\n  }, {\n    key: \"view\",\n    get: function get() {\n      return this.delegate.view;\n    }\n  }, {\n    key: \"history\",\n    get: function get() {\n      return this.delegate.history;\n    }\n  }, {\n    key: \"restorationData\",\n    get: function get() {\n      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);\n    }\n  }, {\n    key: \"silent\",\n    get: function get() {\n      return this.isSamePage;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.state == VisitState.initialized) {\n        this.recordTimingMetric(TimingMetric.visitStart);\n        this.state = VisitState.started;\n        this.adapter.visitStarted(this);\n        this.delegate.visitStarted(this);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.state == VisitState.started) {\n        if (this.request) {\n          this.request.cancel();\n        }\n        this.cancelRender();\n        this.state = VisitState.canceled;\n      }\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      if (this.state == VisitState.started) {\n        this.recordTimingMetric(TimingMetric.visitEnd);\n        this.adapter.visitCompleted(this);\n        this.state = VisitState.completed;\n        this.followRedirect();\n        if (!this.followedRedirect) {\n          this.delegate.visitCompleted(this);\n        }\n      }\n    }\n  }, {\n    key: \"fail\",\n    value: function fail() {\n      if (this.state == VisitState.started) {\n        this.state = VisitState.failed;\n        this.adapter.visitFailed(this);\n        this.delegate.visitCompleted(this);\n      }\n    }\n  }, {\n    key: \"changeHistory\",\n    value: function changeHistory() {\n      if (!this.historyChanged && this.updateHistory) {\n        var _this$referrer;\n        var actionForHistory = this.location.href === ((_this$referrer = this.referrer) === null || _this$referrer === void 0 ? void 0 : _this$referrer.href) ? \"replace\" : this.action;\n        var method = getHistoryMethodForAction(actionForHistory);\n        this.history.update(method, this.location, this.restorationIdentifier);\n        this.historyChanged = true;\n      }\n    }\n  }, {\n    key: \"issueRequest\",\n    value: function issueRequest() {\n      if (this.hasPreloadedResponse()) {\n        this.simulateRequest();\n      } else if (this.shouldIssueRequest() && !this.request) {\n        this.request = new FetchRequest(this, FetchMethod.get, this.location);\n        this.request.perform();\n      }\n    }\n  }, {\n    key: \"simulateRequest\",\n    value: function simulateRequest() {\n      if (this.response) {\n        this.startRequest();\n        this.recordResponse();\n        this.finishRequest();\n      }\n    }\n  }, {\n    key: \"startRequest\",\n    value: function startRequest() {\n      this.recordTimingMetric(TimingMetric.requestStart);\n      this.adapter.visitRequestStarted(this);\n    }\n  }, {\n    key: \"recordResponse\",\n    value: function recordResponse() {\n      var response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.response;\n      this.response = response;\n      if (response) {\n        var statusCode = response.statusCode;\n        if (isSuccessful(statusCode)) {\n          this.adapter.visitRequestCompleted(this);\n        } else {\n          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);\n        }\n      }\n    }\n  }, {\n    key: \"finishRequest\",\n    value: function finishRequest() {\n      this.recordTimingMetric(TimingMetric.requestEnd);\n      this.adapter.visitRequestFinished(this);\n    }\n  }, {\n    key: \"loadResponse\",\n    value: function loadResponse() {\n      var _this23 = this;\n      if (this.response) {\n        var _this$response = this.response,\n          statusCode = _this$response.statusCode,\n          responseHTML = _this$response.responseHTML;\n        this.render(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n          var snapshot;\n          return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n            while (1) switch (_context12.prev = _context12.next) {\n              case 0:\n                if (_this23.shouldCacheSnapshot) _this23.cacheSnapshot();\n                if (!_this23.view.renderPromise) {\n                  _context12.next = 4;\n                  break;\n                }\n                _context12.next = 4;\n                return _this23.view.renderPromise;\n              case 4:\n                if (!(isSuccessful(statusCode) && responseHTML != null)) {\n                  _context12.next = 12;\n                  break;\n                }\n                snapshot = PageSnapshot.fromHTMLString(responseHTML);\n                _context12.next = 8;\n                return _this23.renderPageSnapshot(snapshot, false);\n              case 8:\n                _this23.adapter.visitRendered(_this23);\n                _this23.complete();\n                _context12.next = 16;\n                break;\n              case 12:\n                _context12.next = 14;\n                return _this23.view.renderError(PageSnapshot.fromHTMLString(responseHTML), _this23);\n              case 14:\n                _this23.adapter.visitRendered(_this23);\n                _this23.fail();\n              case 16:\n              case \"end\":\n                return _context12.stop();\n            }\n          }, _callee12);\n        })));\n      }\n    }\n  }, {\n    key: \"getCachedSnapshot\",\n    value: function getCachedSnapshot() {\n      var snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();\n      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {\n        if (this.action == \"restore\" || snapshot.isPreviewable) {\n          return snapshot;\n        }\n      }\n    }\n  }, {\n    key: \"getPreloadedSnapshot\",\n    value: function getPreloadedSnapshot() {\n      if (this.snapshotHTML) {\n        return PageSnapshot.fromHTMLString(this.snapshotHTML);\n      }\n    }\n  }, {\n    key: \"hasCachedSnapshot\",\n    value: function hasCachedSnapshot() {\n      return this.getCachedSnapshot() != null;\n    }\n  }, {\n    key: \"loadCachedSnapshot\",\n    value: function loadCachedSnapshot() {\n      var _this24 = this;\n      var snapshot = this.getCachedSnapshot();\n      if (snapshot) {\n        var isPreview = this.shouldIssueRequest();\n        this.render(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n          return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n            while (1) switch (_context13.prev = _context13.next) {\n              case 0:\n                _this24.cacheSnapshot();\n                if (!(_this24.isSamePage || _this24.isPageRefresh)) {\n                  _context13.next = 5;\n                  break;\n                }\n                _this24.adapter.visitRendered(_this24);\n                _context13.next = 12;\n                break;\n              case 5:\n                if (!_this24.view.renderPromise) {\n                  _context13.next = 8;\n                  break;\n                }\n                _context13.next = 8;\n                return _this24.view.renderPromise;\n              case 8:\n                _context13.next = 10;\n                return _this24.renderPageSnapshot(snapshot, isPreview);\n              case 10:\n                _this24.adapter.visitRendered(_this24);\n                if (!isPreview) {\n                  _this24.complete();\n                }\n              case 12:\n              case \"end\":\n                return _context13.stop();\n            }\n          }, _callee13);\n        })));\n      }\n    }\n  }, {\n    key: \"followRedirect\",\n    value: function followRedirect() {\n      var _this$response2;\n      if (this.redirectedToLocation && !this.followedRedirect && (_this$response2 = this.response) !== null && _this$response2 !== void 0 && _this$response2.redirected) {\n        this.adapter.visitProposedToLocation(this.redirectedToLocation, {\n          action: \"replace\",\n          response: this.response,\n          shouldCacheSnapshot: false,\n          willRender: false\n        });\n        this.followedRedirect = true;\n      }\n    }\n  }, {\n    key: \"goToSamePageAnchor\",\n    value: function goToSamePageAnchor() {\n      var _this25 = this;\n      if (this.isSamePage) {\n        this.render(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n          return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n            while (1) switch (_context14.prev = _context14.next) {\n              case 0:\n                _this25.cacheSnapshot();\n                _this25.performScroll();\n                _this25.changeHistory();\n                _this25.adapter.visitRendered(_this25);\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }, _callee14);\n        })));\n      }\n    }\n\n    // Fetch request delegate\n  }, {\n    key: \"prepareRequest\",\n    value: function prepareRequest(request) {\n      if (this.acceptsStreamResponse) {\n        request.acceptResponseType(StreamMessage.contentType);\n      }\n    }\n  }, {\n    key: \"requestStarted\",\n    value: function requestStarted() {\n      this.startRequest();\n    }\n  }, {\n    key: \"requestPreventedHandlingResponse\",\n    value: function requestPreventedHandlingResponse(_request, _response) {}\n  }, {\n    key: \"requestSucceededWithResponse\",\n    value: function () {\n      var _requestSucceededWithResponse = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(request, response) {\n        var responseHTML, redirected, statusCode;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.next = 2;\n              return response.responseHTML;\n            case 2:\n              responseHTML = _context15.sent;\n              redirected = response.redirected, statusCode = response.statusCode;\n              if (responseHTML == undefined) {\n                this.recordResponse({\n                  statusCode: SystemStatusCode.contentTypeMismatch,\n                  redirected: redirected\n                });\n              } else {\n                this.redirectedToLocation = response.redirected ? response.location : undefined;\n                this.recordResponse({\n                  statusCode: statusCode,\n                  responseHTML: responseHTML,\n                  redirected: redirected\n                });\n              }\n            case 5:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function requestSucceededWithResponse(_x12, _x13) {\n        return _requestSucceededWithResponse.apply(this, arguments);\n      }\n      return requestSucceededWithResponse;\n    }()\n  }, {\n    key: \"requestFailedWithResponse\",\n    value: function () {\n      var _requestFailedWithResponse = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(request, response) {\n        var responseHTML, redirected, statusCode;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.next = 2;\n              return response.responseHTML;\n            case 2:\n              responseHTML = _context16.sent;\n              redirected = response.redirected, statusCode = response.statusCode;\n              if (responseHTML == undefined) {\n                this.recordResponse({\n                  statusCode: SystemStatusCode.contentTypeMismatch,\n                  redirected: redirected\n                });\n              } else {\n                this.recordResponse({\n                  statusCode: statusCode,\n                  responseHTML: responseHTML,\n                  redirected: redirected\n                });\n              }\n            case 5:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function requestFailedWithResponse(_x14, _x15) {\n        return _requestFailedWithResponse.apply(this, arguments);\n      }\n      return requestFailedWithResponse;\n    }()\n  }, {\n    key: \"requestErrored\",\n    value: function requestErrored(_request, _error) {\n      this.recordResponse({\n        statusCode: SystemStatusCode.networkFailure,\n        redirected: false\n      });\n    }\n  }, {\n    key: \"requestFinished\",\n    value: function requestFinished() {\n      this.finishRequest();\n    }\n\n    // Scrolling\n  }, {\n    key: \"performScroll\",\n    value: function performScroll() {\n      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {\n        if (this.action == \"restore\") {\n          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();\n        } else {\n          this.scrollToAnchor() || this.view.scrollToTop();\n        }\n        if (this.isSamePage) {\n          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);\n        }\n        this.scrolled = true;\n      }\n    }\n  }, {\n    key: \"scrollToRestoredPosition\",\n    value: function scrollToRestoredPosition() {\n      var scrollPosition = this.restorationData.scrollPosition;\n      if (scrollPosition) {\n        this.view.scrollToPosition(scrollPosition);\n        return true;\n      }\n    }\n  }, {\n    key: \"scrollToAnchor\",\n    value: function scrollToAnchor() {\n      var anchor = getAnchor(this.location);\n      if (anchor != null) {\n        this.view.scrollToAnchor(anchor);\n        return true;\n      }\n    }\n\n    // Instrumentation\n  }, {\n    key: \"recordTimingMetric\",\n    value: function recordTimingMetric(metric) {\n      this.timingMetrics[metric] = new Date().getTime();\n    }\n  }, {\n    key: \"getTimingMetrics\",\n    value: function getTimingMetrics() {\n      return _objectSpread({}, this.timingMetrics);\n    }\n\n    // Private\n  }, {\n    key: \"getHistoryMethodForAction\",\n    value: function getHistoryMethodForAction(action) {\n      switch (action) {\n        case \"replace\":\n          return history.replaceState;\n        case \"advance\":\n        case \"restore\":\n          return history.pushState;\n      }\n    }\n  }, {\n    key: \"hasPreloadedResponse\",\n    value: function hasPreloadedResponse() {\n      return _typeof(this.response) == \"object\";\n    }\n  }, {\n    key: \"shouldIssueRequest\",\n    value: function shouldIssueRequest() {\n      if (this.isSamePage) {\n        return false;\n      } else if (this.action == \"restore\") {\n        return !this.hasCachedSnapshot();\n      } else {\n        return this.willRender;\n      }\n    }\n  }, {\n    key: \"cacheSnapshot\",\n    value: function cacheSnapshot() {\n      var _this26 = this;\n      if (!this.snapshotCached) {\n        this.view.cacheSnapshot(this.snapshot).then(function (snapshot) {\n          return snapshot && _this26.visitCachedSnapshot(snapshot);\n        });\n        this.snapshotCached = true;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function () {\n      var _render3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(callback) {\n        var _this27 = this;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              this.cancelRender();\n              _context17.next = 3;\n              return new Promise(function (resolve) {\n                _this27.frame = document.visibilityState === \"hidden\" ? setTimeout(function () {\n                  return resolve();\n                }, 0) : requestAnimationFrame(function () {\n                  return resolve();\n                });\n              });\n            case 3:\n              _context17.next = 5;\n              return callback();\n            case 5:\n              delete this.frame;\n            case 6:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function render(_x16) {\n        return _render3.apply(this, arguments);\n      }\n      return render;\n    }()\n  }, {\n    key: \"renderPageSnapshot\",\n    value: function () {\n      var _renderPageSnapshot = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(snapshot, isPreview) {\n        var _this28 = this;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), /*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n                return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n                  while (1) switch (_context18.prev = _context18.next) {\n                    case 0:\n                      _context18.next = 2;\n                      return _this28.view.renderPage(snapshot, isPreview, _this28.willRender, _this28);\n                    case 2:\n                      _this28.performScroll();\n                    case 3:\n                    case \"end\":\n                      return _context18.stop();\n                  }\n                }, _callee18);\n              })));\n            case 2:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function renderPageSnapshot(_x17, _x18) {\n        return _renderPageSnapshot.apply(this, arguments);\n      }\n      return renderPageSnapshot;\n    }()\n  }, {\n    key: \"cancelRender\",\n    value: function cancelRender() {\n      if (this.frame) {\n        cancelAnimationFrame(this.frame);\n        delete this.frame;\n      }\n    }\n  }]);\n}();\nfunction isSuccessful(statusCode) {\n  return statusCode >= 200 && statusCode < 300;\n}\nvar BrowserAdapter = /*#__PURE__*/function () {\n  function BrowserAdapter(session) {\n    var _this29 = this;\n    _classCallCheck(this, BrowserAdapter);\n    this.progressBar = new ProgressBar();\n    this.showProgressBar = function () {\n      _this29.progressBar.show();\n    };\n    this.session = session;\n  }\n  return _createClass(BrowserAdapter, [{\n    key: \"visitProposedToLocation\",\n    value: function visitProposedToLocation(location, options) {\n      if (locationIsVisitable(location, this.navigator.rootLocation)) {\n        this.navigator.startVisit(location, (options === null || options === void 0 ? void 0 : options.restorationIdentifier) || uuid(), options);\n      } else {\n        window.location.href = location.toString();\n      }\n    }\n  }, {\n    key: \"visitStarted\",\n    value: function visitStarted(visit) {\n      this.location = visit.location;\n      visit.loadCachedSnapshot();\n      visit.issueRequest();\n      visit.goToSamePageAnchor();\n    }\n  }, {\n    key: \"visitRequestStarted\",\n    value: function visitRequestStarted(visit) {\n      this.progressBar.setValue(0);\n      if (visit.hasCachedSnapshot() || visit.action != \"restore\") {\n        this.showVisitProgressBarAfterDelay();\n      } else {\n        this.showProgressBar();\n      }\n    }\n  }, {\n    key: \"visitRequestCompleted\",\n    value: function visitRequestCompleted(visit) {\n      visit.loadResponse();\n    }\n  }, {\n    key: \"visitRequestFailedWithStatusCode\",\n    value: function visitRequestFailedWithStatusCode(visit, statusCode) {\n      switch (statusCode) {\n        case SystemStatusCode.networkFailure:\n        case SystemStatusCode.timeoutFailure:\n        case SystemStatusCode.contentTypeMismatch:\n          return this.reload({\n            reason: \"request_failed\",\n            context: {\n              statusCode: statusCode\n            }\n          });\n        default:\n          return visit.loadResponse();\n      }\n    }\n  }, {\n    key: \"visitRequestFinished\",\n    value: function visitRequestFinished(_visit) {}\n  }, {\n    key: \"visitCompleted\",\n    value: function visitCompleted(_visit) {\n      this.progressBar.setValue(1);\n      this.hideVisitProgressBar();\n    }\n  }, {\n    key: \"pageInvalidated\",\n    value: function pageInvalidated(reason) {\n      this.reload(reason);\n    }\n  }, {\n    key: \"visitFailed\",\n    value: function visitFailed(_visit) {\n      this.progressBar.setValue(1);\n      this.hideVisitProgressBar();\n    }\n  }, {\n    key: \"visitRendered\",\n    value: function visitRendered(_visit) {}\n\n    // Form Submission Delegate\n  }, {\n    key: \"formSubmissionStarted\",\n    value: function formSubmissionStarted(_formSubmission) {\n      this.progressBar.setValue(0);\n      this.showFormProgressBarAfterDelay();\n    }\n  }, {\n    key: \"formSubmissionFinished\",\n    value: function formSubmissionFinished(_formSubmission) {\n      this.progressBar.setValue(1);\n      this.hideFormProgressBar();\n    }\n\n    // Private\n  }, {\n    key: \"showVisitProgressBarAfterDelay\",\n    value: function showVisitProgressBarAfterDelay() {\n      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);\n    }\n  }, {\n    key: \"hideVisitProgressBar\",\n    value: function hideVisitProgressBar() {\n      this.progressBar.hide();\n      if (this.visitProgressBarTimeout != null) {\n        window.clearTimeout(this.visitProgressBarTimeout);\n        delete this.visitProgressBarTimeout;\n      }\n    }\n  }, {\n    key: \"showFormProgressBarAfterDelay\",\n    value: function showFormProgressBarAfterDelay() {\n      if (this.formProgressBarTimeout == null) {\n        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);\n      }\n    }\n  }, {\n    key: \"hideFormProgressBar\",\n    value: function hideFormProgressBar() {\n      this.progressBar.hide();\n      if (this.formProgressBarTimeout != null) {\n        window.clearTimeout(this.formProgressBarTimeout);\n        delete this.formProgressBarTimeout;\n      }\n    }\n  }, {\n    key: \"reload\",\n    value: function reload(reason) {\n      var _this$location;\n      dispatch(\"turbo:reload\", {\n        detail: reason\n      });\n      window.location.href = ((_this$location = this.location) === null || _this$location === void 0 ? void 0 : _this$location.toString()) || window.location.href;\n    }\n  }, {\n    key: \"navigator\",\n    get: function get() {\n      return this.session.navigator;\n    }\n  }]);\n}();\nvar CacheObserver = /*#__PURE__*/function () {\n  function CacheObserver() {\n    var _this30 = this;\n    _classCallCheck(this, CacheObserver);\n    this.selector = \"[data-turbo-temporary]\";\n    this.deprecatedSelector = \"[data-turbo-cache=false]\";\n    this.started = false;\n    this.removeTemporaryElements = function (_event) {\n      var _iterator20 = _createForOfIteratorHelper(_this30.temporaryElements),\n        _step20;\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var element = _step20.value;\n          element.remove();\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n    };\n  }\n  return _createClass(CacheObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        this.started = true;\n        addEventListener(\"turbo:before-cache\", this.removeTemporaryElements, false);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.started = false;\n        removeEventListener(\"turbo:before-cache\", this.removeTemporaryElements, false);\n      }\n    }\n  }, {\n    key: \"temporaryElements\",\n    get: function get() {\n      return [].concat(_toConsumableArray(document.querySelectorAll(this.selector)), _toConsumableArray(this.temporaryElementsWithDeprecation));\n    }\n  }, {\n    key: \"temporaryElementsWithDeprecation\",\n    get: function get() {\n      var elements = document.querySelectorAll(this.deprecatedSelector);\n      if (elements.length) {\n        console.warn(\"The \".concat(this.deprecatedSelector, \" selector is deprecated and will be removed in a future version. Use \").concat(this.selector, \" instead.\"));\n      }\n      return _toConsumableArray(elements);\n    }\n  }]);\n}();\nvar _shouldSubmit = /*#__PURE__*/_classPrivateFieldLooseKey(\"shouldSubmit\");\nvar _shouldRedirect = /*#__PURE__*/_classPrivateFieldLooseKey(\"shouldRedirect\");\nvar _findFrameElement = /*#__PURE__*/_classPrivateFieldLooseKey(\"findFrameElement\");\nvar FrameRedirector = /*#__PURE__*/function () {\n  function FrameRedirector(session, _element) {\n    _classCallCheck(this, FrameRedirector);\n    Object.defineProperty(this, _findFrameElement, {\n      value: _findFrameElement2\n    });\n    Object.defineProperty(this, _shouldRedirect, {\n      value: _shouldRedirect2\n    });\n    Object.defineProperty(this, _shouldSubmit, {\n      value: _shouldSubmit2\n    });\n    this.session = session;\n    this.element = _element;\n    this.linkInterceptor = new LinkInterceptor(this, _element);\n    this.formSubmitObserver = new FormSubmitObserver(this, _element);\n  }\n  return _createClass(FrameRedirector, [{\n    key: \"start\",\n    value: function start() {\n      this.linkInterceptor.start();\n      this.formSubmitObserver.start();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.linkInterceptor.stop();\n      this.formSubmitObserver.stop();\n    }\n\n    // Link interceptor delegate\n  }, {\n    key: \"shouldInterceptLinkClick\",\n    value: function shouldInterceptLinkClick(element, _location, _event) {\n      return _classPrivateFieldLooseBase(this, _shouldRedirect)[_shouldRedirect](element);\n    }\n  }, {\n    key: \"linkClickIntercepted\",\n    value: function linkClickIntercepted(element, url, event) {\n      var frame = _classPrivateFieldLooseBase(this, _findFrameElement)[_findFrameElement](element);\n      if (frame) {\n        frame.delegate.linkClickIntercepted(element, url, event);\n      }\n    }\n\n    // Form submit observer delegate\n  }, {\n    key: \"willSubmitForm\",\n    value: function willSubmitForm(element, submitter) {\n      return element.closest(\"turbo-frame\") == null && _classPrivateFieldLooseBase(this, _shouldSubmit)[_shouldSubmit](element, submitter) && _classPrivateFieldLooseBase(this, _shouldRedirect)[_shouldRedirect](element, submitter);\n    }\n  }, {\n    key: \"formSubmitted\",\n    value: function formSubmitted(element, submitter) {\n      var frame = _classPrivateFieldLooseBase(this, _findFrameElement)[_findFrameElement](element, submitter);\n      if (frame) {\n        frame.delegate.formSubmitted(element, submitter);\n      }\n    }\n  }]);\n}();\nfunction _shouldSubmit2(form, submitter) {\n  var _meta$content2;\n  var action = getAction$1(form, submitter);\n  var meta = this.element.ownerDocument.querySelector(\"meta[name=\\\"turbo-root\\\"]\");\n  var rootLocation = expandURL((_meta$content2 = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _meta$content2 !== void 0 ? _meta$content2 : \"/\");\n  return _classPrivateFieldLooseBase(this, _shouldRedirect)[_shouldRedirect](form, submitter) && locationIsVisitable(action, rootLocation);\n}\nfunction _shouldRedirect2(element, submitter) {\n  var isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);\n  if (isNavigatable) {\n    var frame = _classPrivateFieldLooseBase(this, _findFrameElement)[_findFrameElement](element, submitter);\n    return frame ? frame != element.closest(\"turbo-frame\") : false;\n  } else {\n    return false;\n  }\n}\nfunction _findFrameElement2(element, submitter) {\n  var id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute(\"data-turbo-frame\")) || element.getAttribute(\"data-turbo-frame\");\n  if (id && id != \"_top\") {\n    var frame = this.element.querySelector(\"#\".concat(id, \":not([disabled])\"));\n    if (frame instanceof FrameElement) {\n      return frame;\n    }\n  }\n}\nvar History = /*#__PURE__*/function () {\n  function History(delegate) {\n    var _this31 = this;\n    _classCallCheck(this, History);\n    this.location = void 0;\n    this.restorationIdentifier = uuid();\n    this.restorationData = {};\n    this.started = false;\n    this.pageLoaded = false;\n    this.currentIndex = 0;\n    // Event handlers\n    this.onPopState = function (event) {\n      if (_this31.shouldHandlePopState()) {\n        var _ref20 = event.state || {},\n          turbo = _ref20.turbo;\n        if (turbo) {\n          _this31.location = new URL(window.location.href);\n          var restorationIdentifier = turbo.restorationIdentifier,\n            restorationIndex = turbo.restorationIndex;\n          _this31.restorationIdentifier = restorationIdentifier;\n          var direction = restorationIndex > _this31.currentIndex ? \"forward\" : \"back\";\n          _this31.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(_this31.location, restorationIdentifier, direction);\n          _this31.currentIndex = restorationIndex;\n        }\n      }\n    };\n    this.onPageLoad = /*#__PURE__*/function () {\n      var _ref21 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_event) {\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return nextMicrotask();\n            case 2:\n              _this31.pageLoaded = true;\n            case 3:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20);\n      }));\n      return function (_x19) {\n        return _ref21.apply(this, arguments);\n      };\n    }();\n    this.delegate = delegate;\n  }\n  return _createClass(History, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        var _history$state, _history$state$turbo;\n        addEventListener(\"popstate\", this.onPopState, false);\n        addEventListener(\"load\", this.onPageLoad, false);\n        this.currentIndex = ((_history$state = history.state) === null || _history$state === void 0 ? void 0 : (_history$state$turbo = _history$state.turbo) === null || _history$state$turbo === void 0 ? void 0 : _history$state$turbo.restorationIndex) || 0;\n        this.started = true;\n        this.replace(new URL(window.location.href));\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        removeEventListener(\"popstate\", this.onPopState, false);\n        removeEventListener(\"load\", this.onPageLoad, false);\n        this.started = false;\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(location, restorationIdentifier) {\n      this.update(history.pushState, location, restorationIdentifier);\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(location, restorationIdentifier) {\n      this.update(history.replaceState, location, restorationIdentifier);\n    }\n  }, {\n    key: \"update\",\n    value: function update(method, location) {\n      var restorationIdentifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uuid();\n      if (method === history.pushState) ++this.currentIndex;\n      var state = {\n        turbo: {\n          restorationIdentifier: restorationIdentifier,\n          restorationIndex: this.currentIndex\n        }\n      };\n      method.call(history, state, \"\", location.href);\n      this.location = location;\n      this.restorationIdentifier = restorationIdentifier;\n    }\n\n    // Restoration data\n  }, {\n    key: \"getRestorationDataForIdentifier\",\n    value: function getRestorationDataForIdentifier(restorationIdentifier) {\n      return this.restorationData[restorationIdentifier] || {};\n    }\n  }, {\n    key: \"updateRestorationData\",\n    value: function updateRestorationData(additionalData) {\n      var restorationIdentifier = this.restorationIdentifier;\n      var restorationData = this.restorationData[restorationIdentifier];\n      this.restorationData[restorationIdentifier] = _objectSpread(_objectSpread({}, restorationData), additionalData);\n    }\n\n    // Scroll restoration\n  }, {\n    key: \"assumeControlOfScrollRestoration\",\n    value: function assumeControlOfScrollRestoration() {\n      if (!this.previousScrollRestoration) {\n        var _history$scrollRestor;\n        this.previousScrollRestoration = (_history$scrollRestor = history.scrollRestoration) !== null && _history$scrollRestor !== void 0 ? _history$scrollRestor : \"auto\";\n        history.scrollRestoration = \"manual\";\n      }\n    }\n  }, {\n    key: \"relinquishControlOfScrollRestoration\",\n    value: function relinquishControlOfScrollRestoration() {\n      if (this.previousScrollRestoration) {\n        history.scrollRestoration = this.previousScrollRestoration;\n        delete this.previousScrollRestoration;\n      }\n    }\n  }, {\n    key: \"shouldHandlePopState\",\n    value:\n    // Private\n\n    function shouldHandlePopState() {\n      // Safari dispatches a popstate event after window's load event, ignore it\n      return this.pageIsLoaded();\n    }\n  }, {\n    key: \"pageIsLoaded\",\n    value: function pageIsLoaded() {\n      return this.pageLoaded || document.readyState == \"complete\";\n    }\n  }]);\n}();\nvar _prefetchedLink = /*#__PURE__*/_classPrivateFieldLooseKey(\"prefetchedLink\");\nvar _enable = /*#__PURE__*/_classPrivateFieldLooseKey(\"enable\");\nvar _tryToPrefetchRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"tryToPrefetchRequest\");\nvar _cancelRequestIfObsolete = /*#__PURE__*/_classPrivateFieldLooseKey(\"cancelRequestIfObsolete\");\nvar _cancelPrefetchRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"cancelPrefetchRequest\");\nvar _tryToUsePrefetchedRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"tryToUsePrefetchedRequest\");\nvar _cacheTtl = /*#__PURE__*/_classPrivateFieldLooseKey(\"cacheTtl\");\nvar _isPrefetchable = /*#__PURE__*/_classPrivateFieldLooseKey(\"isPrefetchable\");\nvar LinkPrefetchObserver = /*#__PURE__*/function () {\n  function LinkPrefetchObserver(delegate, eventTarget) {\n    var _this32 = this;\n    _classCallCheck(this, LinkPrefetchObserver);\n    Object.defineProperty(this, _isPrefetchable, {\n      value: _isPrefetchable2\n    });\n    Object.defineProperty(this, _cacheTtl, {\n      get: _get_cacheTtl,\n      set: void 0\n    });\n    this.started = false;\n    Object.defineProperty(this, _prefetchedLink, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _enable, {\n      writable: true,\n      value: function value() {\n        _this32.eventTarget.addEventListener(\"mouseenter\", _classPrivateFieldLooseBase(_this32, _tryToPrefetchRequest)[_tryToPrefetchRequest], {\n          capture: true,\n          passive: true\n        });\n        _this32.eventTarget.addEventListener(\"mouseleave\", _classPrivateFieldLooseBase(_this32, _cancelRequestIfObsolete)[_cancelRequestIfObsolete], {\n          capture: true,\n          passive: true\n        });\n        _this32.eventTarget.addEventListener(\"turbo:before-fetch-request\", _classPrivateFieldLooseBase(_this32, _tryToUsePrefetchedRequest)[_tryToUsePrefetchedRequest], true);\n        _this32.started = true;\n      }\n    });\n    Object.defineProperty(this, _tryToPrefetchRequest, {\n      writable: true,\n      value: function value(event) {\n        if (getMetaContent(\"turbo-prefetch\") === \"false\") return;\n        var target = event.target;\n        var isLink = target.matches && target.matches(\"a[href]:not([target^=_]):not([download])\");\n        if (isLink && _classPrivateFieldLooseBase(_this32, _isPrefetchable)[_isPrefetchable](target)) {\n          var link = target;\n          var _location3 = getLocationForLink(link);\n          if (_this32.delegate.canPrefetchRequestToLocation(link, _location3)) {\n            _classPrivateFieldLooseBase(_this32, _prefetchedLink)[_prefetchedLink] = link;\n            var fetchRequest = new FetchRequest(_this32, FetchMethod.get, _location3, new URLSearchParams(), target);\n            prefetchCache.setLater(_location3.toString(), fetchRequest, _classPrivateFieldLooseBase(_this32, _cacheTtl)[_cacheTtl]);\n          }\n        }\n      }\n    });\n    Object.defineProperty(this, _cancelRequestIfObsolete, {\n      writable: true,\n      value: function value(event) {\n        if (event.target === _classPrivateFieldLooseBase(_this32, _prefetchedLink)[_prefetchedLink]) _classPrivateFieldLooseBase(_this32, _cancelPrefetchRequest)[_cancelPrefetchRequest]();\n      }\n    });\n    Object.defineProperty(this, _cancelPrefetchRequest, {\n      writable: true,\n      value: function value() {\n        prefetchCache.clear();\n        _classPrivateFieldLooseBase(_this32, _prefetchedLink)[_prefetchedLink] = null;\n      }\n    });\n    Object.defineProperty(this, _tryToUsePrefetchedRequest, {\n      writable: true,\n      value: function value(event) {\n        if (event.target.tagName !== \"FORM\" && event.detail.fetchOptions.method === \"GET\") {\n          var cached = prefetchCache.get(event.detail.url.toString());\n          if (cached) {\n            // User clicked link, use cache response\n            event.detail.fetchRequest = cached;\n          }\n          prefetchCache.clear();\n        }\n      }\n    });\n    this.delegate = delegate;\n    this.eventTarget = eventTarget;\n  }\n  return _createClass(LinkPrefetchObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (this.started) return;\n      if (this.eventTarget.readyState === \"loading\") {\n        this.eventTarget.addEventListener(\"DOMContentLoaded\", _classPrivateFieldLooseBase(this, _enable)[_enable], {\n          once: true\n        });\n      } else {\n        _classPrivateFieldLooseBase(this, _enable)[_enable]();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.started) return;\n      this.eventTarget.removeEventListener(\"mouseenter\", _classPrivateFieldLooseBase(this, _tryToPrefetchRequest)[_tryToPrefetchRequest], {\n        capture: true,\n        passive: true\n      });\n      this.eventTarget.removeEventListener(\"mouseleave\", _classPrivateFieldLooseBase(this, _cancelRequestIfObsolete)[_cancelRequestIfObsolete], {\n        capture: true,\n        passive: true\n      });\n      this.eventTarget.removeEventListener(\"turbo:before-fetch-request\", _classPrivateFieldLooseBase(this, _tryToUsePrefetchedRequest)[_tryToUsePrefetchedRequest], true);\n      this.started = false;\n    }\n  }, {\n    key: \"prepareRequest\",\n    value: function prepareRequest(request) {\n      var link = request.target;\n      request.headers[\"X-Sec-Purpose\"] = \"prefetch\";\n      var turboFrame = link.closest(\"turbo-frame\");\n      var turboFrameTarget = link.getAttribute(\"data-turbo-frame\") || (turboFrame === null || turboFrame === void 0 ? void 0 : turboFrame.getAttribute(\"target\")) || (turboFrame === null || turboFrame === void 0 ? void 0 : turboFrame.id);\n      if (turboFrameTarget && turboFrameTarget !== \"_top\") {\n        request.headers[\"Turbo-Frame\"] = turboFrameTarget;\n      }\n    }\n\n    // Fetch request interface\n  }, {\n    key: \"requestSucceededWithResponse\",\n    value: function requestSucceededWithResponse() {}\n  }, {\n    key: \"requestStarted\",\n    value: function requestStarted(fetchRequest) {}\n  }, {\n    key: \"requestErrored\",\n    value: function requestErrored(fetchRequest) {}\n  }, {\n    key: \"requestFinished\",\n    value: function requestFinished(fetchRequest) {}\n  }, {\n    key: \"requestPreventedHandlingResponse\",\n    value: function requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}\n  }, {\n    key: \"requestFailedWithResponse\",\n    value: function requestFailedWithResponse(fetchRequest, fetchResponse) {}\n  }]);\n}();\nfunction _get_cacheTtl() {\n  return Number(getMetaContent(\"turbo-prefetch-cache-time\")) || cacheTtl;\n}\nfunction _isPrefetchable2(link) {\n  var href = link.getAttribute(\"href\");\n  if (!href) return false;\n  if (unfetchableLink(link)) return false;\n  if (linkToTheSamePage(link)) return false;\n  if (linkOptsOut(link)) return false;\n  if (nonSafeLink(link)) return false;\n  if (eventPrevented(link)) return false;\n  return true;\n}\nvar unfetchableLink = function unfetchableLink(link) {\n  return link.origin !== document.location.origin || ![\"http:\", \"https:\"].includes(link.protocol) || link.hasAttribute(\"target\");\n};\nvar linkToTheSamePage = function linkToTheSamePage(link) {\n  return link.pathname + link.search === document.location.pathname + document.location.search || link.href.startsWith(\"#\");\n};\nvar linkOptsOut = function linkOptsOut(link) {\n  if (link.getAttribute(\"data-turbo-prefetch\") === \"false\") return true;\n  if (link.getAttribute(\"data-turbo\") === \"false\") return true;\n  var turboPrefetchParent = findClosestRecursively(link, \"[data-turbo-prefetch]\");\n  if (turboPrefetchParent && turboPrefetchParent.getAttribute(\"data-turbo-prefetch\") === \"false\") return true;\n  return false;\n};\nvar nonSafeLink = function nonSafeLink(link) {\n  var turboMethod = link.getAttribute(\"data-turbo-method\");\n  if (turboMethod && turboMethod.toLowerCase() !== \"get\") return true;\n  if (isUJS(link)) return true;\n  if (link.hasAttribute(\"data-turbo-confirm\")) return true;\n  if (link.hasAttribute(\"data-turbo-stream\")) return true;\n  return false;\n};\nvar isUJS = function isUJS(link) {\n  return link.hasAttribute(\"data-remote\") || link.hasAttribute(\"data-behavior\") || link.hasAttribute(\"data-confirm\") || link.hasAttribute(\"data-method\");\n};\nvar eventPrevented = function eventPrevented(link) {\n  var event = dispatch(\"turbo:before-prefetch\", {\n    target: link,\n    cancelable: true\n  });\n  return event.defaultPrevented;\n};\nvar _getActionForFormSubmission = /*#__PURE__*/_classPrivateFieldLooseKey(\"getActionForFormSubmission\");\nvar _getDefaultAction = /*#__PURE__*/_classPrivateFieldLooseKey(\"getDefaultAction\");\nvar Navigator = /*#__PURE__*/function () {\n  function Navigator(delegate) {\n    _classCallCheck(this, Navigator);\n    Object.defineProperty(this, _getDefaultAction, {\n      value: _getDefaultAction2\n    });\n    Object.defineProperty(this, _getActionForFormSubmission, {\n      value: _getActionForFormSubmission2\n    });\n    this.delegate = delegate;\n  }\n  return _createClass(Navigator, [{\n    key: \"proposeVisit\",\n    value: function proposeVisit(location) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) {\n        this.delegate.visitProposedToLocation(location, options);\n      }\n    }\n  }, {\n    key: \"startVisit\",\n    value: function startVisit(locatable, restorationIdentifier) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.stop();\n      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, _objectSpread({\n        referrer: this.location\n      }, options));\n      this.currentVisit.start();\n    }\n  }, {\n    key: \"submitForm\",\n    value: function submitForm(form, submitter) {\n      this.stop();\n      this.formSubmission = new FormSubmission(this, form, submitter, true);\n      this.formSubmission.start();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.formSubmission) {\n        this.formSubmission.stop();\n        delete this.formSubmission;\n      }\n      if (this.currentVisit) {\n        this.currentVisit.cancel();\n        delete this.currentVisit;\n      }\n    }\n  }, {\n    key: \"adapter\",\n    get: function get() {\n      return this.delegate.adapter;\n    }\n  }, {\n    key: \"view\",\n    get: function get() {\n      return this.delegate.view;\n    }\n  }, {\n    key: \"rootLocation\",\n    get: function get() {\n      return this.view.snapshot.rootLocation;\n    }\n  }, {\n    key: \"history\",\n    get: function get() {\n      return this.delegate.history;\n    }\n\n    // Form submission delegate\n  }, {\n    key: \"formSubmissionStarted\",\n    value: function formSubmissionStarted(formSubmission) {\n      // Not all adapters implement formSubmissionStarted\n      if (typeof this.adapter.formSubmissionStarted === \"function\") {\n        this.adapter.formSubmissionStarted(formSubmission);\n      }\n    }\n  }, {\n    key: \"formSubmissionSucceededWithResponse\",\n    value: function () {\n      var _formSubmissionSucceededWithResponse = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(formSubmission, fetchResponse) {\n        var responseHTML, shouldCacheSnapshot, statusCode, redirected, action, visitOptions;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              if (!(formSubmission == this.formSubmission)) {\n                _context21.next = 5;\n                break;\n              }\n              _context21.next = 3;\n              return fetchResponse.responseHTML;\n            case 3:\n              responseHTML = _context21.sent;\n              if (responseHTML) {\n                shouldCacheSnapshot = formSubmission.isSafe;\n                if (!shouldCacheSnapshot) {\n                  this.view.clearSnapshotCache();\n                }\n                statusCode = fetchResponse.statusCode, redirected = fetchResponse.redirected;\n                action = _classPrivateFieldLooseBase(this, _getActionForFormSubmission)[_getActionForFormSubmission](formSubmission, fetchResponse);\n                visitOptions = {\n                  action: action,\n                  shouldCacheSnapshot: shouldCacheSnapshot,\n                  response: {\n                    statusCode: statusCode,\n                    responseHTML: responseHTML,\n                    redirected: redirected\n                  }\n                };\n                this.proposeVisit(fetchResponse.location, visitOptions);\n              }\n            case 5:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function formSubmissionSucceededWithResponse(_x20, _x21) {\n        return _formSubmissionSucceededWithResponse.apply(this, arguments);\n      }\n      return formSubmissionSucceededWithResponse;\n    }()\n  }, {\n    key: \"formSubmissionFailedWithResponse\",\n    value: function () {\n      var _formSubmissionFailedWithResponse = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee22(formSubmission, fetchResponse) {\n        var responseHTML, snapshot;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.next = 2;\n              return fetchResponse.responseHTML;\n            case 2:\n              responseHTML = _context22.sent;\n              if (!responseHTML) {\n                _context22.next = 14;\n                break;\n              }\n              snapshot = PageSnapshot.fromHTMLString(responseHTML);\n              if (!fetchResponse.serverError) {\n                _context22.next = 10;\n                break;\n              }\n              _context22.next = 8;\n              return this.view.renderError(snapshot, this.currentVisit);\n            case 8:\n              _context22.next = 12;\n              break;\n            case 10:\n              _context22.next = 12;\n              return this.view.renderPage(snapshot, false, true, this.currentVisit);\n            case 12:\n              if (!snapshot.shouldPreserveScrollPosition) {\n                this.view.scrollToTop();\n              }\n              this.view.clearSnapshotCache();\n            case 14:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function formSubmissionFailedWithResponse(_x22, _x23) {\n        return _formSubmissionFailedWithResponse.apply(this, arguments);\n      }\n      return formSubmissionFailedWithResponse;\n    }()\n  }, {\n    key: \"formSubmissionErrored\",\n    value: function formSubmissionErrored(formSubmission, error) {\n      console.error(error);\n    }\n  }, {\n    key: \"formSubmissionFinished\",\n    value: function formSubmissionFinished(formSubmission) {\n      // Not all adapters implement formSubmissionFinished\n      if (typeof this.adapter.formSubmissionFinished === \"function\") {\n        this.adapter.formSubmissionFinished(formSubmission);\n      }\n    }\n\n    // Visit delegate\n  }, {\n    key: \"visitStarted\",\n    value: function visitStarted(visit) {\n      this.delegate.visitStarted(visit);\n    }\n  }, {\n    key: \"visitCompleted\",\n    value: function visitCompleted(visit) {\n      this.delegate.visitCompleted(visit);\n      delete this.currentVisit;\n    }\n  }, {\n    key: \"locationWithActionIsSamePage\",\n    value: function locationWithActionIsSamePage(location, action) {\n      var anchor = getAnchor(location);\n      var currentAnchor = getAnchor(this.view.lastRenderedLocation);\n      var isRestorationToTop = action === \"restore\" && typeof anchor === \"undefined\";\n      return action !== \"replace\" && getRequestURL(location) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);\n    }\n  }, {\n    key: \"visitScrolledToSamePageLocation\",\n    value: function visitScrolledToSamePageLocation(oldURL, newURL) {\n      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);\n    }\n\n    // Visits\n  }, {\n    key: \"location\",\n    get: function get() {\n      return this.history.location;\n    }\n  }, {\n    key: \"restorationIdentifier\",\n    get: function get() {\n      return this.history.restorationIdentifier;\n    }\n  }]);\n}();\nfunction _getActionForFormSubmission2(formSubmission, fetchResponse) {\n  var submitter = formSubmission.submitter,\n    formElement = formSubmission.formElement;\n  return getVisitAction(submitter, formElement) || _classPrivateFieldLooseBase(this, _getDefaultAction)[_getDefaultAction](fetchResponse);\n}\nfunction _getDefaultAction2(fetchResponse) {\n  var _this$location2;\n  var sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === ((_this$location2 = this.location) === null || _this$location2 === void 0 ? void 0 : _this$location2.href);\n  return sameLocationRedirect ? \"replace\" : \"advance\";\n}\nvar PageStage = {\n  initial: 0,\n  loading: 1,\n  interactive: 2,\n  complete: 3\n};\nvar PageObserver = /*#__PURE__*/function () {\n  function PageObserver(delegate) {\n    var _this33 = this;\n    _classCallCheck(this, PageObserver);\n    this.stage = PageStage.initial;\n    this.started = false;\n    this.interpretReadyState = function () {\n      var readyState = _this33.readyState;\n      if (readyState == \"interactive\") {\n        _this33.pageIsInteractive();\n      } else if (readyState == \"complete\") {\n        _this33.pageIsComplete();\n      }\n    };\n    this.pageWillUnload = function () {\n      _this33.delegate.pageWillUnload();\n    };\n    this.delegate = delegate;\n  }\n  return _createClass(PageObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        if (this.stage == PageStage.initial) {\n          this.stage = PageStage.loading;\n        }\n        document.addEventListener(\"readystatechange\", this.interpretReadyState, false);\n        addEventListener(\"pagehide\", this.pageWillUnload, false);\n        this.started = true;\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        document.removeEventListener(\"readystatechange\", this.interpretReadyState, false);\n        removeEventListener(\"pagehide\", this.pageWillUnload, false);\n        this.started = false;\n      }\n    }\n  }, {\n    key: \"pageIsInteractive\",\n    value: function pageIsInteractive() {\n      if (this.stage == PageStage.loading) {\n        this.stage = PageStage.interactive;\n        this.delegate.pageBecameInteractive();\n      }\n    }\n  }, {\n    key: \"pageIsComplete\",\n    value: function pageIsComplete() {\n      this.pageIsInteractive();\n      if (this.stage == PageStage.interactive) {\n        this.stage = PageStage.complete;\n        this.delegate.pageLoaded();\n      }\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return document.readyState;\n    }\n  }]);\n}();\nvar ScrollObserver = /*#__PURE__*/function () {\n  function ScrollObserver(delegate) {\n    var _this34 = this;\n    _classCallCheck(this, ScrollObserver);\n    this.started = false;\n    this.onScroll = function () {\n      _this34.updatePosition({\n        x: window.pageXOffset,\n        y: window.pageYOffset\n      });\n    };\n    this.delegate = delegate;\n  }\n  return _createClass(ScrollObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        addEventListener(\"scroll\", this.onScroll, false);\n        this.onScroll();\n        this.started = true;\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        removeEventListener(\"scroll\", this.onScroll, false);\n        this.started = false;\n      }\n    }\n  }, {\n    key: \"updatePosition\",\n    value:\n    // Private\n\n    function updatePosition(position) {\n      this.delegate.scrollPositionChanged(position);\n    }\n  }]);\n}();\nvar StreamMessageRenderer = /*#__PURE__*/function () {\n  function StreamMessageRenderer() {\n    _classCallCheck(this, StreamMessageRenderer);\n  }\n  return _createClass(StreamMessageRenderer, [{\n    key: \"render\",\n    value: function render(_ref22) {\n      var fragment = _ref22.fragment;\n      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), function () {\n        withAutofocusFromFragment(fragment, function () {\n          withPreservedFocus(function () {\n            document.documentElement.appendChild(fragment);\n          });\n        });\n      });\n    }\n\n    // Bardo delegate\n  }, {\n    key: \"enteringBardo\",\n    value: function enteringBardo(currentPermanentElement, newPermanentElement) {\n      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));\n    }\n  }, {\n    key: \"leavingBardo\",\n    value: function leavingBardo() {}\n  }]);\n}();\nfunction getPermanentElementMapForFragment(fragment) {\n  var permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);\n  var permanentElementMap = {};\n  var _iterator21 = _createForOfIteratorHelper(permanentElementsInDocument),\n    _step21;\n  try {\n    for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n      var permanentElementInDocument = _step21.value;\n      var _id6 = permanentElementInDocument.id;\n      var _iterator22 = _createForOfIteratorHelper(fragment.querySelectorAll(\"turbo-stream\")),\n        _step22;\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var streamElement = _step22.value;\n          var elementInStream = _getPermanentElementById(streamElement.templateElement.content, _id6);\n          if (elementInStream) {\n            permanentElementMap[_id6] = [permanentElementInDocument, elementInStream];\n          }\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n    }\n  } catch (err) {\n    _iterator21.e(err);\n  } finally {\n    _iterator21.f();\n  }\n  return permanentElementMap;\n}\nfunction withAutofocusFromFragment(_x24, _x25) {\n  return _withAutofocusFromFragment.apply(this, arguments);\n}\nfunction _withAutofocusFromFragment() {\n  _withAutofocusFromFragment = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee47(fragment, callback) {\n    var generatedID, turboStreams, elementWithAutofocus, willAutofocusId, hasNoActiveElement, elementToAutofocus;\n    return _regeneratorRuntime().wrap(function _callee47$(_context47) {\n      while (1) switch (_context47.prev = _context47.next) {\n        case 0:\n          generatedID = \"turbo-stream-autofocus-\".concat(uuid());\n          turboStreams = fragment.querySelectorAll(\"turbo-stream\");\n          elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);\n          willAutofocusId = null;\n          if (elementWithAutofocus) {\n            if (elementWithAutofocus.id) {\n              willAutofocusId = elementWithAutofocus.id;\n            } else {\n              willAutofocusId = generatedID;\n            }\n            elementWithAutofocus.id = willAutofocusId;\n          }\n          callback();\n          _context47.next = 8;\n          return nextRepaint();\n        case 8:\n          hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;\n          if (hasNoActiveElement && willAutofocusId) {\n            elementToAutofocus = document.getElementById(willAutofocusId);\n            if (elementIsFocusable(elementToAutofocus)) {\n              elementToAutofocus.focus();\n            }\n            if (elementToAutofocus && elementToAutofocus.id == generatedID) {\n              elementToAutofocus.removeAttribute(\"id\");\n            }\n          }\n        case 10:\n        case \"end\":\n          return _context47.stop();\n      }\n    }, _callee47);\n  }));\n  return _withAutofocusFromFragment.apply(this, arguments);\n}\nfunction withPreservedFocus(_x26) {\n  return _withPreservedFocus.apply(this, arguments);\n}\nfunction _withPreservedFocus() {\n  _withPreservedFocus = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee48(callback) {\n    var _yield$around, _yield$around2, activeElementBeforeRender, activeElementAfterRender, restoreFocusTo, elementToFocus;\n    return _regeneratorRuntime().wrap(function _callee48$(_context48) {\n      while (1) switch (_context48.prev = _context48.next) {\n        case 0:\n          _context48.next = 2;\n          return around(callback, function () {\n            return document.activeElement;\n          });\n        case 2:\n          _yield$around = _context48.sent;\n          _yield$around2 = _slicedToArray(_yield$around, 2);\n          activeElementBeforeRender = _yield$around2[0];\n          activeElementAfterRender = _yield$around2[1];\n          restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;\n          if (restoreFocusTo) {\n            elementToFocus = document.getElementById(restoreFocusTo);\n            if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {\n              elementToFocus.focus();\n            }\n          }\n        case 8:\n        case \"end\":\n          return _context48.stop();\n      }\n    }, _callee48);\n  }));\n  return _withPreservedFocus.apply(this, arguments);\n}\nfunction firstAutofocusableElementInStreams(nodeListOfStreamElements) {\n  var _iterator23 = _createForOfIteratorHelper(nodeListOfStreamElements),\n    _step23;\n  try {\n    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n      var streamElement = _step23.value;\n      var elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);\n      if (elementWithAutofocus) return elementWithAutofocus;\n    }\n  } catch (err) {\n    _iterator23.e(err);\n  } finally {\n    _iterator23.f();\n  }\n  return null;\n}\nvar _started = /*#__PURE__*/_classPrivateFieldLooseKey(\"started\");\nvar StreamObserver = /*#__PURE__*/function () {\n  function StreamObserver(delegate) {\n    var _this35 = this;\n    _classCallCheck(this, StreamObserver);\n    this.sources = new Set();\n    Object.defineProperty(this, _started, {\n      writable: true,\n      value: false\n    });\n    this.inspectFetchResponse = function (event) {\n      var response = fetchResponseFromEvent(event);\n      if (response && fetchResponseIsStream(response)) {\n        event.preventDefault();\n        _this35.receiveMessageResponse(response);\n      }\n    };\n    this.receiveMessageEvent = function (event) {\n      if (_classPrivateFieldLooseBase(_this35, _started)[_started] && typeof event.data == \"string\") {\n        _this35.receiveMessageHTML(event.data);\n      }\n    };\n    this.delegate = delegate;\n  }\n  return _createClass(StreamObserver, [{\n    key: \"start\",\n    value: function start() {\n      if (!_classPrivateFieldLooseBase(this, _started)[_started]) {\n        _classPrivateFieldLooseBase(this, _started)[_started] = true;\n        addEventListener(\"turbo:before-fetch-response\", this.inspectFetchResponse, false);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (_classPrivateFieldLooseBase(this, _started)[_started]) {\n        _classPrivateFieldLooseBase(this, _started)[_started] = false;\n        removeEventListener(\"turbo:before-fetch-response\", this.inspectFetchResponse, false);\n      }\n    }\n  }, {\n    key: \"connectStreamSource\",\n    value: function connectStreamSource(source) {\n      if (!this.streamSourceIsConnected(source)) {\n        this.sources.add(source);\n        source.addEventListener(\"message\", this.receiveMessageEvent, false);\n      }\n    }\n  }, {\n    key: \"disconnectStreamSource\",\n    value: function disconnectStreamSource(source) {\n      if (this.streamSourceIsConnected(source)) {\n        this.sources[\"delete\"](source);\n        source.removeEventListener(\"message\", this.receiveMessageEvent, false);\n      }\n    }\n  }, {\n    key: \"streamSourceIsConnected\",\n    value: function streamSourceIsConnected(source) {\n      return this.sources.has(source);\n    }\n  }, {\n    key: \"receiveMessageResponse\",\n    value: function () {\n      var _receiveMessageResponse = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee23(response) {\n        var html;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.next = 2;\n              return response.responseHTML;\n            case 2:\n              html = _context23.sent;\n              if (html) {\n                this.receiveMessageHTML(html);\n              }\n            case 4:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function receiveMessageResponse(_x27) {\n        return _receiveMessageResponse.apply(this, arguments);\n      }\n      return receiveMessageResponse;\n    }()\n  }, {\n    key: \"receiveMessageHTML\",\n    value: function receiveMessageHTML(html) {\n      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));\n    }\n  }]);\n}();\nfunction fetchResponseFromEvent(event) {\n  var _event$detail;\n  var fetchResponse = (_event$detail = event.detail) === null || _event$detail === void 0 ? void 0 : _event$detail.fetchResponse;\n  if (fetchResponse instanceof FetchResponse) {\n    return fetchResponse;\n  }\n}\nfunction fetchResponseIsStream(response) {\n  var _response$contentType;\n  var contentType = (_response$contentType = response.contentType) !== null && _response$contentType !== void 0 ? _response$contentType : \"\";\n  return contentType.startsWith(StreamMessage.contentType);\n}\nvar ErrorRenderer = /*#__PURE__*/function (_Renderer3) {\n  function ErrorRenderer() {\n    _classCallCheck(this, ErrorRenderer);\n    return _callSuper(this, ErrorRenderer, arguments);\n  }\n  _inherits(ErrorRenderer, _Renderer3);\n  return _createClass(ErrorRenderer, [{\n    key: \"render\",\n    value: function () {\n      var _render4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              this.replaceHeadAndBody();\n              this.activateScriptElements();\n            case 2:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function render() {\n        return _render4.apply(this, arguments);\n      }\n      return render;\n    }()\n  }, {\n    key: \"replaceHeadAndBody\",\n    value: function replaceHeadAndBody() {\n      var _document = document,\n        documentElement = _document.documentElement,\n        head = _document.head;\n      documentElement.replaceChild(this.newHead, head);\n      this.renderElement(this.currentElement, this.newElement);\n    }\n  }, {\n    key: \"activateScriptElements\",\n    value: function activateScriptElements() {\n      var _iterator24 = _createForOfIteratorHelper(this.scriptElements),\n        _step24;\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var replaceableElement = _step24.value;\n          var parentNode = replaceableElement.parentNode;\n          if (parentNode) {\n            var element = activateScriptElement(replaceableElement);\n            parentNode.replaceChild(element, replaceableElement);\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n    }\n  }, {\n    key: \"newHead\",\n    get: function get() {\n      return this.newSnapshot.headSnapshot.element;\n    }\n  }, {\n    key: \"scriptElements\",\n    get: function get() {\n      return document.documentElement.querySelectorAll(\"script\");\n    }\n  }], [{\n    key: \"renderElement\",\n    value: function renderElement(currentElement, newElement) {\n      var _document2 = document,\n        documentElement = _document2.documentElement,\n        body = _document2.body;\n      documentElement.replaceChild(newElement, body);\n    }\n  }]);\n}(Renderer);\nvar _setLanguage = /*#__PURE__*/_classPrivateFieldLooseKey(\"setLanguage\");\nvar PageRenderer = /*#__PURE__*/function (_Renderer4) {\n  function PageRenderer() {\n    var _this36;\n    _classCallCheck(this, PageRenderer);\n    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      args[_key9] = arguments[_key9];\n    }\n    _this36 = _callSuper(this, PageRenderer, [].concat(args));\n    Object.defineProperty(_this36, _setLanguage, {\n      value: _setLanguage2\n    });\n    return _this36;\n  }\n  _inherits(PageRenderer, _Renderer4);\n  return _createClass(PageRenderer, [{\n    key: \"shouldRender\",\n    get: function get() {\n      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;\n    }\n  }, {\n    key: \"reloadReason\",\n    get: function get() {\n      if (!this.newSnapshot.isVisitable) {\n        return {\n          reason: \"turbo_visit_control_is_reload\"\n        };\n      }\n      if (!this.trackedElementsAreIdentical) {\n        return {\n          reason: \"tracked_element_mismatch\"\n        };\n      }\n    }\n  }, {\n    key: \"prepareToRender\",\n    value: function () {\n      var _prepareToRender = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              _classPrivateFieldLooseBase(this, _setLanguage)[_setLanguage]();\n              _context25.next = 3;\n              return this.mergeHead();\n            case 3:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function prepareToRender() {\n        return _prepareToRender.apply(this, arguments);\n      }\n      return prepareToRender;\n    }()\n  }, {\n    key: \"render\",\n    value: function () {\n      var _render5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              if (!this.willRender) {\n                _context26.next = 3;\n                break;\n              }\n              _context26.next = 3;\n              return this.replaceBody();\n            case 3:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n      function render() {\n        return _render5.apply(this, arguments);\n      }\n      return render;\n    }()\n  }, {\n    key: \"finishRendering\",\n    value: function finishRendering() {\n      _superPropGet(PageRenderer, \"finishRendering\", this, 3)([]);\n      if (!this.isPreview) {\n        this.focusFirstAutofocusableElement();\n      }\n    }\n  }, {\n    key: \"currentHeadSnapshot\",\n    get: function get() {\n      return this.currentSnapshot.headSnapshot;\n    }\n  }, {\n    key: \"newHeadSnapshot\",\n    get: function get() {\n      return this.newSnapshot.headSnapshot;\n    }\n  }, {\n    key: \"newElement\",\n    get: function get() {\n      return this.newSnapshot.element;\n    }\n  }, {\n    key: \"mergeHead\",\n    value: function () {\n      var _mergeHead = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var mergedHeadElements, newStylesheetElements;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              mergedHeadElements = this.mergeProvisionalElements();\n              newStylesheetElements = this.copyNewHeadStylesheetElements();\n              this.copyNewHeadScriptElements();\n              _context27.next = 5;\n              return mergedHeadElements;\n            case 5:\n              _context27.next = 7;\n              return newStylesheetElements;\n            case 7:\n              if (this.willRender) {\n                this.removeUnusedDynamicStylesheetElements();\n              }\n            case 8:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n      function mergeHead() {\n        return _mergeHead.apply(this, arguments);\n      }\n      return mergeHead;\n    }()\n  }, {\n    key: \"replaceBody\",\n    value: function () {\n      var _replaceBody = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n        var _this37 = this;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              _context29.next = 2;\n              return this.preservingPermanentElements(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n                return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n                  while (1) switch (_context28.prev = _context28.next) {\n                    case 0:\n                      _this37.activateNewBody();\n                      _context28.next = 3;\n                      return _this37.assignNewBody();\n                    case 3:\n                    case \"end\":\n                      return _context28.stop();\n                  }\n                }, _callee28);\n              })));\n            case 2:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n      function replaceBody() {\n        return _replaceBody.apply(this, arguments);\n      }\n      return replaceBody;\n    }()\n  }, {\n    key: \"trackedElementsAreIdentical\",\n    get: function get() {\n      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;\n    }\n  }, {\n    key: \"copyNewHeadStylesheetElements\",\n    value: function () {\n      var _copyNewHeadStylesheetElements = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        var loadingElements, _iterator25, _step25, element;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              loadingElements = [];\n              _iterator25 = _createForOfIteratorHelper(this.newHeadStylesheetElements);\n              try {\n                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                  element = _step25.value;\n                  loadingElements.push(waitForLoad(element));\n                  document.head.appendChild(element);\n                }\n              } catch (err) {\n                _iterator25.e(err);\n              } finally {\n                _iterator25.f();\n              }\n              _context30.next = 5;\n              return Promise.all(loadingElements);\n            case 5:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n      function copyNewHeadStylesheetElements() {\n        return _copyNewHeadStylesheetElements.apply(this, arguments);\n      }\n      return copyNewHeadStylesheetElements;\n    }()\n  }, {\n    key: \"copyNewHeadScriptElements\",\n    value: function copyNewHeadScriptElements() {\n      var _iterator26 = _createForOfIteratorHelper(this.newHeadScriptElements),\n        _step26;\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var element = _step26.value;\n          document.head.appendChild(activateScriptElement(element));\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n    }\n  }, {\n    key: \"removeUnusedDynamicStylesheetElements\",\n    value: function removeUnusedDynamicStylesheetElements() {\n      var _iterator27 = _createForOfIteratorHelper(this.unusedDynamicStylesheetElements),\n        _step27;\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var element = _step27.value;\n          document.head.removeChild(element);\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n    }\n  }, {\n    key: \"mergeProvisionalElements\",\n    value: function () {\n      var _mergeProvisionalElements = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {\n        var newHeadElements, _iterator28, _step28, element, _iterator29, _step29, _element2;\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) switch (_context31.prev = _context31.next) {\n            case 0:\n              newHeadElements = _toConsumableArray(this.newHeadProvisionalElements);\n              _iterator28 = _createForOfIteratorHelper(this.currentHeadProvisionalElements);\n              try {\n                for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                  element = _step28.value;\n                  if (!this.isCurrentElementInElementList(element, newHeadElements)) {\n                    document.head.removeChild(element);\n                  }\n                }\n              } catch (err) {\n                _iterator28.e(err);\n              } finally {\n                _iterator28.f();\n              }\n              _iterator29 = _createForOfIteratorHelper(newHeadElements);\n              try {\n                for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                  _element2 = _step29.value;\n                  document.head.appendChild(_element2);\n                }\n              } catch (err) {\n                _iterator29.e(err);\n              } finally {\n                _iterator29.f();\n              }\n            case 5:\n            case \"end\":\n              return _context31.stop();\n          }\n        }, _callee31, this);\n      }));\n      function mergeProvisionalElements() {\n        return _mergeProvisionalElements.apply(this, arguments);\n      }\n      return mergeProvisionalElements;\n    }()\n  }, {\n    key: \"isCurrentElementInElementList\",\n    value: function isCurrentElementInElementList(element, elementList) {\n      var _iterator30 = _createForOfIteratorHelper(elementList.entries()),\n        _step30;\n      try {\n        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n          var _ref24 = _step30.value;\n          var _ref25 = _slicedToArray(_ref24, 2);\n          var index = _ref25[0];\n          var newElement = _ref25[1];\n          // if title element...\n          if (element.tagName == \"TITLE\") {\n            if (newElement.tagName != \"TITLE\") {\n              continue;\n            }\n            if (element.innerHTML == newElement.innerHTML) {\n              elementList.splice(index, 1);\n              return true;\n            }\n          }\n\n          // if any other element...\n          if (newElement.isEqualNode(element)) {\n            elementList.splice(index, 1);\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"removeCurrentHeadProvisionalElements\",\n    value: function removeCurrentHeadProvisionalElements() {\n      var _iterator31 = _createForOfIteratorHelper(this.currentHeadProvisionalElements),\n        _step31;\n      try {\n        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n          var element = _step31.value;\n          document.head.removeChild(element);\n        }\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n    }\n  }, {\n    key: \"copyNewHeadProvisionalElements\",\n    value: function copyNewHeadProvisionalElements() {\n      var _iterator32 = _createForOfIteratorHelper(this.newHeadProvisionalElements),\n        _step32;\n      try {\n        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n          var element = _step32.value;\n          document.head.appendChild(element);\n        }\n      } catch (err) {\n        _iterator32.e(err);\n      } finally {\n        _iterator32.f();\n      }\n    }\n  }, {\n    key: \"activateNewBody\",\n    value: function activateNewBody() {\n      document.adoptNode(this.newElement);\n      this.activateNewBodyScriptElements();\n    }\n  }, {\n    key: \"activateNewBodyScriptElements\",\n    value: function activateNewBodyScriptElements() {\n      var _iterator33 = _createForOfIteratorHelper(this.newBodyScriptElements),\n        _step33;\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var inertScriptElement = _step33.value;\n          var activatedScriptElement = activateScriptElement(inertScriptElement);\n          inertScriptElement.replaceWith(activatedScriptElement);\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n    }\n  }, {\n    key: \"assignNewBody\",\n    value: function () {\n      var _assignNewBody = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) switch (_context32.prev = _context32.next) {\n            case 0:\n              _context32.next = 2;\n              return this.renderElement(this.currentElement, this.newElement);\n            case 2:\n            case \"end\":\n              return _context32.stop();\n          }\n        }, _callee32, this);\n      }));\n      function assignNewBody() {\n        return _assignNewBody.apply(this, arguments);\n      }\n      return assignNewBody;\n    }()\n  }, {\n    key: \"unusedDynamicStylesheetElements\",\n    get: function get() {\n      return this.oldHeadStylesheetElements.filter(function (element) {\n        return element.getAttribute(\"data-turbo-track\") === \"dynamic\";\n      });\n    }\n  }, {\n    key: \"oldHeadStylesheetElements\",\n    get: function get() {\n      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);\n    }\n  }, {\n    key: \"newHeadStylesheetElements\",\n    get: function get() {\n      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);\n    }\n  }, {\n    key: \"newHeadScriptElements\",\n    get: function get() {\n      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);\n    }\n  }, {\n    key: \"currentHeadProvisionalElements\",\n    get: function get() {\n      return this.currentHeadSnapshot.provisionalElements;\n    }\n  }, {\n    key: \"newHeadProvisionalElements\",\n    get: function get() {\n      return this.newHeadSnapshot.provisionalElements;\n    }\n  }, {\n    key: \"newBodyScriptElements\",\n    get: function get() {\n      return this.newElement.querySelectorAll(\"script\");\n    }\n  }], [{\n    key: \"renderElement\",\n    value: function renderElement(currentElement, newElement) {\n      if (document.body && newElement instanceof HTMLBodyElement) {\n        document.body.replaceWith(newElement);\n      } else {\n        document.documentElement.appendChild(newElement);\n      }\n    }\n  }]);\n}(Renderer);\nfunction _setLanguage2() {\n  var documentElement = this.currentSnapshot.documentElement;\n  var lang = this.newSnapshot.lang;\n  if (lang) {\n    documentElement.setAttribute(\"lang\", lang);\n  } else {\n    documentElement.removeAttribute(\"lang\");\n  }\n}\nvar MorphingPageRenderer = /*#__PURE__*/function (_PageRenderer2) {\n  function MorphingPageRenderer() {\n    _classCallCheck(this, MorphingPageRenderer);\n    return _callSuper(this, MorphingPageRenderer, arguments);\n  }\n  _inherits(MorphingPageRenderer, _PageRenderer2);\n  return _createClass(MorphingPageRenderer, [{\n    key: \"preservingPermanentElements\",\n    value: function () {\n      var _preservingPermanentElements4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee33(callback) {\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              _context33.next = 2;\n              return callback();\n            case 2:\n              return _context33.abrupt(\"return\", _context33.sent);\n            case 3:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee33);\n      }));\n      function preservingPermanentElements(_x28) {\n        return _preservingPermanentElements4.apply(this, arguments);\n      }\n      return preservingPermanentElements;\n    }()\n  }, {\n    key: \"renderMethod\",\n    get: function get() {\n      return \"morph\";\n    }\n  }, {\n    key: \"shouldAutofocus\",\n    get: function get() {\n      return false;\n    }\n  }], [{\n    key: \"renderElement\",\n    value: function renderElement(currentElement, newElement) {\n      morphElements(currentElement, newElement, {\n        callbacks: {\n          beforeNodeMorphed: function beforeNodeMorphed(element) {\n            return !canRefreshFrame(element);\n          }\n        }\n      });\n      var _iterator34 = _createForOfIteratorHelper(currentElement.querySelectorAll(\"turbo-frame\")),\n        _step34;\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var frame = _step34.value;\n          if (canRefreshFrame(frame)) frame.reload();\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n      dispatch(\"turbo:morph\", {\n        detail: {\n          currentElement: currentElement,\n          newElement: newElement\n        }\n      });\n    }\n  }]);\n}(PageRenderer);\nfunction canRefreshFrame(frame) {\n  return frame instanceof FrameElement && frame.src && frame.refresh === \"morph\" && !frame.closest(\"[data-turbo-permanent]\");\n}\nvar SnapshotCache = /*#__PURE__*/function () {\n  function SnapshotCache(size) {\n    _classCallCheck(this, SnapshotCache);\n    this.keys = [];\n    this.snapshots = {};\n    this.size = size;\n  }\n  return _createClass(SnapshotCache, [{\n    key: \"has\",\n    value: function has(location) {\n      return toCacheKey(location) in this.snapshots;\n    }\n  }, {\n    key: \"get\",\n    value: function get(location) {\n      if (this.has(location)) {\n        var snapshot = this.read(location);\n        this.touch(location);\n        return snapshot;\n      }\n    }\n  }, {\n    key: \"put\",\n    value: function put(location, snapshot) {\n      this.write(location, snapshot);\n      this.touch(location);\n      return snapshot;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.snapshots = {};\n    }\n\n    // Private\n  }, {\n    key: \"read\",\n    value: function read(location) {\n      return this.snapshots[toCacheKey(location)];\n    }\n  }, {\n    key: \"write\",\n    value: function write(location, snapshot) {\n      this.snapshots[toCacheKey(location)] = snapshot;\n    }\n  }, {\n    key: \"touch\",\n    value: function touch(location) {\n      var key = toCacheKey(location);\n      var index = this.keys.indexOf(key);\n      if (index > -1) this.keys.splice(index, 1);\n      this.keys.unshift(key);\n      this.trim();\n    }\n  }, {\n    key: \"trim\",\n    value: function trim() {\n      var _iterator35 = _createForOfIteratorHelper(this.keys.splice(this.size)),\n        _step35;\n      try {\n        for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n          var key = _step35.value;\n          delete this.snapshots[key];\n        }\n      } catch (err) {\n        _iterator35.e(err);\n      } finally {\n        _iterator35.f();\n      }\n    }\n  }]);\n}();\nvar PageView = /*#__PURE__*/function (_View3) {\n  function PageView() {\n    var _this38;\n    _classCallCheck(this, PageView);\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n    _this38 = _callSuper(this, PageView, [].concat(args));\n    _this38.snapshotCache = new SnapshotCache(10);\n    _this38.lastRenderedLocation = new URL(location.href);\n    _this38.forceReloaded = false;\n    return _this38;\n  }\n  _inherits(PageView, _View3);\n  return _createClass(PageView, [{\n    key: \"shouldTransitionTo\",\n    value: function shouldTransitionTo(newSnapshot) {\n      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;\n    }\n  }, {\n    key: \"renderPage\",\n    value: function renderPage(snapshot) {\n      var isPreview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var willRender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var visit = arguments.length > 3 ? arguments[3] : undefined;\n      var shouldMorphPage = this.isPageRefresh(visit) && this.snapshot.shouldMorphPage;\n      var rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;\n      var renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);\n      if (!renderer.shouldRender) {\n        this.forceReloaded = true;\n      } else {\n        visit === null || visit === void 0 ? void 0 : visit.changeHistory();\n      }\n      return this.render(renderer);\n    }\n  }, {\n    key: \"renderError\",\n    value: function renderError(snapshot, visit) {\n      visit === null || visit === void 0 ? void 0 : visit.changeHistory();\n      var renderer = new ErrorRenderer(this.snapshot, snapshot, false);\n      return this.render(renderer);\n    }\n  }, {\n    key: \"clearSnapshotCache\",\n    value: function clearSnapshotCache() {\n      this.snapshotCache.clear();\n    }\n  }, {\n    key: \"cacheSnapshot\",\n    value: function () {\n      var _cacheSnapshot = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {\n        var snapshot,\n          _location4,\n          cachedSnapshot,\n          _args34 = arguments;\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              snapshot = _args34.length > 0 && _args34[0] !== undefined ? _args34[0] : this.snapshot;\n              if (!snapshot.isCacheable) {\n                _context34.next = 9;\n                break;\n              }\n              this.delegate.viewWillCacheSnapshot();\n              _location4 = this.lastRenderedLocation;\n              _context34.next = 6;\n              return nextEventLoopTick();\n            case 6:\n              cachedSnapshot = snapshot.clone();\n              this.snapshotCache.put(_location4, cachedSnapshot);\n              return _context34.abrupt(\"return\", cachedSnapshot);\n            case 9:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee34, this);\n      }));\n      function cacheSnapshot() {\n        return _cacheSnapshot.apply(this, arguments);\n      }\n      return cacheSnapshot;\n    }()\n  }, {\n    key: \"getCachedSnapshotForLocation\",\n    value: function getCachedSnapshotForLocation(location) {\n      return this.snapshotCache.get(location);\n    }\n  }, {\n    key: \"isPageRefresh\",\n    value: function isPageRefresh(visit) {\n      return !visit || this.lastRenderedLocation.pathname === visit.location.pathname && visit.action === \"replace\";\n    }\n  }, {\n    key: \"shouldPreserveScrollPosition\",\n    value: function shouldPreserveScrollPosition(visit) {\n      return this.isPageRefresh(visit) && this.snapshot.shouldPreserveScrollPosition;\n    }\n  }, {\n    key: \"snapshot\",\n    get: function get() {\n      return PageSnapshot.fromElement(this.element);\n    }\n  }]);\n}(View);\nvar _preloadAll = /*#__PURE__*/_classPrivateFieldLooseKey(\"preloadAll\");\nvar Preloader = /*#__PURE__*/function () {\n  function Preloader(delegate, snapshotCache) {\n    var _this39 = this;\n    _classCallCheck(this, Preloader);\n    this.selector = \"a[data-turbo-preload]\";\n    Object.defineProperty(this, _preloadAll, {\n      writable: true,\n      value: function value() {\n        _this39.preloadOnLoadLinksForView(document.body);\n      }\n    });\n    this.delegate = delegate;\n    this.snapshotCache = snapshotCache;\n  }\n  return _createClass(Preloader, [{\n    key: \"start\",\n    value: function start() {\n      if (document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", _classPrivateFieldLooseBase(this, _preloadAll)[_preloadAll]);\n      } else {\n        this.preloadOnLoadLinksForView(document.body);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      document.removeEventListener(\"DOMContentLoaded\", _classPrivateFieldLooseBase(this, _preloadAll)[_preloadAll]);\n    }\n  }, {\n    key: \"preloadOnLoadLinksForView\",\n    value: function preloadOnLoadLinksForView(element) {\n      var _iterator36 = _createForOfIteratorHelper(element.querySelectorAll(this.selector)),\n        _step36;\n      try {\n        for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n          var link = _step36.value;\n          if (this.delegate.shouldPreloadLink(link)) {\n            this.preloadURL(link);\n          }\n        }\n      } catch (err) {\n        _iterator36.e(err);\n      } finally {\n        _iterator36.f();\n      }\n    }\n  }, {\n    key: \"preloadURL\",\n    value: function () {\n      var _preloadURL = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee35(link) {\n        var location, fetchRequest;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              location = new URL(link.href);\n              if (!this.snapshotCache.has(location)) {\n                _context35.next = 3;\n                break;\n              }\n              return _context35.abrupt(\"return\");\n            case 3:\n              fetchRequest = new FetchRequest(this, FetchMethod.get, location, new URLSearchParams(), link);\n              _context35.next = 6;\n              return fetchRequest.perform();\n            case 6:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee35, this);\n      }));\n      function preloadURL(_x29) {\n        return _preloadURL.apply(this, arguments);\n      }\n      return preloadURL;\n    }() // Fetch request delegate\n  }, {\n    key: \"prepareRequest\",\n    value: function prepareRequest(fetchRequest) {\n      fetchRequest.headers[\"X-Sec-Purpose\"] = \"prefetch\";\n    }\n  }, {\n    key: \"requestSucceededWithResponse\",\n    value: function () {\n      var _requestSucceededWithResponse2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee36(fetchRequest, fetchResponse) {\n        var responseHTML, snapshot;\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) switch (_context36.prev = _context36.next) {\n            case 0:\n              _context36.prev = 0;\n              _context36.next = 3;\n              return fetchResponse.responseHTML;\n            case 3:\n              responseHTML = _context36.sent;\n              snapshot = PageSnapshot.fromHTMLString(responseHTML);\n              this.snapshotCache.put(fetchRequest.url, snapshot);\n              _context36.next = 10;\n              break;\n            case 8:\n              _context36.prev = 8;\n              _context36.t0 = _context36[\"catch\"](0);\n            case 10:\n            case \"end\":\n              return _context36.stop();\n          }\n        }, _callee36, this, [[0, 8]]);\n      }));\n      function requestSucceededWithResponse(_x30, _x31) {\n        return _requestSucceededWithResponse2.apply(this, arguments);\n      }\n      return requestSucceededWithResponse;\n    }()\n  }, {\n    key: \"requestStarted\",\n    value: function requestStarted(fetchRequest) {}\n  }, {\n    key: \"requestErrored\",\n    value: function requestErrored(fetchRequest) {}\n  }, {\n    key: \"requestFinished\",\n    value: function requestFinished(fetchRequest) {}\n  }, {\n    key: \"requestPreventedHandlingResponse\",\n    value: function requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}\n  }, {\n    key: \"requestFailedWithResponse\",\n    value: function requestFailedWithResponse(fetchRequest, fetchResponse) {}\n  }]);\n}();\nvar _setCacheControl = /*#__PURE__*/_classPrivateFieldLooseKey(\"setCacheControl\");\nvar Cache = /*#__PURE__*/function () {\n  function Cache(session) {\n    _classCallCheck(this, Cache);\n    Object.defineProperty(this, _setCacheControl, {\n      value: _setCacheControl2\n    });\n    this.session = session;\n  }\n  return _createClass(Cache, [{\n    key: \"clear\",\n    value: function clear() {\n      this.session.clearCache();\n    }\n  }, {\n    key: \"resetCacheControl\",\n    value: function resetCacheControl() {\n      _classPrivateFieldLooseBase(this, _setCacheControl)[_setCacheControl](\"\");\n    }\n  }, {\n    key: \"exemptPageFromCache\",\n    value: function exemptPageFromCache() {\n      _classPrivateFieldLooseBase(this, _setCacheControl)[_setCacheControl](\"no-cache\");\n    }\n  }, {\n    key: \"exemptPageFromPreview\",\n    value: function exemptPageFromPreview() {\n      _classPrivateFieldLooseBase(this, _setCacheControl)[_setCacheControl](\"no-preview\");\n    }\n  }]);\n}();\nfunction _setCacheControl2(value) {\n  setMetaContent(\"turbo-cache-control\", value);\n}\nvar _pageRefreshDebouncePeriod = /*#__PURE__*/_classPrivateFieldLooseKey(\"pageRefreshDebouncePeriod\");\nvar Session = /*#__PURE__*/function () {\n  function Session(recentRequests) {\n    _classCallCheck(this, Session);\n    this.navigator = new Navigator(this);\n    this.history = new History(this);\n    this.view = new PageView(this, document.documentElement);\n    this.adapter = new BrowserAdapter(this);\n    this.pageObserver = new PageObserver(this);\n    this.cacheObserver = new CacheObserver();\n    this.linkPrefetchObserver = new LinkPrefetchObserver(this, document);\n    this.linkClickObserver = new LinkClickObserver(this, window);\n    this.formSubmitObserver = new FormSubmitObserver(this, document);\n    this.scrollObserver = new ScrollObserver(this);\n    this.streamObserver = new StreamObserver(this);\n    this.formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);\n    this.frameRedirector = new FrameRedirector(this, document.documentElement);\n    this.streamMessageRenderer = new StreamMessageRenderer();\n    this.cache = new Cache(this);\n    this.enabled = true;\n    this.started = false;\n    Object.defineProperty(this, _pageRefreshDebouncePeriod, {\n      writable: true,\n      value: 150\n    });\n    this.recentRequests = recentRequests;\n    this.preloader = new Preloader(this, this.view.snapshotCache);\n    this.debouncedRefresh = this.refresh;\n    this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;\n  }\n  return _createClass(Session, [{\n    key: \"start\",\n    value: function start() {\n      if (!this.started) {\n        this.pageObserver.start();\n        this.cacheObserver.start();\n        this.linkPrefetchObserver.start();\n        this.formLinkClickObserver.start();\n        this.linkClickObserver.start();\n        this.formSubmitObserver.start();\n        this.scrollObserver.start();\n        this.streamObserver.start();\n        this.frameRedirector.start();\n        this.history.start();\n        this.preloader.start();\n        this.started = true;\n        this.enabled = true;\n      }\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.pageObserver.stop();\n        this.cacheObserver.stop();\n        this.linkPrefetchObserver.stop();\n        this.formLinkClickObserver.stop();\n        this.linkClickObserver.stop();\n        this.formSubmitObserver.stop();\n        this.scrollObserver.stop();\n        this.streamObserver.stop();\n        this.frameRedirector.stop();\n        this.history.stop();\n        this.preloader.stop();\n        this.started = false;\n      }\n    }\n  }, {\n    key: \"registerAdapter\",\n    value: function registerAdapter(adapter) {\n      this.adapter = adapter;\n    }\n  }, {\n    key: \"visit\",\n    value: function visit(location) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var frameElement = options.frame ? document.getElementById(options.frame) : null;\n      if (frameElement instanceof FrameElement) {\n        var action = options.action || getVisitAction(frameElement);\n        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);\n        frameElement.src = location.toString();\n      } else {\n        this.navigator.proposeVisit(expandURL(location), options);\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh(url, requestId) {\n      var isRecentRequest = requestId && this.recentRequests.has(requestId);\n      if (!isRecentRequest && !this.navigator.currentVisit) {\n        this.visit(url, {\n          action: \"replace\",\n          shouldCacheSnapshot: false\n        });\n      }\n    }\n  }, {\n    key: \"connectStreamSource\",\n    value: function connectStreamSource(source) {\n      this.streamObserver.connectStreamSource(source);\n    }\n  }, {\n    key: \"disconnectStreamSource\",\n    value: function disconnectStreamSource(source) {\n      this.streamObserver.disconnectStreamSource(source);\n    }\n  }, {\n    key: \"renderStreamMessage\",\n    value: function renderStreamMessage(message) {\n      this.streamMessageRenderer.render(StreamMessage.wrap(message));\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this.view.clearSnapshotCache();\n    }\n  }, {\n    key: \"setProgressBarDelay\",\n    value: function setProgressBarDelay(delay) {\n      console.warn(\"Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`\");\n      this.progressBarDelay = delay;\n    }\n  }, {\n    key: \"progressBarDelay\",\n    get: function get() {\n      return config.drive.progressBarDelay;\n    },\n    set: function set(delay) {\n      config.drive.progressBarDelay = delay;\n    }\n  }, {\n    key: \"drive\",\n    get: function get() {\n      return config.drive.enabled;\n    },\n    set: function set(value) {\n      config.drive.enabled = value;\n    }\n  }, {\n    key: \"formMode\",\n    get: function get() {\n      return config.forms.mode;\n    },\n    set: function set(value) {\n      config.forms.mode = value;\n    }\n  }, {\n    key: \"location\",\n    get: function get() {\n      return this.history.location;\n    }\n  }, {\n    key: \"restorationIdentifier\",\n    get: function get() {\n      return this.history.restorationIdentifier;\n    }\n  }, {\n    key: \"pageRefreshDebouncePeriod\",\n    get: function get() {\n      return _classPrivateFieldLooseBase(this, _pageRefreshDebouncePeriod)[_pageRefreshDebouncePeriod];\n    },\n    set: function set(value) {\n      this.refresh = debounce(this.debouncedRefresh.bind(this), value);\n      _classPrivateFieldLooseBase(this, _pageRefreshDebouncePeriod)[_pageRefreshDebouncePeriod] = value;\n    }\n\n    // Preloader delegate\n  }, {\n    key: \"shouldPreloadLink\",\n    value: function shouldPreloadLink(element) {\n      var isUnsafe = element.hasAttribute(\"data-turbo-method\");\n      var isStream = element.hasAttribute(\"data-turbo-stream\");\n      var frameTarget = element.getAttribute(\"data-turbo-frame\");\n      var frame = frameTarget == \"_top\" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, \"turbo-frame:not([disabled])\");\n      if (isUnsafe || isStream || frame instanceof FrameElement) {\n        return false;\n      } else {\n        var _location5 = new URL(element.href);\n        return this.elementIsNavigatable(element) && locationIsVisitable(_location5, this.snapshot.rootLocation);\n      }\n    }\n\n    // History delegate\n  }, {\n    key: \"historyPoppedToLocationWithRestorationIdentifierAndDirection\",\n    value: function historyPoppedToLocationWithRestorationIdentifierAndDirection(location, restorationIdentifier, direction) {\n      if (this.enabled) {\n        this.navigator.startVisit(location, restorationIdentifier, {\n          action: \"restore\",\n          historyChanged: true,\n          direction: direction\n        });\n      } else {\n        this.adapter.pageInvalidated({\n          reason: \"turbo_disabled\"\n        });\n      }\n    }\n\n    // Scroll observer delegate\n  }, {\n    key: \"scrollPositionChanged\",\n    value: function scrollPositionChanged(position) {\n      this.history.updateRestorationData({\n        scrollPosition: position\n      });\n    }\n\n    // Form click observer delegate\n  }, {\n    key: \"willSubmitFormLinkToLocation\",\n    value: function willSubmitFormLinkToLocation(link, location) {\n      return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation);\n    }\n  }, {\n    key: \"submittedFormLinkToLocation\",\n    value: function submittedFormLinkToLocation() {}\n\n    // Link hover observer delegate\n  }, {\n    key: \"canPrefetchRequestToLocation\",\n    value: function canPrefetchRequestToLocation(link, location) {\n      return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation);\n    }\n\n    // Link click observer delegate\n  }, {\n    key: \"willFollowLinkToLocation\",\n    value: function willFollowLinkToLocation(link, location, event) {\n      return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location, event);\n    }\n  }, {\n    key: \"followedLinkToLocation\",\n    value: function followedLinkToLocation(link, location) {\n      var action = this.getActionForLink(link);\n      var acceptsStreamResponse = link.hasAttribute(\"data-turbo-stream\");\n      this.visit(location.href, {\n        action: action,\n        acceptsStreamResponse: acceptsStreamResponse\n      });\n    }\n\n    // Navigator delegate\n  }, {\n    key: \"allowsVisitingLocationWithAction\",\n    value: function allowsVisitingLocationWithAction(location, action) {\n      return this.locationWithActionIsSamePage(location, action) || this.applicationAllowsVisitingLocation(location);\n    }\n  }, {\n    key: \"visitProposedToLocation\",\n    value: function visitProposedToLocation(location, options) {\n      extendURLWithDeprecatedProperties(location);\n      this.adapter.visitProposedToLocation(location, options);\n    }\n\n    // Visit delegate\n  }, {\n    key: \"visitStarted\",\n    value: function visitStarted(visit) {\n      if (!visit.acceptsStreamResponse) {\n        markAsBusy(document.documentElement);\n        this.view.markVisitDirection(visit.direction);\n      }\n      extendURLWithDeprecatedProperties(visit.location);\n      if (!visit.silent) {\n        this.notifyApplicationAfterVisitingLocation(visit.location, visit.action);\n      }\n    }\n  }, {\n    key: \"visitCompleted\",\n    value: function visitCompleted(visit) {\n      this.view.unmarkVisitDirection();\n      clearBusyState(document.documentElement);\n      this.notifyApplicationAfterPageLoad(visit.getTimingMetrics());\n    }\n  }, {\n    key: \"locationWithActionIsSamePage\",\n    value: function locationWithActionIsSamePage(location, action) {\n      return this.navigator.locationWithActionIsSamePage(location, action);\n    }\n  }, {\n    key: \"visitScrolledToSamePageLocation\",\n    value: function visitScrolledToSamePageLocation(oldURL, newURL) {\n      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);\n    }\n\n    // Form submit observer delegate\n  }, {\n    key: \"willSubmitForm\",\n    value: function willSubmitForm(form, submitter) {\n      var action = getAction$1(form, submitter);\n      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);\n    }\n  }, {\n    key: \"formSubmitted\",\n    value: function formSubmitted(form, submitter) {\n      this.navigator.submitForm(form, submitter);\n    }\n\n    // Page observer delegate\n  }, {\n    key: \"pageBecameInteractive\",\n    value: function pageBecameInteractive() {\n      this.view.lastRenderedLocation = this.location;\n      this.notifyApplicationAfterPageLoad();\n    }\n  }, {\n    key: \"pageLoaded\",\n    value: function pageLoaded() {\n      this.history.assumeControlOfScrollRestoration();\n    }\n  }, {\n    key: \"pageWillUnload\",\n    value: function pageWillUnload() {\n      this.history.relinquishControlOfScrollRestoration();\n    }\n\n    // Stream observer delegate\n  }, {\n    key: \"receivedMessageFromStream\",\n    value: function receivedMessageFromStream(message) {\n      this.renderStreamMessage(message);\n    }\n\n    // Page view delegate\n  }, {\n    key: \"viewWillCacheSnapshot\",\n    value: function viewWillCacheSnapshot() {\n      var _this$navigator$curre;\n      if (!((_this$navigator$curre = this.navigator.currentVisit) !== null && _this$navigator$curre !== void 0 && _this$navigator$curre.silent)) {\n        this.notifyApplicationBeforeCachingSnapshot();\n      }\n    }\n  }, {\n    key: \"allowsImmediateRender\",\n    value: function allowsImmediateRender(_ref26, options) {\n      var element = _ref26.element;\n      var event = this.notifyApplicationBeforeRender(element, options);\n      var defaultPrevented = event.defaultPrevented,\n        render = event.detail.render;\n      if (this.view.renderer && render) {\n        this.view.renderer.renderElement = render;\n      }\n      return !defaultPrevented;\n    }\n  }, {\n    key: \"viewRenderedSnapshot\",\n    value: function viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {\n      this.view.lastRenderedLocation = this.history.location;\n      this.notifyApplicationAfterRender(renderMethod);\n    }\n  }, {\n    key: \"preloadOnLoadLinksForView\",\n    value: function preloadOnLoadLinksForView(element) {\n      this.preloader.preloadOnLoadLinksForView(element);\n    }\n  }, {\n    key: \"viewInvalidated\",\n    value: function viewInvalidated(reason) {\n      this.adapter.pageInvalidated(reason);\n    }\n\n    // Frame element\n  }, {\n    key: \"frameLoaded\",\n    value: function frameLoaded(frame) {\n      this.notifyApplicationAfterFrameLoad(frame);\n    }\n  }, {\n    key: \"frameRendered\",\n    value: function frameRendered(fetchResponse, frame) {\n      this.notifyApplicationAfterFrameRender(fetchResponse, frame);\n    }\n\n    // Application events\n  }, {\n    key: \"applicationAllowsFollowingLinkToLocation\",\n    value: function applicationAllowsFollowingLinkToLocation(link, location, ev) {\n      var event = this.notifyApplicationAfterClickingLinkToLocation(link, location, ev);\n      return !event.defaultPrevented;\n    }\n  }, {\n    key: \"applicationAllowsVisitingLocation\",\n    value: function applicationAllowsVisitingLocation(location) {\n      var event = this.notifyApplicationBeforeVisitingLocation(location);\n      return !event.defaultPrevented;\n    }\n  }, {\n    key: \"notifyApplicationAfterClickingLinkToLocation\",\n    value: function notifyApplicationAfterClickingLinkToLocation(link, location, event) {\n      return dispatch(\"turbo:click\", {\n        target: link,\n        detail: {\n          url: location.href,\n          originalEvent: event\n        },\n        cancelable: true\n      });\n    }\n  }, {\n    key: \"notifyApplicationBeforeVisitingLocation\",\n    value: function notifyApplicationBeforeVisitingLocation(location) {\n      return dispatch(\"turbo:before-visit\", {\n        detail: {\n          url: location.href\n        },\n        cancelable: true\n      });\n    }\n  }, {\n    key: \"notifyApplicationAfterVisitingLocation\",\n    value: function notifyApplicationAfterVisitingLocation(location, action) {\n      return dispatch(\"turbo:visit\", {\n        detail: {\n          url: location.href,\n          action: action\n        }\n      });\n    }\n  }, {\n    key: \"notifyApplicationBeforeCachingSnapshot\",\n    value: function notifyApplicationBeforeCachingSnapshot() {\n      return dispatch(\"turbo:before-cache\");\n    }\n  }, {\n    key: \"notifyApplicationBeforeRender\",\n    value: function notifyApplicationBeforeRender(newBody, options) {\n      return dispatch(\"turbo:before-render\", {\n        detail: _objectSpread({\n          newBody: newBody\n        }, options),\n        cancelable: true\n      });\n    }\n  }, {\n    key: \"notifyApplicationAfterRender\",\n    value: function notifyApplicationAfterRender(renderMethod) {\n      return dispatch(\"turbo:render\", {\n        detail: {\n          renderMethod: renderMethod\n        }\n      });\n    }\n  }, {\n    key: \"notifyApplicationAfterPageLoad\",\n    value: function notifyApplicationAfterPageLoad() {\n      var timing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return dispatch(\"turbo:load\", {\n        detail: {\n          url: this.location.href,\n          timing: timing\n        }\n      });\n    }\n  }, {\n    key: \"notifyApplicationAfterVisitingSamePageLocation\",\n    value: function notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {\n      dispatchEvent(new HashChangeEvent(\"hashchange\", {\n        oldURL: oldURL.toString(),\n        newURL: newURL.toString()\n      }));\n    }\n  }, {\n    key: \"notifyApplicationAfterFrameLoad\",\n    value: function notifyApplicationAfterFrameLoad(frame) {\n      return dispatch(\"turbo:frame-load\", {\n        target: frame\n      });\n    }\n  }, {\n    key: \"notifyApplicationAfterFrameRender\",\n    value: function notifyApplicationAfterFrameRender(fetchResponse, frame) {\n      return dispatch(\"turbo:frame-render\", {\n        detail: {\n          fetchResponse: fetchResponse\n        },\n        target: frame,\n        cancelable: true\n      });\n    }\n\n    // Helpers\n  }, {\n    key: \"submissionIsNavigatable\",\n    value: function submissionIsNavigatable(form, submitter) {\n      if (config.forms.mode == \"off\") {\n        return false;\n      } else {\n        var submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;\n        if (config.forms.mode == \"optin\") {\n          return submitterIsNavigatable && form.closest('[data-turbo=\"true\"]') != null;\n        } else {\n          return submitterIsNavigatable && this.elementIsNavigatable(form);\n        }\n      }\n    }\n  }, {\n    key: \"elementIsNavigatable\",\n    value: function elementIsNavigatable(element) {\n      var container = findClosestRecursively(element, \"[data-turbo]\");\n      var withinFrame = findClosestRecursively(element, \"turbo-frame\");\n\n      // Check if Drive is enabled on the session or we're within a Frame.\n      if (config.drive.enabled || withinFrame) {\n        // Element is navigatable by default, unless `data-turbo=\"false\"`.\n        if (container) {\n          return container.getAttribute(\"data-turbo\") != \"false\";\n        } else {\n          return true;\n        }\n      } else {\n        // Element isn't navigatable by default, unless `data-turbo=\"true\"`.\n        if (container) {\n          return container.getAttribute(\"data-turbo\") == \"true\";\n        } else {\n          return false;\n        }\n      }\n    }\n\n    // Private\n  }, {\n    key: \"getActionForLink\",\n    value: function getActionForLink(link) {\n      return getVisitAction(link) || \"advance\";\n    }\n  }, {\n    key: \"snapshot\",\n    get: function get() {\n      return this.view.snapshot;\n    }\n  }]);\n}(); // Older versions of the Turbo Native adapters referenced the\n// `Location#absoluteURL` property in their implementations of\n// the `Adapter#visitProposedToLocation()` and `#visitStarted()`\n// methods. The Location class has since been removed in favor\n// of the DOM URL API, and accordingly all Adapter methods now\n// receive URL objects.\n//\n// We alias #absoluteURL to #toString() here to avoid crashing\n// older adapters which do not expect URL objects. We should\n// consider removing this support at some point in the future.\nfunction extendURLWithDeprecatedProperties(url) {\n  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);\n}\nvar deprecatedLocationPropertyDescriptors = {\n  absoluteURL: {\n    get: function get() {\n      return this.toString();\n    }\n  }\n};\nvar session = new Session(recentRequests);\nvar cache = session.cache,\n  navigator$1 = session.navigator;\n\n/**\n * Starts the main session.\n * This initialises any necessary observers such as those to monitor\n * link interactions.\n */\nfunction start() {\n  session.start();\n}\n\n/**\n * Registers an adapter for the main session.\n *\n * @param adapter Adapter to register\n */\nfunction registerAdapter(adapter) {\n  session.registerAdapter(adapter);\n}\n\n/**\n * Performs an application visit to the given location.\n *\n * @param location Location to visit (a URL or path)\n * @param options Options to apply\n * @param options.action Type of history navigation to apply (\"restore\",\n * \"replace\" or \"advance\")\n * @param options.historyChanged Specifies whether the browser history has\n * already been changed for this visit or not\n * @param options.referrer Specifies the referrer of this visit such that\n * navigations to the same page will not result in a new history entry.\n * @param options.snapshotHTML Cached snapshot to render\n * @param options.response Response of the specified location\n */\nfunction visit(location, options) {\n  session.visit(location, options);\n}\n\n/**\n * Connects a stream source to the main session.\n *\n * @param source Stream source to connect\n */\nfunction connectStreamSource(source) {\n  session.connectStreamSource(source);\n}\n\n/**\n * Disconnects a stream source from the main session.\n *\n * @param source Stream source to disconnect\n */\nfunction disconnectStreamSource(source) {\n  session.disconnectStreamSource(source);\n}\n\n/**\n * Renders a stream message to the main session by appending it to the\n * current document.\n *\n * @param message Message to render\n */\nfunction renderStreamMessage(message) {\n  session.renderStreamMessage(message);\n}\n\n/**\n * Removes all entries from the Turbo Drive page cache.\n * Call this when state has changed on the server that may affect cached pages.\n *\n * @deprecated since version 7.2.0 in favor of `Turbo.cache.clear()`\n */\nfunction clearCache() {\n  console.warn(\"Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`\");\n  session.clearCache();\n}\n\n/**\n * Sets the delay after which the progress bar will appear during navigation.\n *\n * The progress bar appears after 500ms by default.\n *\n * Note that this method has no effect when used with the iOS or Android\n * adapters.\n *\n * @param delay Time to delay in milliseconds\n */\nfunction setProgressBarDelay(delay) {\n  console.warn(\"Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`\");\n  config.drive.progressBarDelay = delay;\n}\nfunction setConfirmMethod(confirmMethod) {\n  console.warn(\"Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`\");\n  config.forms.confirm = confirmMethod;\n}\nfunction setFormMode(mode) {\n  console.warn(\"Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`\");\n  config.forms.mode = mode;\n}\nvar Turbo = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  navigator: navigator$1,\n  session: session,\n  cache: cache,\n  PageRenderer: PageRenderer,\n  PageSnapshot: PageSnapshot,\n  FrameRenderer: FrameRenderer,\n  fetch: fetchWithTurboHeaders,\n  config: config,\n  start: start,\n  registerAdapter: registerAdapter,\n  visit: visit,\n  connectStreamSource: connectStreamSource,\n  disconnectStreamSource: disconnectStreamSource,\n  renderStreamMessage: renderStreamMessage,\n  clearCache: clearCache,\n  setProgressBarDelay: setProgressBarDelay,\n  setConfirmMethod: setConfirmMethod,\n  setFormMode: setFormMode\n});\nvar TurboFrameMissingError = /*#__PURE__*/function (_Error) {\n  function TurboFrameMissingError() {\n    _classCallCheck(this, TurboFrameMissingError);\n    return _callSuper(this, TurboFrameMissingError, arguments);\n  }\n  _inherits(TurboFrameMissingError, _Error);\n  return _createClass(TurboFrameMissingError);\n}(/*#__PURE__*/_wrapNativeSuper(Error));\nvar _currentFetchRequest = /*#__PURE__*/_classPrivateFieldLooseKey(\"currentFetchRequest\");\nvar _resolveVisitPromise = /*#__PURE__*/_classPrivateFieldLooseKey(\"resolveVisitPromise\");\nvar _connected = /*#__PURE__*/_classPrivateFieldLooseKey(\"connected\");\nvar _hasBeenLoaded = /*#__PURE__*/_classPrivateFieldLooseKey(\"hasBeenLoaded\");\nvar _ignoredAttributes = /*#__PURE__*/_classPrivateFieldLooseKey(\"ignoredAttributes\");\nvar _shouldMorphFrame = /*#__PURE__*/_classPrivateFieldLooseKey(\"shouldMorphFrame\");\nvar _loadSourceURL = /*#__PURE__*/_classPrivateFieldLooseKey(\"loadSourceURL\");\nvar _loadFrameResponse = /*#__PURE__*/_classPrivateFieldLooseKey(\"loadFrameResponse\");\nvar _visit2 = /*#__PURE__*/_classPrivateFieldLooseKey(\"visit\");\nvar _navigateFrame = /*#__PURE__*/_classPrivateFieldLooseKey(\"navigateFrame\");\nvar _handleUnvisitableFrameResponse = /*#__PURE__*/_classPrivateFieldLooseKey(\"handleUnvisitableFrameResponse\");\nvar _willHandleFrameMissingFromResponse = /*#__PURE__*/_classPrivateFieldLooseKey(\"willHandleFrameMissingFromResponse\");\nvar _handleFrameMissingFromResponse = /*#__PURE__*/_classPrivateFieldLooseKey(\"handleFrameMissingFromResponse\");\nvar _throwFrameMissingError = /*#__PURE__*/_classPrivateFieldLooseKey(\"throwFrameMissingError\");\nvar _visitResponse = /*#__PURE__*/_classPrivateFieldLooseKey(\"visitResponse\");\nvar _findFrameElement3 = /*#__PURE__*/_classPrivateFieldLooseKey(\"findFrameElement\");\nvar _formActionIsVisitable = /*#__PURE__*/_classPrivateFieldLooseKey(\"formActionIsVisitable\");\nvar _shouldInterceptNavigation = /*#__PURE__*/_classPrivateFieldLooseKey(\"shouldInterceptNavigation\");\nvar _isIgnoringChangesTo = /*#__PURE__*/_classPrivateFieldLooseKey(\"isIgnoringChangesTo\");\nvar _ignoringChangesToAttribute = /*#__PURE__*/_classPrivateFieldLooseKey(\"ignoringChangesToAttribute\");\nvar _withCurrentNavigationElement = /*#__PURE__*/_classPrivateFieldLooseKey(\"withCurrentNavigationElement\");\nvar FrameController = /*#__PURE__*/function () {\n  function FrameController(_element3) {\n    var _this40 = this;\n    _classCallCheck(this, FrameController);\n    Object.defineProperty(this, _withCurrentNavigationElement, {\n      value: _withCurrentNavigationElement2\n    });\n    Object.defineProperty(this, _ignoringChangesToAttribute, {\n      value: _ignoringChangesToAttribute2\n    });\n    Object.defineProperty(this, _isIgnoringChangesTo, {\n      value: _isIgnoringChangesTo2\n    });\n    Object.defineProperty(this, _shouldInterceptNavigation, {\n      value: _shouldInterceptNavigation2\n    });\n    Object.defineProperty(this, _formActionIsVisitable, {\n      value: _formActionIsVisitable2\n    });\n    Object.defineProperty(this, _findFrameElement3, {\n      value: _findFrameElement4\n    });\n    Object.defineProperty(this, _visitResponse, {\n      value: _visitResponse2\n    });\n    Object.defineProperty(this, _throwFrameMissingError, {\n      value: _throwFrameMissingError2\n    });\n    Object.defineProperty(this, _handleFrameMissingFromResponse, {\n      value: _handleFrameMissingFromResponse2\n    });\n    Object.defineProperty(this, _willHandleFrameMissingFromResponse, {\n      value: _willHandleFrameMissingFromResponse2\n    });\n    Object.defineProperty(this, _handleUnvisitableFrameResponse, {\n      value: _handleUnvisitableFrameResponse2\n    });\n    Object.defineProperty(this, _navigateFrame, {\n      value: _navigateFrame2\n    });\n    Object.defineProperty(this, _visit2, {\n      value: _visit3\n    });\n    // Private\n    Object.defineProperty(this, _loadFrameResponse, {\n      value: _loadFrameResponse2\n    });\n    Object.defineProperty(this, _loadSourceURL, {\n      value: _loadSourceURL2\n    });\n    this.fetchResponseLoaded = function (_fetchResponse) {\n      return Promise.resolve();\n    };\n    Object.defineProperty(this, _currentFetchRequest, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _resolveVisitPromise, {\n      writable: true,\n      value: function value() {}\n    });\n    Object.defineProperty(this, _connected, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _hasBeenLoaded, {\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, _ignoredAttributes, {\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, _shouldMorphFrame, {\n      writable: true,\n      value: false\n    });\n    this.action = null;\n    this.visitCachedSnapshot = function (_ref15) {\n      var element = _ref15.element;\n      var frame = element.querySelector(\"#\" + _this40.element.id);\n      if (frame && _this40.previousFrameElement) {\n        frame.replaceChildren.apply(frame, _toConsumableArray(_this40.previousFrameElement.children));\n      }\n      delete _this40.previousFrameElement;\n    };\n    this.element = _element3;\n    this.view = new FrameView(this, this.element);\n    this.appearanceObserver = new AppearanceObserver(this, this.element);\n    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);\n    this.linkInterceptor = new LinkInterceptor(this, this.element);\n    this.restorationIdentifier = uuid();\n    this.formSubmitObserver = new FormSubmitObserver(this, this.element);\n  }\n\n  // Frame delegate\n  return _createClass(FrameController, [{\n    key: \"connect\",\n    value: function connect() {\n      if (!_classPrivateFieldLooseBase(this, _connected)[_connected]) {\n        _classPrivateFieldLooseBase(this, _connected)[_connected] = true;\n        if (this.loadingStyle == FrameLoadingStyle.lazy) {\n          this.appearanceObserver.start();\n        } else {\n          _classPrivateFieldLooseBase(this, _loadSourceURL)[_loadSourceURL]();\n        }\n        this.formLinkClickObserver.start();\n        this.linkInterceptor.start();\n        this.formSubmitObserver.start();\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (_classPrivateFieldLooseBase(this, _connected)[_connected]) {\n        _classPrivateFieldLooseBase(this, _connected)[_connected] = false;\n        this.appearanceObserver.stop();\n        this.formLinkClickObserver.stop();\n        this.linkInterceptor.stop();\n        this.formSubmitObserver.stop();\n      }\n    }\n  }, {\n    key: \"disabledChanged\",\n    value: function disabledChanged() {\n      if (this.loadingStyle == FrameLoadingStyle.eager) {\n        _classPrivateFieldLooseBase(this, _loadSourceURL)[_loadSourceURL]();\n      }\n    }\n  }, {\n    key: \"sourceURLChanged\",\n    value: function sourceURLChanged() {\n      if (_classPrivateFieldLooseBase(this, _isIgnoringChangesTo)[_isIgnoringChangesTo](\"src\")) return;\n      if (this.element.isConnected) {\n        this.complete = false;\n      }\n      if (this.loadingStyle == FrameLoadingStyle.eager || _classPrivateFieldLooseBase(this, _hasBeenLoaded)[_hasBeenLoaded]) {\n        _classPrivateFieldLooseBase(this, _loadSourceURL)[_loadSourceURL]();\n      }\n    }\n  }, {\n    key: \"sourceURLReloaded\",\n    value: function sourceURLReloaded() {\n      var _this$element = this.element,\n        refresh = _this$element.refresh,\n        src = _this$element.src;\n      _classPrivateFieldLooseBase(this, _shouldMorphFrame)[_shouldMorphFrame] = src && refresh === \"morph\";\n      this.element.removeAttribute(\"complete\");\n      this.element.src = null;\n      this.element.src = src;\n      return this.element.loaded;\n    }\n  }, {\n    key: \"loadingStyleChanged\",\n    value: function loadingStyleChanged() {\n      if (this.loadingStyle == FrameLoadingStyle.lazy) {\n        this.appearanceObserver.start();\n      } else {\n        this.appearanceObserver.stop();\n        _classPrivateFieldLooseBase(this, _loadSourceURL)[_loadSourceURL]();\n      }\n    }\n  }, {\n    key: \"loadResponse\",\n    value: function () {\n      var _loadResponse = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee37(fetchResponse) {\n        var html, _document3, pageSnapshot;\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) switch (_context37.prev = _context37.next) {\n            case 0:\n              if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {\n                this.sourceURL = fetchResponse.response.url;\n              }\n              _context37.prev = 1;\n              _context37.next = 4;\n              return fetchResponse.responseHTML;\n            case 4:\n              html = _context37.sent;\n              if (!html) {\n                _context37.next = 15;\n                break;\n              }\n              _document3 = parseHTMLDocument(html);\n              pageSnapshot = PageSnapshot.fromDocument(_document3);\n              if (!pageSnapshot.isVisitable) {\n                _context37.next = 13;\n                break;\n              }\n              _context37.next = 11;\n              return _classPrivateFieldLooseBase(this, _loadFrameResponse)[_loadFrameResponse](fetchResponse, _document3);\n            case 11:\n              _context37.next = 15;\n              break;\n            case 13:\n              _context37.next = 15;\n              return _classPrivateFieldLooseBase(this, _handleUnvisitableFrameResponse)[_handleUnvisitableFrameResponse](fetchResponse);\n            case 15:\n              _context37.prev = 15;\n              _classPrivateFieldLooseBase(this, _shouldMorphFrame)[_shouldMorphFrame] = false;\n              this.fetchResponseLoaded = function () {\n                return Promise.resolve();\n              };\n              return _context37.finish(15);\n            case 19:\n            case \"end\":\n              return _context37.stop();\n          }\n        }, _callee37, this, [[1,, 15, 19]]);\n      }));\n      function loadResponse(_x32) {\n        return _loadResponse.apply(this, arguments);\n      }\n      return loadResponse;\n    }() // Appearance observer delegate\n  }, {\n    key: \"elementAppearedInViewport\",\n    value: function elementAppearedInViewport(element) {\n      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));\n      _classPrivateFieldLooseBase(this, _loadSourceURL)[_loadSourceURL]();\n    }\n\n    // Form link click observer delegate\n  }, {\n    key: \"willSubmitFormLinkToLocation\",\n    value: function willSubmitFormLinkToLocation(link) {\n      return _classPrivateFieldLooseBase(this, _shouldInterceptNavigation)[_shouldInterceptNavigation](link);\n    }\n  }, {\n    key: \"submittedFormLinkToLocation\",\n    value: function submittedFormLinkToLocation(link, _location, form) {\n      var frame = _classPrivateFieldLooseBase(this, _findFrameElement3)[_findFrameElement3](link);\n      if (frame) form.setAttribute(\"data-turbo-frame\", frame.id);\n    }\n\n    // Link interceptor delegate\n  }, {\n    key: \"shouldInterceptLinkClick\",\n    value: function shouldInterceptLinkClick(element, _location, _event) {\n      return _classPrivateFieldLooseBase(this, _shouldInterceptNavigation)[_shouldInterceptNavigation](element);\n    }\n  }, {\n    key: \"linkClickIntercepted\",\n    value: function linkClickIntercepted(element, location) {\n      _classPrivateFieldLooseBase(this, _navigateFrame)[_navigateFrame](element, location);\n    }\n\n    // Form submit observer delegate\n  }, {\n    key: \"willSubmitForm\",\n    value: function willSubmitForm(element, submitter) {\n      return element.closest(\"turbo-frame\") == this.element && _classPrivateFieldLooseBase(this, _shouldInterceptNavigation)[_shouldInterceptNavigation](element, submitter);\n    }\n  }, {\n    key: \"formSubmitted\",\n    value: function formSubmitted(element, submitter) {\n      if (this.formSubmission) {\n        this.formSubmission.stop();\n      }\n      this.formSubmission = new FormSubmission(this, element, submitter);\n      var fetchRequest = this.formSubmission.fetchRequest;\n      this.prepareRequest(fetchRequest);\n      this.formSubmission.start();\n    }\n\n    // Fetch request delegate\n  }, {\n    key: \"prepareRequest\",\n    value: function prepareRequest(request) {\n      var _this$currentNavigati;\n      request.headers[\"Turbo-Frame\"] = this.id;\n      if ((_this$currentNavigati = this.currentNavigationElement) !== null && _this$currentNavigati !== void 0 && _this$currentNavigati.hasAttribute(\"data-turbo-stream\")) {\n        request.acceptResponseType(StreamMessage.contentType);\n      }\n    }\n  }, {\n    key: \"requestStarted\",\n    value: function requestStarted(_request) {\n      markAsBusy(this.element);\n    }\n  }, {\n    key: \"requestPreventedHandlingResponse\",\n    value: function requestPreventedHandlingResponse(_request, _response) {\n      _classPrivateFieldLooseBase(this, _resolveVisitPromise)[_resolveVisitPromise]();\n    }\n  }, {\n    key: \"requestSucceededWithResponse\",\n    value: function () {\n      var _requestSucceededWithResponse3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee38(request, response) {\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) switch (_context38.prev = _context38.next) {\n            case 0:\n              _context38.next = 2;\n              return this.loadResponse(response);\n            case 2:\n              _classPrivateFieldLooseBase(this, _resolveVisitPromise)[_resolveVisitPromise]();\n            case 3:\n            case \"end\":\n              return _context38.stop();\n          }\n        }, _callee38, this);\n      }));\n      function requestSucceededWithResponse(_x33, _x34) {\n        return _requestSucceededWithResponse3.apply(this, arguments);\n      }\n      return requestSucceededWithResponse;\n    }()\n  }, {\n    key: \"requestFailedWithResponse\",\n    value: function () {\n      var _requestFailedWithResponse2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee39(request, response) {\n        return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n          while (1) switch (_context39.prev = _context39.next) {\n            case 0:\n              _context39.next = 2;\n              return this.loadResponse(response);\n            case 2:\n              _classPrivateFieldLooseBase(this, _resolveVisitPromise)[_resolveVisitPromise]();\n            case 3:\n            case \"end\":\n              return _context39.stop();\n          }\n        }, _callee39, this);\n      }));\n      function requestFailedWithResponse(_x35, _x36) {\n        return _requestFailedWithResponse2.apply(this, arguments);\n      }\n      return requestFailedWithResponse;\n    }()\n  }, {\n    key: \"requestErrored\",\n    value: function requestErrored(request, error) {\n      console.error(error);\n      _classPrivateFieldLooseBase(this, _resolveVisitPromise)[_resolveVisitPromise]();\n    }\n  }, {\n    key: \"requestFinished\",\n    value: function requestFinished(_request) {\n      clearBusyState(this.element);\n    }\n\n    // Form submission delegate\n  }, {\n    key: \"formSubmissionStarted\",\n    value: function formSubmissionStarted(_ref16) {\n      var formElement = _ref16.formElement;\n      markAsBusy(formElement, _classPrivateFieldLooseBase(this, _findFrameElement3)[_findFrameElement3](formElement));\n    }\n  }, {\n    key: \"formSubmissionSucceededWithResponse\",\n    value: function formSubmissionSucceededWithResponse(formSubmission, response) {\n      var frame = _classPrivateFieldLooseBase(this, _findFrameElement3)[_findFrameElement3](formSubmission.formElement, formSubmission.submitter);\n      frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));\n      frame.delegate.loadResponse(response);\n      if (!formSubmission.isSafe) {\n        session.clearCache();\n      }\n    }\n  }, {\n    key: \"formSubmissionFailedWithResponse\",\n    value: function formSubmissionFailedWithResponse(formSubmission, fetchResponse) {\n      this.element.delegate.loadResponse(fetchResponse);\n      session.clearCache();\n    }\n  }, {\n    key: \"formSubmissionErrored\",\n    value: function formSubmissionErrored(formSubmission, error) {\n      console.error(error);\n    }\n  }, {\n    key: \"formSubmissionFinished\",\n    value: function formSubmissionFinished(_ref17) {\n      var formElement = _ref17.formElement;\n      clearBusyState(formElement, _classPrivateFieldLooseBase(this, _findFrameElement3)[_findFrameElement3](formElement));\n    }\n\n    // View delegate\n  }, {\n    key: \"allowsImmediateRender\",\n    value: function allowsImmediateRender(_ref18, options) {\n      var newFrame = _ref18.element;\n      var event = dispatch(\"turbo:before-frame-render\", {\n        target: this.element,\n        detail: _objectSpread({\n          newFrame: newFrame\n        }, options),\n        cancelable: true\n      });\n      var defaultPrevented = event.defaultPrevented,\n        render = event.detail.render;\n      if (this.view.renderer && render) {\n        this.view.renderer.renderElement = render;\n      }\n      return !defaultPrevented;\n    }\n  }, {\n    key: \"viewRenderedSnapshot\",\n    value: function viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {}\n  }, {\n    key: \"preloadOnLoadLinksForView\",\n    value: function preloadOnLoadLinksForView(element) {\n      session.preloadOnLoadLinksForView(element);\n    }\n  }, {\n    key: \"viewInvalidated\",\n    value: function viewInvalidated() {}\n\n    // Frame renderer delegate\n  }, {\n    key: \"willRenderFrame\",\n    value: function willRenderFrame(currentElement, _newElement) {\n      this.previousFrameElement = currentElement.cloneNode(true);\n    }\n  }, {\n    key: \"proposeVisitIfNavigatedWithAction\",\n    value: function proposeVisitIfNavigatedWithAction(frame) {\n      var _this41 = this;\n      var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      this.action = action;\n      if (this.action) {\n        var pageSnapshot = PageSnapshot.fromElement(frame).clone();\n        var visitCachedSnapshot = frame.delegate.visitCachedSnapshot;\n        frame.delegate.fetchResponseLoaded = /*#__PURE__*/function () {\n          var _ref19 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee40(fetchResponse) {\n            var statusCode, redirected, responseHTML, response, options;\n            return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n              while (1) switch (_context40.prev = _context40.next) {\n                case 0:\n                  if (!frame.src) {\n                    _context40.next = 9;\n                    break;\n                  }\n                  statusCode = fetchResponse.statusCode, redirected = fetchResponse.redirected;\n                  _context40.next = 4;\n                  return fetchResponse.responseHTML;\n                case 4:\n                  responseHTML = _context40.sent;\n                  response = {\n                    statusCode: statusCode,\n                    redirected: redirected,\n                    responseHTML: responseHTML\n                  };\n                  options = {\n                    response: response,\n                    visitCachedSnapshot: visitCachedSnapshot,\n                    willRender: false,\n                    updateHistory: false,\n                    restorationIdentifier: _this41.restorationIdentifier,\n                    snapshot: pageSnapshot\n                  };\n                  if (_this41.action) options.action = _this41.action;\n                  session.visit(frame.src, options);\n                case 9:\n                case \"end\":\n                  return _context40.stop();\n              }\n            }, _callee40);\n          }));\n          return function (_x37) {\n            return _ref19.apply(this, arguments);\n          };\n        }();\n      }\n    }\n  }, {\n    key: \"changeHistory\",\n    value: function changeHistory() {\n      if (this.action) {\n        var method = getHistoryMethodForAction(this.action);\n        session.history.update(method, expandURL(this.element.src || \"\"), this.restorationIdentifier);\n      }\n    }\n  }, {\n    key: \"extractForeignFrameElement\",\n    value: function () {\n      var _extractForeignFrameElement = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee41(container) {\n        var element, id;\n        return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n          while (1) switch (_context41.prev = _context41.next) {\n            case 0:\n              id = CSS.escape(this.id);\n              _context41.prev = 1;\n              element = activateElement(container.querySelector(\"turbo-frame#\".concat(id)), this.sourceURL);\n              if (!element) {\n                _context41.next = 5;\n                break;\n              }\n              return _context41.abrupt(\"return\", element);\n            case 5:\n              element = activateElement(container.querySelector(\"turbo-frame[src][recurse~=\".concat(id, \"]\")), this.sourceURL);\n              if (!element) {\n                _context41.next = 12;\n                break;\n              }\n              _context41.next = 9;\n              return element.loaded;\n            case 9:\n              _context41.next = 11;\n              return this.extractForeignFrameElement(element);\n            case 11:\n              return _context41.abrupt(\"return\", _context41.sent);\n            case 12:\n              _context41.next = 18;\n              break;\n            case 14:\n              _context41.prev = 14;\n              _context41.t0 = _context41[\"catch\"](1);\n              console.error(_context41.t0);\n              return _context41.abrupt(\"return\", new FrameElement());\n            case 18:\n              return _context41.abrupt(\"return\", null);\n            case 19:\n            case \"end\":\n              return _context41.stop();\n          }\n        }, _callee41, this, [[1, 14]]);\n      }));\n      function extractForeignFrameElement(_x38) {\n        return _extractForeignFrameElement.apply(this, arguments);\n      }\n      return extractForeignFrameElement;\n    }()\n  }, {\n    key: \"id\",\n    get:\n    // Computed properties\n\n    function get() {\n      return this.element.id;\n    }\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return !this.element.disabled;\n    }\n  }, {\n    key: \"sourceURL\",\n    get: function get() {\n      if (this.element.src) {\n        return this.element.src;\n      }\n    },\n    set: function set(sourceURL) {\n      var _this42 = this;\n      _classPrivateFieldLooseBase(this, _ignoringChangesToAttribute)[_ignoringChangesToAttribute](\"src\", function () {\n        _this42.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;\n      });\n    }\n  }, {\n    key: \"loadingStyle\",\n    get: function get() {\n      return this.element.loading;\n    }\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      return this.formSubmission !== undefined || _classPrivateFieldLooseBase(this, _resolveVisitPromise)[_resolveVisitPromise]() !== undefined;\n    }\n  }, {\n    key: \"complete\",\n    get: function get() {\n      return this.element.hasAttribute(\"complete\");\n    },\n    set: function set(value) {\n      if (value) {\n        this.element.setAttribute(\"complete\", \"\");\n      } else {\n        this.element.removeAttribute(\"complete\");\n      }\n    }\n  }, {\n    key: \"isActive\",\n    get: function get() {\n      return this.element.isActive && _classPrivateFieldLooseBase(this, _connected)[_connected];\n    }\n  }, {\n    key: \"rootLocation\",\n    get: function get() {\n      var _meta$content;\n      var meta = this.element.ownerDocument.querySelector(\"meta[name=\\\"turbo-root\\\"]\");\n      var root = (_meta$content = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _meta$content !== void 0 ? _meta$content : \"/\";\n      return expandURL(root);\n    }\n  }]);\n}();\nfunction _loadSourceURL2() {\n  return _loadSourceURL3.apply(this, arguments);\n}\nfunction _loadSourceURL3() {\n  _loadSourceURL3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee51() {\n    return _regeneratorRuntime().wrap(function _callee51$(_context51) {\n      while (1) switch (_context51.prev = _context51.next) {\n        case 0:\n          if (!(this.enabled && this.isActive && !this.complete && this.sourceURL)) {\n            _context51.next = 6;\n            break;\n          }\n          this.element.loaded = _classPrivateFieldLooseBase(this, _visit2)[_visit2](expandURL(this.sourceURL));\n          this.appearanceObserver.stop();\n          _context51.next = 5;\n          return this.element.loaded;\n        case 5:\n          _classPrivateFieldLooseBase(this, _hasBeenLoaded)[_hasBeenLoaded] = true;\n        case 6:\n        case \"end\":\n          return _context51.stop();\n      }\n    }, _callee51, this);\n  }));\n  return _loadSourceURL3.apply(this, arguments);\n}\nfunction _loadFrameResponse2(_x41, _x42) {\n  return _loadFrameResponse3.apply(this, arguments);\n}\nfunction _loadFrameResponse3() {\n  _loadFrameResponse3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee52(fetchResponse, document) {\n    var newFrameElement, rendererClass, snapshot, renderer;\n    return _regeneratorRuntime().wrap(function _callee52$(_context52) {\n      while (1) switch (_context52.prev = _context52.next) {\n        case 0:\n          _context52.next = 2;\n          return this.extractForeignFrameElement(document.body);\n        case 2:\n          newFrameElement = _context52.sent;\n          rendererClass = _classPrivateFieldLooseBase(this, _shouldMorphFrame)[_shouldMorphFrame] ? MorphingFrameRenderer : FrameRenderer;\n          if (!newFrameElement) {\n            _context52.next = 20;\n            break;\n          }\n          snapshot = new Snapshot(newFrameElement);\n          renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);\n          if (!this.view.renderPromise) {\n            _context52.next = 10;\n            break;\n          }\n          _context52.next = 10;\n          return this.view.renderPromise;\n        case 10:\n          this.changeHistory();\n          _context52.next = 13;\n          return this.view.render(renderer);\n        case 13:\n          this.complete = true;\n          session.frameRendered(fetchResponse, this.element);\n          session.frameLoaded(this.element);\n          _context52.next = 18;\n          return this.fetchResponseLoaded(fetchResponse);\n        case 18:\n          _context52.next = 21;\n          break;\n        case 20:\n          if (_classPrivateFieldLooseBase(this, _willHandleFrameMissingFromResponse)[_willHandleFrameMissingFromResponse](fetchResponse)) {\n            _classPrivateFieldLooseBase(this, _handleFrameMissingFromResponse)[_handleFrameMissingFromResponse](fetchResponse);\n          }\n        case 21:\n        case \"end\":\n          return _context52.stop();\n      }\n    }, _callee52, this);\n  }));\n  return _loadFrameResponse3.apply(this, arguments);\n}\nfunction _visit3(_x43) {\n  return _visit4.apply(this, arguments);\n}\nfunction _visit4() {\n  _visit4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee53(url) {\n    var _classPrivateFieldLoo,\n      _this54 = this;\n    var request;\n    return _regeneratorRuntime().wrap(function _callee53$(_context53) {\n      while (1) switch (_context53.prev = _context53.next) {\n        case 0:\n          request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);\n          (_classPrivateFieldLoo = _classPrivateFieldLooseBase(this, _currentFetchRequest)[_currentFetchRequest]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.cancel();\n          _classPrivateFieldLooseBase(this, _currentFetchRequest)[_currentFetchRequest] = request;\n          return _context53.abrupt(\"return\", new Promise(function (resolve) {\n            _classPrivateFieldLooseBase(_this54, _resolveVisitPromise)[_resolveVisitPromise] = function () {\n              _classPrivateFieldLooseBase(_this54, _resolveVisitPromise)[_resolveVisitPromise] = function () {};\n              _classPrivateFieldLooseBase(_this54, _currentFetchRequest)[_currentFetchRequest] = null;\n              resolve();\n            };\n            request.perform();\n          }));\n        case 4:\n        case \"end\":\n          return _context53.stop();\n      }\n    }, _callee53, this);\n  }));\n  return _visit4.apply(this, arguments);\n}\nfunction _navigateFrame2(element, url, submitter) {\n  var frame = _classPrivateFieldLooseBase(this, _findFrameElement3)[_findFrameElement3](element, submitter);\n  frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));\n  _classPrivateFieldLooseBase(this, _withCurrentNavigationElement)[_withCurrentNavigationElement](element, function () {\n    frame.src = url;\n  });\n}\nfunction _handleUnvisitableFrameResponse2(_x44) {\n  return _handleUnvisitableFrameResponse3.apply(this, arguments);\n}\nfunction _handleUnvisitableFrameResponse3() {\n  _handleUnvisitableFrameResponse3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee54(fetchResponse) {\n    return _regeneratorRuntime().wrap(function _callee54$(_context54) {\n      while (1) switch (_context54.prev = _context54.next) {\n        case 0:\n          console.warn(\"The response (\".concat(fetchResponse.statusCode, \") from <turbo-frame id=\\\"\").concat(this.element.id, \"\\\"> is performing a full page visit due to turbo-visit-control.\"));\n          _context54.next = 3;\n          return _classPrivateFieldLooseBase(this, _visitResponse)[_visitResponse](fetchResponse.response);\n        case 3:\n        case \"end\":\n          return _context54.stop();\n      }\n    }, _callee54, this);\n  }));\n  return _handleUnvisitableFrameResponse3.apply(this, arguments);\n}\nfunction _willHandleFrameMissingFromResponse2(fetchResponse) {\n  var _this52 = this;\n  this.element.setAttribute(\"complete\", \"\");\n  var response = fetchResponse.response;\n  var visit = /*#__PURE__*/function () {\n    var _ref27 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee49(url, options) {\n      return _regeneratorRuntime().wrap(function _callee49$(_context49) {\n        while (1) switch (_context49.prev = _context49.next) {\n          case 0:\n            if (url instanceof Response) {\n              _classPrivateFieldLooseBase(_this52, _visitResponse)[_visitResponse](url);\n            } else {\n              session.visit(url, options);\n            }\n          case 1:\n          case \"end\":\n            return _context49.stop();\n        }\n      }, _callee49);\n    }));\n    return function visit(_x45, _x46) {\n      return _ref27.apply(this, arguments);\n    };\n  }();\n  var event = dispatch(\"turbo:frame-missing\", {\n    target: this.element,\n    detail: {\n      response: response,\n      visit: visit\n    },\n    cancelable: true\n  });\n  return !event.defaultPrevented;\n}\nfunction _handleFrameMissingFromResponse2(fetchResponse) {\n  this.view.missing();\n  _classPrivateFieldLooseBase(this, _throwFrameMissingError)[_throwFrameMissingError](fetchResponse);\n}\nfunction _throwFrameMissingError2(fetchResponse) {\n  var message = \"The response (\".concat(fetchResponse.statusCode, \") did not contain the expected <turbo-frame id=\\\"\").concat(this.element.id, \"\\\"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.\");\n  throw new TurboFrameMissingError(message);\n}\nfunction _visitResponse2(_x47) {\n  return _visitResponse3.apply(this, arguments);\n}\nfunction _visitResponse3() {\n  _visitResponse3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee55(response) {\n    var wrapped, responseHTML, location, redirected, statusCode;\n    return _regeneratorRuntime().wrap(function _callee55$(_context55) {\n      while (1) switch (_context55.prev = _context55.next) {\n        case 0:\n          wrapped = new FetchResponse(response);\n          _context55.next = 3;\n          return wrapped.responseHTML;\n        case 3:\n          responseHTML = _context55.sent;\n          location = wrapped.location, redirected = wrapped.redirected, statusCode = wrapped.statusCode;\n          return _context55.abrupt(\"return\", session.visit(location, {\n            response: {\n              redirected: redirected,\n              statusCode: statusCode,\n              responseHTML: responseHTML\n            }\n          }));\n        case 6:\n        case \"end\":\n          return _context55.stop();\n      }\n    }, _callee55);\n  }));\n  return _visitResponse3.apply(this, arguments);\n}\nfunction _findFrameElement4(element, submitter) {\n  var _getFrameElementById;\n  var id = getAttribute(\"data-turbo-frame\", submitter, element) || this.element.getAttribute(\"target\");\n  return (_getFrameElementById = getFrameElementById(id)) !== null && _getFrameElementById !== void 0 ? _getFrameElementById : this.element;\n}\nfunction _formActionIsVisitable2(form, submitter) {\n  var action = getAction$1(form, submitter);\n  return locationIsVisitable(expandURL(action), this.rootLocation);\n}\nfunction _shouldInterceptNavigation2(element, submitter) {\n  var id = getAttribute(\"data-turbo-frame\", submitter, element) || this.element.getAttribute(\"target\");\n  if (element instanceof HTMLFormElement && !_classPrivateFieldLooseBase(this, _formActionIsVisitable)[_formActionIsVisitable](element, submitter)) {\n    return false;\n  }\n  if (!this.enabled || id == \"_top\") {\n    return false;\n  }\n  if (id) {\n    var frameElement = getFrameElementById(id);\n    if (frameElement) {\n      return !frameElement.disabled;\n    }\n  }\n  if (!session.elementIsNavigatable(element)) {\n    return false;\n  }\n  if (submitter && !session.elementIsNavigatable(submitter)) {\n    return false;\n  }\n  return true;\n}\nfunction _isIgnoringChangesTo2(attributeName) {\n  return _classPrivateFieldLooseBase(this, _ignoredAttributes)[_ignoredAttributes].has(attributeName);\n}\nfunction _ignoringChangesToAttribute2(attributeName, callback) {\n  _classPrivateFieldLooseBase(this, _ignoredAttributes)[_ignoredAttributes].add(attributeName);\n  callback();\n  _classPrivateFieldLooseBase(this, _ignoredAttributes)[_ignoredAttributes][\"delete\"](attributeName);\n}\nfunction _withCurrentNavigationElement2(element, callback) {\n  this.currentNavigationElement = element;\n  callback();\n  delete this.currentNavigationElement;\n}\nfunction getFrameElementById(id) {\n  if (id != null) {\n    var element = document.getElementById(id);\n    if (element instanceof FrameElement) {\n      return element;\n    }\n  }\n}\nfunction activateElement(element, currentURL) {\n  if (element) {\n    var src = element.getAttribute(\"src\");\n    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {\n      throw new Error(\"Matching <turbo-frame id=\\\"\".concat(element.id, \"\\\"> element has a source URL which references itself\"));\n    }\n    if (element.ownerDocument !== document) {\n      element = document.importNode(element, true);\n    }\n    if (element instanceof FrameElement) {\n      element.connectedCallback();\n      element.disconnectedCallback();\n      return element;\n    }\n  }\n}\nvar StreamActions = {\n  after: function after() {\n    var _this43 = this;\n    this.targetElements.forEach(function (e) {\n      var _e$parentElement;\n      return (_e$parentElement = e.parentElement) === null || _e$parentElement === void 0 ? void 0 : _e$parentElement.insertBefore(_this43.templateContent, e.nextSibling);\n    });\n  },\n  append: function append() {\n    var _this44 = this;\n    this.removeDuplicateTargetChildren();\n    this.targetElements.forEach(function (e) {\n      return e.append(_this44.templateContent);\n    });\n  },\n  before: function before() {\n    var _this45 = this;\n    this.targetElements.forEach(function (e) {\n      var _e$parentElement2;\n      return (_e$parentElement2 = e.parentElement) === null || _e$parentElement2 === void 0 ? void 0 : _e$parentElement2.insertBefore(_this45.templateContent, e);\n    });\n  },\n  prepend: function prepend() {\n    var _this46 = this;\n    this.removeDuplicateTargetChildren();\n    this.targetElements.forEach(function (e) {\n      return e.prepend(_this46.templateContent);\n    });\n  },\n  remove: function remove() {\n    this.targetElements.forEach(function (e) {\n      return e.remove();\n    });\n  },\n  replace: function replace() {\n    var _this47 = this;\n    var method = this.getAttribute(\"method\");\n    this.targetElements.forEach(function (targetElement) {\n      if (method === \"morph\") {\n        morphElements(targetElement, _this47.templateContent);\n      } else {\n        targetElement.replaceWith(_this47.templateContent);\n      }\n    });\n  },\n  update: function update() {\n    var _this48 = this;\n    var method = this.getAttribute(\"method\");\n    this.targetElements.forEach(function (targetElement) {\n      if (method === \"morph\") {\n        morphChildren(targetElement, _this48.templateContent);\n      } else {\n        targetElement.innerHTML = \"\";\n        targetElement.append(_this48.templateContent);\n      }\n    });\n  },\n  refresh: function refresh() {\n    session.refresh(this.baseURI, this.requestId);\n  }\n};\n\n// <turbo-stream action=replace target=id><template>...\n\n/**\n * Renders updates to the page from a stream of messages.\n *\n * Using the `action` attribute, this can be configured one of eight ways:\n *\n * - `after` - inserts the result after the target\n * - `append` - appends the result to the target\n * - `before` - inserts the result before the target\n * - `prepend` - prepends the result to the target\n * - `refresh` - initiates a page refresh\n * - `remove` - removes the target\n * - `replace` - replaces the outer HTML of the target\n * - `update` - replaces the inner HTML of the target\n *\n * @customElement turbo-stream\n * @example\n *   <turbo-stream action=\"append\" target=\"dom_id\">\n *     <template>\n *       Content to append to target designated with the dom_id.\n *     </template>\n *   </turbo-stream>\n */\nvar _raise = /*#__PURE__*/_classPrivateFieldLooseKey(\"raise\");\nvar StreamElement = /*#__PURE__*/function (_HTMLElement2) {\n  function StreamElement() {\n    var _this49;\n    _classCallCheck(this, StreamElement);\n    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      args[_key11] = arguments[_key11];\n    }\n    _this49 = _callSuper(this, StreamElement, [].concat(args));\n    Object.defineProperty(_this49, _raise, {\n      value: _raise2\n    });\n    return _this49;\n  }\n  _inherits(StreamElement, _HTMLElement2);\n  return _createClass(StreamElement, [{\n    key: \"connectedCallback\",\n    value: function () {\n      var _connectedCallback = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {\n        return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n          while (1) switch (_context42.prev = _context42.next) {\n            case 0:\n              _context42.prev = 0;\n              _context42.next = 3;\n              return this.render();\n            case 3:\n              _context42.next = 8;\n              break;\n            case 5:\n              _context42.prev = 5;\n              _context42.t0 = _context42[\"catch\"](0);\n              console.error(_context42.t0);\n            case 8:\n              _context42.prev = 8;\n              this.disconnect();\n              return _context42.finish(8);\n            case 11:\n            case \"end\":\n              return _context42.stop();\n          }\n        }, _callee42, this, [[0, 5, 8, 11]]);\n      }));\n      function connectedCallback() {\n        return _connectedCallback.apply(this, arguments);\n      }\n      return connectedCallback;\n    }()\n  }, {\n    key: \"render\",\n    value: function () {\n      var _render6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee44() {\n        var _this$renderPromise,\n          _this50 = this;\n        return _regeneratorRuntime().wrap(function _callee44$(_context44) {\n          while (1) switch (_context44.prev = _context44.next) {\n            case 0:\n              return _context44.abrupt(\"return\", (_this$renderPromise = this.renderPromise) !== null && _this$renderPromise !== void 0 ? _this$renderPromise : this.renderPromise = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {\n                var event;\n                return _regeneratorRuntime().wrap(function _callee43$(_context43) {\n                  while (1) switch (_context43.prev = _context43.next) {\n                    case 0:\n                      event = _this50.beforeRenderEvent;\n                      if (!_this50.dispatchEvent(event)) {\n                        _context43.next = 6;\n                        break;\n                      }\n                      _context43.next = 4;\n                      return nextRepaint();\n                    case 4:\n                      _context43.next = 6;\n                      return event.detail.render(_this50);\n                    case 6:\n                    case \"end\":\n                      return _context43.stop();\n                  }\n                }, _callee43);\n              }))());\n            case 1:\n            case \"end\":\n              return _context44.stop();\n          }\n        }, _callee44, this);\n      }));\n      function render() {\n        return _render6.apply(this, arguments);\n      }\n      return render;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      try {\n        this.remove();\n        // eslint-disable-next-line no-empty\n      } catch (_unused) {}\n    }\n\n    /**\n     * Removes duplicate children (by ID)\n     */\n  }, {\n    key: \"removeDuplicateTargetChildren\",\n    value: function removeDuplicateTargetChildren() {\n      this.duplicateChildren.forEach(function (c) {\n        return c.remove();\n      });\n    }\n\n    /**\n     * Gets the list of duplicate children (i.e. those with the same ID)\n     */\n  }, {\n    key: \"duplicateChildren\",\n    get: function get() {\n      var _this$templateContent;\n      var existingChildren = this.targetElements.flatMap(function (e) {\n        return _toConsumableArray(e.children);\n      }).filter(function (c) {\n        return !!c.id;\n      });\n      var newChildrenIds = _toConsumableArray(((_this$templateContent = this.templateContent) === null || _this$templateContent === void 0 ? void 0 : _this$templateContent.children) || []).filter(function (c) {\n        return !!c.id;\n      }).map(function (c) {\n        return c.id;\n      });\n      return existingChildren.filter(function (c) {\n        return newChildrenIds.includes(c.id);\n      });\n    }\n\n    /**\n     * Gets the action function to be performed.\n     */\n  }, {\n    key: \"performAction\",\n    get: function get() {\n      if (this.action) {\n        var actionFunction = StreamActions[this.action];\n        if (actionFunction) {\n          return actionFunction;\n        }\n        _classPrivateFieldLooseBase(this, _raise)[_raise](\"unknown action\");\n      }\n      _classPrivateFieldLooseBase(this, _raise)[_raise](\"action attribute is missing\");\n    }\n\n    /**\n     * Gets the target elements which the template will be rendered to.\n     */\n  }, {\n    key: \"targetElements\",\n    get: function get() {\n      if (this.target) {\n        return this.targetElementsById;\n      } else if (this.targets) {\n        return this.targetElementsByQuery;\n      } else {\n        _classPrivateFieldLooseBase(this, _raise)[_raise](\"target or targets attribute is missing\");\n      }\n    }\n\n    /**\n     * Gets the contents of the main `<template>`.\n     */\n  }, {\n    key: \"templateContent\",\n    get: function get() {\n      return this.templateElement.content.cloneNode(true);\n    }\n\n    /**\n     * Gets the main `<template>` used for rendering\n     */\n  }, {\n    key: \"templateElement\",\n    get: function get() {\n      if (this.firstElementChild === null) {\n        var template = this.ownerDocument.createElement(\"template\");\n        this.appendChild(template);\n        return template;\n      } else if (this.firstElementChild instanceof HTMLTemplateElement) {\n        return this.firstElementChild;\n      }\n      _classPrivateFieldLooseBase(this, _raise)[_raise](\"first child element must be a <template> element\");\n    }\n\n    /**\n     * Gets the current action.\n     */\n  }, {\n    key: \"action\",\n    get: function get() {\n      return this.getAttribute(\"action\");\n    }\n\n    /**\n     * Gets the current target (an element ID) to which the result will\n     * be rendered.\n     */\n  }, {\n    key: \"target\",\n    get: function get() {\n      return this.getAttribute(\"target\");\n    }\n\n    /**\n     * Gets the current \"targets\" selector (a CSS selector)\n     */\n  }, {\n    key: \"targets\",\n    get: function get() {\n      return this.getAttribute(\"targets\");\n    }\n\n    /**\n     * Reads the request-id attribute\n     */\n  }, {\n    key: \"requestId\",\n    get: function get() {\n      return this.getAttribute(\"request-id\");\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      var _2, _this$outerHTML$match;\n      return (_2 = ((_this$outerHTML$match = this.outerHTML.match(/<[^>]+>/)) !== null && _this$outerHTML$match !== void 0 ? _this$outerHTML$match : [])[0]) !== null && _2 !== void 0 ? _2 : \"<turbo-stream>\";\n    }\n  }, {\n    key: \"beforeRenderEvent\",\n    get: function get() {\n      return new CustomEvent(\"turbo:before-stream-render\", {\n        bubbles: true,\n        cancelable: true,\n        detail: {\n          newStream: this,\n          render: StreamElement.renderElement\n        }\n      });\n    }\n  }, {\n    key: \"targetElementsById\",\n    get: function get() {\n      var _this$ownerDocument2;\n      var element = (_this$ownerDocument2 = this.ownerDocument) === null || _this$ownerDocument2 === void 0 ? void 0 : _this$ownerDocument2.getElementById(this.target);\n      if (element !== null) {\n        return [element];\n      } else {\n        return [];\n      }\n    }\n  }, {\n    key: \"targetElementsByQuery\",\n    get: function get() {\n      var _this$ownerDocument3;\n      var elements = (_this$ownerDocument3 = this.ownerDocument) === null || _this$ownerDocument3 === void 0 ? void 0 : _this$ownerDocument3.querySelectorAll(this.targets);\n      if (elements.length !== 0) {\n        return Array.prototype.slice.call(elements);\n      } else {\n        return [];\n      }\n    }\n  }], [{\n    key: \"renderElement\",\n    value: function () {\n      var _renderElement = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee45(newElement) {\n        return _regeneratorRuntime().wrap(function _callee45$(_context45) {\n          while (1) switch (_context45.prev = _context45.next) {\n            case 0:\n              _context45.next = 2;\n              return newElement.performAction();\n            case 2:\n            case \"end\":\n              return _context45.stop();\n          }\n        }, _callee45);\n      }));\n      function renderElement(_x39) {\n        return _renderElement.apply(this, arguments);\n      }\n      return renderElement;\n    }()\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(HTMLElement));\nfunction _raise2(message) {\n  throw new Error(\"\".concat(this.description, \": \").concat(message));\n}\nvar StreamSourceElement = /*#__PURE__*/function (_HTMLElement3) {\n  function StreamSourceElement() {\n    var _this51;\n    _classCallCheck(this, StreamSourceElement);\n    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      args[_key12] = arguments[_key12];\n    }\n    _this51 = _callSuper(this, StreamSourceElement, [].concat(args));\n    _this51.streamSource = null;\n    return _this51;\n  }\n  _inherits(StreamSourceElement, _HTMLElement3);\n  return _createClass(StreamSourceElement, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);\n      connectStreamSource(this.streamSource);\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      if (this.streamSource) {\n        this.streamSource.close();\n        disconnectStreamSource(this.streamSource);\n      }\n    }\n  }, {\n    key: \"src\",\n    get: function get() {\n      return this.getAttribute(\"src\") || \"\";\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(HTMLElement));\nFrameElement.delegateConstructor = FrameController;\nif (customElements.get(\"turbo-frame\") === undefined) {\n  customElements.define(\"turbo-frame\", FrameElement);\n}\nif (customElements.get(\"turbo-stream\") === undefined) {\n  customElements.define(\"turbo-stream\", StreamElement);\n}\nif (customElements.get(\"turbo-stream-source\") === undefined) {\n  customElements.define(\"turbo-stream-source\", StreamSourceElement);\n}\n(function () {\n  var element = document.currentScript;\n  if (!element) return;\n  if (element.hasAttribute(\"data-turbo-suppress-warning\")) return;\n  element = element.parentElement;\n  while (element) {\n    if (element == document.body) {\n      return console.warn(unindent(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!\\n\\n        Load your application\\u2019s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\\n\\n        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements\\n\\n        \\u2014\\u2014\\n        Suppress this warning by adding a \\\"data-turbo-suppress-warning\\\" attribute to: %s\\n      \"]))), element.outerHTML);\n    }\n    element = element.parentElement;\n  }\n})();\nwindow.Turbo = _objectSpread(_objectSpread({}, Turbo), {}, {\n  StreamActions: StreamActions\n});\nstart();\nexport { FetchEnctype, FetchMethod, FetchRequest, FetchResponse, FrameElement, FrameLoadingStyle, FrameRenderer, PageRenderer, PageSnapshot, StreamActions, StreamElement, StreamSourceElement, cache, clearCache, config, connectStreamSource, disconnectStreamSource, fetchWithTurboHeaders as fetch, fetchEnctypeFromString, fetchMethodFromString, isSafe, navigator$1 as navigator, registerAdapter, renderStreamMessage, session, setConfirmMethod, setFormMode, setProgressBarDelay, start, visit };","map":null,"metadata":{},"sourceType":"module"}