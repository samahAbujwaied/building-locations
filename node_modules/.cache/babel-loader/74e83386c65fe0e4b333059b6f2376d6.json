{"ast":null,"code":"function _readOnlyError(r) { throw new TypeError('\"' + r + '\" is read-only'); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport adapters from \"./adapters\";\nimport ConnectionMonitor from \"./connection_monitor\";\nimport INTERNAL from \"./internal\";\nimport logger from \"./logger\";\n\n// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nvar message_types = INTERNAL.message_types,\n  protocols = INTERNAL.protocols;\nvar supportedProtocols = protocols.slice(0, protocols.length - 1);\nvar indexOf = [].indexOf;\nvar Connection = /*#__PURE__*/function () {\n  function Connection(consumer) {\n    _classCallCheck(this, Connection);\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  return _createClass(Connection, [{\n    key: \"send\",\n    value: function send(data) {\n      if (this.isOpen()) {\n        this.webSocket.send(JSON.stringify(data));\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"open\",\n    value: function open() {\n      if (this.isActive()) {\n        logger.log(\"Attempted to open WebSocket, but existing socket is \".concat(this.getState()));\n        return false;\n      } else {\n        var socketProtocols = [].concat(_toConsumableArray(protocols), _toConsumableArray(this.consumer.subprotocols || []));\n        logger.log(\"Opening WebSocket, current state is \".concat(this.getState(), \", subprotocols: \").concat(socketProtocols));\n        if (this.webSocket) {\n          this.uninstallEventHandlers();\n        }\n        this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n        this.installEventHandlers();\n        this.monitor.start();\n        return true;\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n          allowReconnect: true\n        },\n        allowReconnect = _ref.allowReconnect;\n      if (!allowReconnect) {\n        this.monitor.stop();\n      }\n      // Avoid closing websockets in a \"connecting\" state due to Safari 15.1+ bug. See: https://github.com/rails/rails/issues/43835#issuecomment-1002288478\n      if (this.isOpen()) {\n        return this.webSocket.close();\n      }\n    }\n  }, {\n    key: \"reopen\",\n    value: function reopen() {\n      logger.log(\"Reopening WebSocket, current state is \".concat(this.getState()));\n      if (this.isActive()) {\n        try {\n          return this.close();\n        } catch (error) {\n          logger.log(\"Failed to reopen WebSocket\", error);\n        } finally {\n          logger.log(\"Reopening WebSocket in \".concat(this.constructor.reopenDelay, \"ms\"));\n          setTimeout(this.open, this.constructor.reopenDelay);\n        }\n      } else {\n        return this.open();\n      }\n    }\n  }, {\n    key: \"getProtocol\",\n    value: function getProtocol() {\n      if (this.webSocket) {\n        return this.webSocket.protocol;\n      }\n    }\n  }, {\n    key: \"isOpen\",\n    value: function isOpen() {\n      return this.isState(\"open\");\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.isState(\"open\", \"connecting\");\n    }\n  }, {\n    key: \"triedToReconnect\",\n    value: function triedToReconnect() {\n      return this.monitor.reconnectAttempts > 0;\n    }\n\n    // Private\n  }, {\n    key: \"isProtocolSupported\",\n    value: function isProtocolSupported() {\n      return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n    }\n  }, {\n    key: \"isState\",\n    value: function isState() {\n      for (var _len = arguments.length, states = new Array(_len), _key = 0; _key < _len; _key++) {\n        states[_key] = arguments[_key];\n      }\n      return indexOf.call(states, this.getState()) >= 0;\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      if (this.webSocket) {\n        for (var state in adapters.WebSocket) {\n          if (adapters.WebSocket[state] === this.webSocket.readyState) {\n            return state.toLowerCase();\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"installEventHandlers\",\n    value: function installEventHandlers() {\n      for (var eventName in this.events) {\n        var handler = this.events[eventName].bind(this);\n        this.webSocket[\"on\".concat(eventName)] = handler;\n      }\n    }\n  }, {\n    key: \"uninstallEventHandlers\",\n    value: function uninstallEventHandlers() {\n      for (var eventName in this.events) {\n        this.webSocket[\"on\".concat(eventName)] = function () {};\n      }\n    }\n  }]);\n}();\nConnection.reopenDelay = 500;\nConnection.prototype.events = {\n  message: function message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    var _JSON$parse = JSON.parse(event.data),\n      identifier = _JSON$parse.identifier,\n      message = _JSON$parse.message,\n      reason = _JSON$parse.reason,\n      reconnect = _JSON$parse.reconnect,\n      type = _JSON$parse.type;\n    this.monitor.recordMessage();\n    switch (type) {\n      case message_types.welcome:\n        if (this.triedToReconnect()) {\n          this.reconnectAttempted = true;\n        }\n        this.monitor.recordConnect();\n        return this.subscriptions.reload();\n      case message_types.disconnect:\n        logger.log(\"Disconnecting. Reason: \".concat(reason));\n        return this.close({\n          allowReconnect: reconnect\n        });\n      case message_types.ping:\n        return null;\n      case message_types.confirmation:\n        this.subscriptions.confirmSubscription(identifier);\n        if (this.reconnectAttempted) {\n          this.reconnectAttempted = false;\n          return this.subscriptions.notify(identifier, \"connected\", {\n            reconnected: true\n          });\n        } else {\n          return this.subscriptions.notify(identifier, \"connected\", {\n            reconnected: false\n          });\n        }\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier);\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open: function open() {\n    logger.log(\"WebSocket onopen event, using '\".concat(this.getProtocol(), \"' subprotocol\"));\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close: function close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error: function error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\nexport default Connection;","map":null,"metadata":{},"sourceType":"module"}